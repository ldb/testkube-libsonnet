{
  local d = (import 'doc-util/main.libsonnet'),
  '#':: d.pkg(name='testWorkflowTemplate', url='', help='"TestWorkflowTemplate is the Schema for the workflows API"'),
  '#metadata':: d.obj(help='"ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create."'),
  metadata: {
    '#withAnnotations':: d.fn(help='"Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations"', args=[d.arg(name='annotations', type=d.T.object)]),
    withAnnotations(annotations): { metadata+: { annotations: annotations } },
    '#withAnnotationsMixin':: d.fn(help='"Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='annotations', type=d.T.object)]),
    withAnnotationsMixin(annotations): { metadata+: { annotations+: annotations } },
    '#withClusterName':: d.fn(help='"The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request."', args=[d.arg(name='clusterName', type=d.T.string)]),
    withClusterName(clusterName): { metadata+: { clusterName: clusterName } },
    '#withCreationTimestamp':: d.fn(help='"Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers."', args=[d.arg(name='creationTimestamp', type=d.T.string)]),
    withCreationTimestamp(creationTimestamp): { metadata+: { creationTimestamp: creationTimestamp } },
    '#withDeletionGracePeriodSeconds':: d.fn(help='"Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only."', args=[d.arg(name='deletionGracePeriodSeconds', type=d.T.integer)]),
    withDeletionGracePeriodSeconds(deletionGracePeriodSeconds): { metadata+: { deletionGracePeriodSeconds: deletionGracePeriodSeconds } },
    '#withDeletionTimestamp':: d.fn(help='"Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers."', args=[d.arg(name='deletionTimestamp', type=d.T.string)]),
    withDeletionTimestamp(deletionTimestamp): { metadata+: { deletionTimestamp: deletionTimestamp } },
    '#withFinalizers':: d.fn(help='"Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order.  Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list."', args=[d.arg(name='finalizers', type=d.T.array)]),
    withFinalizers(finalizers): { metadata+: { finalizers: if std.isArray(v=finalizers) then finalizers else [finalizers] } },
    '#withFinalizersMixin':: d.fn(help='"Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order.  Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='finalizers', type=d.T.array)]),
    withFinalizersMixin(finalizers): { metadata+: { finalizers+: if std.isArray(v=finalizers) then finalizers else [finalizers] } },
    '#withGenerateName':: d.fn(help='"GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.\\n\\nIf this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).\\n\\nApplied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency"', args=[d.arg(name='generateName', type=d.T.string)]),
    withGenerateName(generateName): { metadata+: { generateName: generateName } },
    '#withGeneration':: d.fn(help='"A sequence number representing a specific generation of the desired state. Populated by the system. Read-only."', args=[d.arg(name='generation', type=d.T.integer)]),
    withGeneration(generation): { metadata+: { generation: generation } },
    '#withLabels':: d.fn(help='"Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels"', args=[d.arg(name='labels', type=d.T.object)]),
    withLabels(labels): { metadata+: { labels: labels } },
    '#withLabelsMixin':: d.fn(help='"Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='labels', type=d.T.object)]),
    withLabelsMixin(labels): { metadata+: { labels+: labels } },
    '#withName':: d.fn(help='"Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names"', args=[d.arg(name='name', type=d.T.string)]),
    withName(name): { metadata+: { name: name } },
    '#withNamespace':: d.fn(help='"Namespace defines the space within which each name must be unique. An empty namespace is equivalent to the \\"default\\" namespace, but \\"default\\" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.\\n\\nMust be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces"', args=[d.arg(name='namespace', type=d.T.string)]),
    withNamespace(namespace): { metadata+: { namespace: namespace } },
    '#withOwnerReferences':: d.fn(help='"List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller."', args=[d.arg(name='ownerReferences', type=d.T.array)]),
    withOwnerReferences(ownerReferences): { metadata+: { ownerReferences: if std.isArray(v=ownerReferences) then ownerReferences else [ownerReferences] } },
    '#withOwnerReferencesMixin':: d.fn(help='"List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='ownerReferences', type=d.T.array)]),
    withOwnerReferencesMixin(ownerReferences): { metadata+: { ownerReferences+: if std.isArray(v=ownerReferences) then ownerReferences else [ownerReferences] } },
    '#withResourceVersion':: d.fn(help='"An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server. They may only be valid for a particular resource or set of resources.\\n\\nPopulated by the system. Read-only. Value must be treated as opaque by clients and . More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency"', args=[d.arg(name='resourceVersion', type=d.T.string)]),
    withResourceVersion(resourceVersion): { metadata+: { resourceVersion: resourceVersion } },
    '#withSelfLink':: d.fn(help='"SelfLink is a URL representing this object. Populated by the system. Read-only.\\n\\nDEPRECATED Kubernetes will stop propagating this field in 1.20 release and the field is planned to be removed in 1.21 release."', args=[d.arg(name='selfLink', type=d.T.string)]),
    withSelfLink(selfLink): { metadata+: { selfLink: selfLink } },
    '#withUid':: d.fn(help='"UID is the unique in time and space value for this object. It is typically generated by the server on successful creation of a resource and is not allowed to change on PUT operations.\\n\\nPopulated by the system. Read-only. More info: http://kubernetes.io/docs/user-guide/identifiers#uids"', args=[d.arg(name='uid', type=d.T.string)]),
    withUid(uid): { metadata+: { uid: uid } },
  },
  '#new':: d.fn(help='new returns an instance of TestWorkflowTemplate', args=[d.arg(name='name', type=d.T.string)]),
  new(name): {
    apiVersion: 'testworkflows.testkube.io/v1',
    kind: 'TestWorkflowTemplate',
  } + self.metadata.withName(name=name),
  '#spec':: d.obj(help='"TestWorkflowTemplate specification"'),
  spec: {
    '#after':: d.obj(help='"steps to run at the end of the workflow"'),
    after: {
      '#artifacts':: d.obj(help='"scrape artifacts from the volumes"'),
      artifacts: {
        '#compress':: d.obj(help='"compression options for the artifacts"'),
        compress: {
          '#withName':: d.fn(help='"artifact name"', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { artifacts+: { compress+: { name: name } } },
        },
        '#withPaths':: d.fn(help='"paths to fetch from the container"', args=[d.arg(name='paths', type=d.T.array)]),
        withPaths(paths): { artifacts+: { paths: if std.isArray(v=paths) then paths else [paths] } },
        '#withPathsMixin':: d.fn(help='"paths to fetch from the container"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='paths', type=d.T.array)]),
        withPathsMixin(paths): { artifacts+: { paths+: if std.isArray(v=paths) then paths else [paths] } },
        '#withWorkingDir':: d.fn(help='"working directory to override, so it will be used as a base dir"', args=[d.arg(name='workingDir', type=d.T.string)]),
        withWorkingDir(workingDir): { artifacts+: { workingDir: workingDir } },
      },
      '#container':: d.obj(help='"defaults for the containers in this step"'),
      container: {
        '#env':: d.obj(help=''),
        env: {
          '#valueFrom':: d.obj(help=''),
          valueFrom: {
            '#configMapKeyRef':: d.obj(help=''),
            configMapKeyRef: {
              '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { valueFrom+: { configMapKeyRef+: { key: key } } },
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { valueFrom+: { configMapKeyRef+: { name: name } } },
              '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { valueFrom+: { configMapKeyRef+: { optional: optional } } },
            },
            '#fieldRef':: d.obj(help=''),
            fieldRef: {
              '#withApiVersion':: d.fn(help='', args=[d.arg(name='apiVersion', type=d.T.string)]),
              withApiVersion(apiVersion): { valueFrom+: { fieldRef+: { apiVersion: apiVersion } } },
              '#withFieldPath':: d.fn(help='', args=[d.arg(name='fieldPath', type=d.T.string)]),
              withFieldPath(fieldPath): { valueFrom+: { fieldRef+: { fieldPath: fieldPath } } },
            },
            '#resourceFieldRef':: d.obj(help=''),
            resourceFieldRef: {
              '#withContainerName':: d.fn(help='', args=[d.arg(name='containerName', type=d.T.string)]),
              withContainerName(containerName): { valueFrom+: { resourceFieldRef+: { containerName: containerName } } },
              '#withDivisor':: d.fn(help='', args=[d.arg(name='divisor', type=d.T.any)]),
              withDivisor(divisor): { valueFrom+: { resourceFieldRef+: { divisor: divisor } } },
              '#withResource':: d.fn(help='', args=[d.arg(name='resource', type=d.T.string)]),
              withResource(resource): { valueFrom+: { resourceFieldRef+: { resource: resource } } },
            },
            '#secretKeyRef':: d.obj(help=''),
            secretKeyRef: {
              '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { valueFrom+: { secretKeyRef+: { key: key } } },
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { valueFrom+: { secretKeyRef+: { name: name } } },
              '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { valueFrom+: { secretKeyRef+: { optional: optional } } },
            },
          },
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { name: name },
          '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#envFrom':: d.obj(help=''),
        envFrom: {
          '#configMapRef':: d.obj(help=''),
          configMapRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { configMapRef+: { name: name } },
            '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { configMapRef+: { optional: optional } },
          },
          '#secretRef':: d.obj(help=''),
          secretRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { secretRef+: { name: name } },
            '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { secretRef+: { optional: optional } },
          },
          '#withPrefix':: d.fn(help='', args=[d.arg(name='prefix', type=d.T.string)]),
          withPrefix(prefix): { prefix: prefix },
        },
        '#resources':: d.obj(help='"expected resources for the container"'),
        resources: {
          '#withLimits':: d.fn(help='"resource limits for the container"', args=[d.arg(name='limits', type=d.T.object)]),
          withLimits(limits): { container+: { resources+: { limits: limits } } },
          '#withLimitsMixin':: d.fn(help='"resource limits for the container"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='limits', type=d.T.object)]),
          withLimitsMixin(limits): { container+: { resources+: { limits+: limits } } },
          '#withRequests':: d.fn(help='"resource requests for the container"', args=[d.arg(name='requests', type=d.T.object)]),
          withRequests(requests): { container+: { resources+: { requests: requests } } },
          '#withRequestsMixin':: d.fn(help='"resource requests for the container"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requests', type=d.T.object)]),
          withRequestsMixin(requests): { container+: { resources+: { requests+: requests } } },
        },
        '#securityContext':: d.obj(help=''),
        securityContext: {
          '#appArmorProfile':: d.obj(help=''),
          appArmorProfile: {
            '#withLocalhostProfile':: d.fn(help='', args=[d.arg(name='localhostProfile', type=d.T.string)]),
            withLocalhostProfile(localhostProfile): { container+: { securityContext+: { appArmorProfile+: { localhostProfile: localhostProfile } } } },
            '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
            withType(type): { container+: { securityContext+: { appArmorProfile+: { type: type } } } },
          },
          '#capabilities':: d.obj(help=''),
          capabilities: {
            '#withAdd':: d.fn(help='', args=[d.arg(name='add', type=d.T.array)]),
            withAdd(add): { container+: { securityContext+: { capabilities+: { add: if std.isArray(v=add) then add else [add] } } } },
            '#withAddMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='add', type=d.T.array)]),
            withAddMixin(add): { container+: { securityContext+: { capabilities+: { add+: if std.isArray(v=add) then add else [add] } } } },
            '#withDrop':: d.fn(help='', args=[d.arg(name='drop', type=d.T.array)]),
            withDrop(drop): { container+: { securityContext+: { capabilities+: { drop: if std.isArray(v=drop) then drop else [drop] } } } },
            '#withDropMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='drop', type=d.T.array)]),
            withDropMixin(drop): { container+: { securityContext+: { capabilities+: { drop+: if std.isArray(v=drop) then drop else [drop] } } } },
          },
          '#seLinuxOptions':: d.obj(help=''),
          seLinuxOptions: {
            '#withLevel':: d.fn(help='', args=[d.arg(name='level', type=d.T.string)]),
            withLevel(level): { container+: { securityContext+: { seLinuxOptions+: { level: level } } } },
            '#withRole':: d.fn(help='', args=[d.arg(name='role', type=d.T.string)]),
            withRole(role): { container+: { securityContext+: { seLinuxOptions+: { role: role } } } },
            '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
            withType(type): { container+: { securityContext+: { seLinuxOptions+: { type: type } } } },
            '#withUser':: d.fn(help='', args=[d.arg(name='user', type=d.T.string)]),
            withUser(user): { container+: { securityContext+: { seLinuxOptions+: { user: user } } } },
          },
          '#seccompProfile':: d.obj(help=''),
          seccompProfile: {
            '#withLocalhostProfile':: d.fn(help='', args=[d.arg(name='localhostProfile', type=d.T.string)]),
            withLocalhostProfile(localhostProfile): { container+: { securityContext+: { seccompProfile+: { localhostProfile: localhostProfile } } } },
            '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
            withType(type): { container+: { securityContext+: { seccompProfile+: { type: type } } } },
          },
          '#windowsOptions':: d.obj(help=''),
          windowsOptions: {
            '#withGmsaCredentialSpec':: d.fn(help='', args=[d.arg(name='gmsaCredentialSpec', type=d.T.string)]),
            withGmsaCredentialSpec(gmsaCredentialSpec): { container+: { securityContext+: { windowsOptions+: { gmsaCredentialSpec: gmsaCredentialSpec } } } },
            '#withGmsaCredentialSpecName':: d.fn(help='', args=[d.arg(name='gmsaCredentialSpecName', type=d.T.string)]),
            withGmsaCredentialSpecName(gmsaCredentialSpecName): { container+: { securityContext+: { windowsOptions+: { gmsaCredentialSpecName: gmsaCredentialSpecName } } } },
            '#withHostProcess':: d.fn(help='', args=[d.arg(name='hostProcess', type=d.T.boolean)]),
            withHostProcess(hostProcess): { container+: { securityContext+: { windowsOptions+: { hostProcess: hostProcess } } } },
            '#withRunAsUserName':: d.fn(help='', args=[d.arg(name='runAsUserName', type=d.T.string)]),
            withRunAsUserName(runAsUserName): { container+: { securityContext+: { windowsOptions+: { runAsUserName: runAsUserName } } } },
          },
          '#withAllowPrivilegeEscalation':: d.fn(help='', args=[d.arg(name='allowPrivilegeEscalation', type=d.T.boolean)]),
          withAllowPrivilegeEscalation(allowPrivilegeEscalation): { container+: { securityContext+: { allowPrivilegeEscalation: allowPrivilegeEscalation } } },
          '#withPrivileged':: d.fn(help='', args=[d.arg(name='privileged', type=d.T.boolean)]),
          withPrivileged(privileged): { container+: { securityContext+: { privileged: privileged } } },
          '#withProcMount':: d.fn(help='', args=[d.arg(name='procMount', type=d.T.string)]),
          withProcMount(procMount): { container+: { securityContext+: { procMount: procMount } } },
          '#withReadOnlyRootFilesystem':: d.fn(help='', args=[d.arg(name='readOnlyRootFilesystem', type=d.T.boolean)]),
          withReadOnlyRootFilesystem(readOnlyRootFilesystem): { container+: { securityContext+: { readOnlyRootFilesystem: readOnlyRootFilesystem } } },
          '#withRunAsGroup':: d.fn(help='', args=[d.arg(name='runAsGroup', type=d.T.integer)]),
          withRunAsGroup(runAsGroup): { container+: { securityContext+: { runAsGroup: runAsGroup } } },
          '#withRunAsNonRoot':: d.fn(help='', args=[d.arg(name='runAsNonRoot', type=d.T.boolean)]),
          withRunAsNonRoot(runAsNonRoot): { container+: { securityContext+: { runAsNonRoot: runAsNonRoot } } },
          '#withRunAsUser':: d.fn(help='', args=[d.arg(name='runAsUser', type=d.T.integer)]),
          withRunAsUser(runAsUser): { container+: { securityContext+: { runAsUser: runAsUser } } },
        },
        '#volumeMounts':: d.obj(help=''),
        volumeMounts: {
          '#withMountPath':: d.fn(help='', args=[d.arg(name='mountPath', type=d.T.string)]),
          withMountPath(mountPath): { mountPath: mountPath },
          '#withMountPropagation':: d.fn(help='', args=[d.arg(name='mountPropagation', type=d.T.string)]),
          withMountPropagation(mountPropagation): { mountPropagation: mountPropagation },
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { name: name },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { readOnly: readOnly },
          '#withRecursiveReadOnly':: d.fn(help='', args=[d.arg(name='recursiveReadOnly', type=d.T.string)]),
          withRecursiveReadOnly(recursiveReadOnly): { recursiveReadOnly: recursiveReadOnly },
          '#withSubPath':: d.fn(help='', args=[d.arg(name='subPath', type=d.T.string)]),
          withSubPath(subPath): { subPath: subPath },
          '#withSubPathExpr':: d.fn(help='', args=[d.arg(name='subPathExpr', type=d.T.string)]),
          withSubPathExpr(subPathExpr): { subPathExpr: subPathExpr },
        },
        '#withArgs':: d.fn(help='"override default command in the image (empty string to default CMD of the image)"', args=[d.arg(name='args', type=d.T.array)]),
        withArgs(args): { container+: { args: if std.isArray(v=args) then args else [args] } },
        '#withArgsMixin':: d.fn(help='"override default command in the image (empty string to default CMD of the image)"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='args', type=d.T.array)]),
        withArgsMixin(args): { container+: { args+: if std.isArray(v=args) then args else [args] } },
        '#withCommand':: d.fn(help='"override default command in the image (empty string to default ENTRYPOINT of the image)"', args=[d.arg(name='command', type=d.T.array)]),
        withCommand(command): { container+: { command: if std.isArray(v=command) then command else [command] } },
        '#withCommandMixin':: d.fn(help='"override default command in the image (empty string to default ENTRYPOINT of the image)"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='command', type=d.T.array)]),
        withCommandMixin(command): { container+: { command+: if std.isArray(v=command) then command else [command] } },
        '#withEnv':: d.fn(help='', args=[d.arg(name='env', type=d.T.array)]),
        withEnv(env): { container+: { env: if std.isArray(v=env) then env else [env] } },
        '#withEnvFrom':: d.fn(help='', args=[d.arg(name='envFrom', type=d.T.array)]),
        withEnvFrom(envFrom): { container+: { envFrom: if std.isArray(v=envFrom) then envFrom else [envFrom] } },
        '#withEnvFromMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='envFrom', type=d.T.array)]),
        withEnvFromMixin(envFrom): { container+: { envFrom+: if std.isArray(v=envFrom) then envFrom else [envFrom] } },
        '#withEnvMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='env', type=d.T.array)]),
        withEnvMixin(env): { container+: { env+: if std.isArray(v=env) then env else [env] } },
        '#withImage':: d.fn(help='"image to be used for the container"', args=[d.arg(name='image', type=d.T.string)]),
        withImage(image): { container+: { image: image } },
        '#withImagePullPolicy':: d.fn(help='"pulling policy for the image"', args=[d.arg(name='imagePullPolicy', type=d.T.string)]),
        withImagePullPolicy(imagePullPolicy): { container+: { imagePullPolicy: imagePullPolicy } },
        '#withVolumeMounts':: d.fn(help='', args=[d.arg(name='volumeMounts', type=d.T.array)]),
        withVolumeMounts(volumeMounts): { container+: { volumeMounts: if std.isArray(v=volumeMounts) then volumeMounts else [volumeMounts] } },
        '#withVolumeMountsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='volumeMounts', type=d.T.array)]),
        withVolumeMountsMixin(volumeMounts): { container+: { volumeMounts+: if std.isArray(v=volumeMounts) then volumeMounts else [volumeMounts] } },
        '#withWorkingDir':: d.fn(help='"override default working directory in the image (empty string to default WORKDIR for the image)"', args=[d.arg(name='workingDir', type=d.T.string)]),
        withWorkingDir(workingDir): { container+: { workingDir: workingDir } },
      },
      '#content':: d.obj(help='"content that should be fetched for this step"'),
      content: {
        '#files':: d.obj(help='"files to load"'),
        files: {
          '#contentFrom':: d.obj(help='"external source to use"'),
          contentFrom: {
            '#configMapKeyRef':: d.obj(help=''),
            configMapKeyRef: {
              '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { contentFrom+: { configMapKeyRef+: { key: key } } },
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { contentFrom+: { configMapKeyRef+: { name: name } } },
              '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { contentFrom+: { configMapKeyRef+: { optional: optional } } },
            },
            '#fieldRef':: d.obj(help=''),
            fieldRef: {
              '#withApiVersion':: d.fn(help='', args=[d.arg(name='apiVersion', type=d.T.string)]),
              withApiVersion(apiVersion): { contentFrom+: { fieldRef+: { apiVersion: apiVersion } } },
              '#withFieldPath':: d.fn(help='', args=[d.arg(name='fieldPath', type=d.T.string)]),
              withFieldPath(fieldPath): { contentFrom+: { fieldRef+: { fieldPath: fieldPath } } },
            },
            '#resourceFieldRef':: d.obj(help=''),
            resourceFieldRef: {
              '#withContainerName':: d.fn(help='', args=[d.arg(name='containerName', type=d.T.string)]),
              withContainerName(containerName): { contentFrom+: { resourceFieldRef+: { containerName: containerName } } },
              '#withDivisor':: d.fn(help='', args=[d.arg(name='divisor', type=d.T.any)]),
              withDivisor(divisor): { contentFrom+: { resourceFieldRef+: { divisor: divisor } } },
              '#withResource':: d.fn(help='', args=[d.arg(name='resource', type=d.T.string)]),
              withResource(resource): { contentFrom+: { resourceFieldRef+: { resource: resource } } },
            },
            '#secretKeyRef':: d.obj(help=''),
            secretKeyRef: {
              '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { contentFrom+: { secretKeyRef+: { key: key } } },
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { contentFrom+: { secretKeyRef+: { name: name } } },
              '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { contentFrom+: { secretKeyRef+: { optional: optional } } },
            },
          },
          '#withContent':: d.fn(help='"plain-text content to put inside"', args=[d.arg(name='content', type=d.T.string)]),
          withContent(content): { content: content },
          '#withMode':: d.fn(help='"mode to use for the file"', args=[d.arg(name='mode', type=d.T.integer)]),
          withMode(mode): { mode: mode },
          '#withPath':: d.fn(help='"path where the file should be accessible at"', args=[d.arg(name='path', type=d.T.string)]),
          withPath(path): { path: path },
        },
        '#git':: d.obj(help='"git repository details"'),
        git: {
          '#sshKeyFrom':: d.obj(help='"external SSH private key to fetch with"'),
          sshKeyFrom: {
            '#configMapKeyRef':: d.obj(help=''),
            configMapKeyRef: {
              '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { content+: { git+: { sshKeyFrom+: { configMapKeyRef+: { key: key } } } } },
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { content+: { git+: { sshKeyFrom+: { configMapKeyRef+: { name: name } } } } },
              '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { content+: { git+: { sshKeyFrom+: { configMapKeyRef+: { optional: optional } } } } },
            },
            '#fieldRef':: d.obj(help=''),
            fieldRef: {
              '#withApiVersion':: d.fn(help='', args=[d.arg(name='apiVersion', type=d.T.string)]),
              withApiVersion(apiVersion): { content+: { git+: { sshKeyFrom+: { fieldRef+: { apiVersion: apiVersion } } } } },
              '#withFieldPath':: d.fn(help='', args=[d.arg(name='fieldPath', type=d.T.string)]),
              withFieldPath(fieldPath): { content+: { git+: { sshKeyFrom+: { fieldRef+: { fieldPath: fieldPath } } } } },
            },
            '#resourceFieldRef':: d.obj(help=''),
            resourceFieldRef: {
              '#withContainerName':: d.fn(help='', args=[d.arg(name='containerName', type=d.T.string)]),
              withContainerName(containerName): { content+: { git+: { sshKeyFrom+: { resourceFieldRef+: { containerName: containerName } } } } },
              '#withDivisor':: d.fn(help='', args=[d.arg(name='divisor', type=d.T.any)]),
              withDivisor(divisor): { content+: { git+: { sshKeyFrom+: { resourceFieldRef+: { divisor: divisor } } } } },
              '#withResource':: d.fn(help='', args=[d.arg(name='resource', type=d.T.string)]),
              withResource(resource): { content+: { git+: { sshKeyFrom+: { resourceFieldRef+: { resource: resource } } } } },
            },
            '#secretKeyRef':: d.obj(help=''),
            secretKeyRef: {
              '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { content+: { git+: { sshKeyFrom+: { secretKeyRef+: { key: key } } } } },
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { content+: { git+: { sshKeyFrom+: { secretKeyRef+: { name: name } } } } },
              '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { content+: { git+: { sshKeyFrom+: { secretKeyRef+: { optional: optional } } } } },
            },
          },
          '#tokenFrom':: d.obj(help='"external token to fetch with"'),
          tokenFrom: {
            '#configMapKeyRef':: d.obj(help=''),
            configMapKeyRef: {
              '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { content+: { git+: { tokenFrom+: { configMapKeyRef+: { key: key } } } } },
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { content+: { git+: { tokenFrom+: { configMapKeyRef+: { name: name } } } } },
              '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { content+: { git+: { tokenFrom+: { configMapKeyRef+: { optional: optional } } } } },
            },
            '#fieldRef':: d.obj(help=''),
            fieldRef: {
              '#withApiVersion':: d.fn(help='', args=[d.arg(name='apiVersion', type=d.T.string)]),
              withApiVersion(apiVersion): { content+: { git+: { tokenFrom+: { fieldRef+: { apiVersion: apiVersion } } } } },
              '#withFieldPath':: d.fn(help='', args=[d.arg(name='fieldPath', type=d.T.string)]),
              withFieldPath(fieldPath): { content+: { git+: { tokenFrom+: { fieldRef+: { fieldPath: fieldPath } } } } },
            },
            '#resourceFieldRef':: d.obj(help=''),
            resourceFieldRef: {
              '#withContainerName':: d.fn(help='', args=[d.arg(name='containerName', type=d.T.string)]),
              withContainerName(containerName): { content+: { git+: { tokenFrom+: { resourceFieldRef+: { containerName: containerName } } } } },
              '#withDivisor':: d.fn(help='', args=[d.arg(name='divisor', type=d.T.any)]),
              withDivisor(divisor): { content+: { git+: { tokenFrom+: { resourceFieldRef+: { divisor: divisor } } } } },
              '#withResource':: d.fn(help='', args=[d.arg(name='resource', type=d.T.string)]),
              withResource(resource): { content+: { git+: { tokenFrom+: { resourceFieldRef+: { resource: resource } } } } },
            },
            '#secretKeyRef':: d.obj(help=''),
            secretKeyRef: {
              '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { content+: { git+: { tokenFrom+: { secretKeyRef+: { key: key } } } } },
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { content+: { git+: { tokenFrom+: { secretKeyRef+: { name: name } } } } },
              '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { content+: { git+: { tokenFrom+: { secretKeyRef+: { optional: optional } } } } },
            },
          },
          '#usernameFrom':: d.obj(help='"external username to fetch with"'),
          usernameFrom: {
            '#configMapKeyRef':: d.obj(help=''),
            configMapKeyRef: {
              '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { content+: { git+: { usernameFrom+: { configMapKeyRef+: { key: key } } } } },
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { content+: { git+: { usernameFrom+: { configMapKeyRef+: { name: name } } } } },
              '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { content+: { git+: { usernameFrom+: { configMapKeyRef+: { optional: optional } } } } },
            },
            '#fieldRef':: d.obj(help=''),
            fieldRef: {
              '#withApiVersion':: d.fn(help='', args=[d.arg(name='apiVersion', type=d.T.string)]),
              withApiVersion(apiVersion): { content+: { git+: { usernameFrom+: { fieldRef+: { apiVersion: apiVersion } } } } },
              '#withFieldPath':: d.fn(help='', args=[d.arg(name='fieldPath', type=d.T.string)]),
              withFieldPath(fieldPath): { content+: { git+: { usernameFrom+: { fieldRef+: { fieldPath: fieldPath } } } } },
            },
            '#resourceFieldRef':: d.obj(help=''),
            resourceFieldRef: {
              '#withContainerName':: d.fn(help='', args=[d.arg(name='containerName', type=d.T.string)]),
              withContainerName(containerName): { content+: { git+: { usernameFrom+: { resourceFieldRef+: { containerName: containerName } } } } },
              '#withDivisor':: d.fn(help='', args=[d.arg(name='divisor', type=d.T.any)]),
              withDivisor(divisor): { content+: { git+: { usernameFrom+: { resourceFieldRef+: { divisor: divisor } } } } },
              '#withResource':: d.fn(help='', args=[d.arg(name='resource', type=d.T.string)]),
              withResource(resource): { content+: { git+: { usernameFrom+: { resourceFieldRef+: { resource: resource } } } } },
            },
            '#secretKeyRef':: d.obj(help=''),
            secretKeyRef: {
              '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { content+: { git+: { usernameFrom+: { secretKeyRef+: { key: key } } } } },
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { content+: { git+: { usernameFrom+: { secretKeyRef+: { name: name } } } } },
              '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { content+: { git+: { usernameFrom+: { secretKeyRef+: { optional: optional } } } } },
            },
          },
          '#withAuthType':: d.fn(help='"authorization type for the credentials"', args=[d.arg(name='authType', type=d.T.string)]),
          withAuthType(authType): { content+: { git+: { authType: authType } } },
          '#withCone':: d.fn(help='"enable cone mode for sparse checkout with paths"', args=[d.arg(name='cone', type=d.T.boolean)]),
          withCone(cone): { content+: { git+: { cone: cone } } },
          '#withMountPath':: d.fn(help='"where to mount the fetched repository contents (defaults to \\"repo\\" directory in the data volume)"', args=[d.arg(name='mountPath', type=d.T.string)]),
          withMountPath(mountPath): { content+: { git+: { mountPath: mountPath } } },
          '#withPaths':: d.fn(help='"paths to fetch for the sparse checkout"', args=[d.arg(name='paths', type=d.T.array)]),
          withPaths(paths): { content+: { git+: { paths: if std.isArray(v=paths) then paths else [paths] } } },
          '#withPathsMixin':: d.fn(help='"paths to fetch for the sparse checkout"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='paths', type=d.T.array)]),
          withPathsMixin(paths): { content+: { git+: { paths+: if std.isArray(v=paths) then paths else [paths] } } },
          '#withRevision':: d.fn(help='"branch, commit or a tag name to fetch"', args=[d.arg(name='revision', type=d.T.string)]),
          withRevision(revision): { content+: { git+: { revision: revision } } },
          '#withSshKey':: d.fn(help='"plain text SSH private key to fetch with"', args=[d.arg(name='sshKey', type=d.T.string)]),
          withSshKey(sshKey): { content+: { git+: { sshKey: sshKey } } },
          '#withToken':: d.fn(help='"plain text token to fetch with"', args=[d.arg(name='token', type=d.T.string)]),
          withToken(token): { content+: { git+: { token: token } } },
          '#withUri':: d.fn(help='"uri for the Git repository"', args=[d.arg(name='uri', type=d.T.string)]),
          withUri(uri): { content+: { git+: { uri: uri } } },
          '#withUsername':: d.fn(help='"plain text username to fetch with"', args=[d.arg(name='username', type=d.T.string)]),
          withUsername(username): { content+: { git+: { username: username } } },
        },
        '#tarball':: d.obj(help='"tarballs to unpack"'),
        tarball: {
          '#withMount':: d.fn(help='"should it mount a new volume there"', args=[d.arg(name='mount', type=d.T.boolean)]),
          withMount(mount): { mount: mount },
          '#withPath':: d.fn(help='"path where the tarball should be extracted"', args=[d.arg(name='path', type=d.T.string)]),
          withPath(path): { path: path },
          '#withUrl':: d.fn(help='"url for the tarball to extract"', args=[d.arg(name='url', type=d.T.string)]),
          withUrl(url): { url: url },
        },
        '#withFiles':: d.fn(help='"files to load"', args=[d.arg(name='files', type=d.T.array)]),
        withFiles(files): { content+: { files: if std.isArray(v=files) then files else [files] } },
        '#withFilesMixin':: d.fn(help='"files to load"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='files', type=d.T.array)]),
        withFilesMixin(files): { content+: { files+: if std.isArray(v=files) then files else [files] } },
        '#withTarball':: d.fn(help='"tarballs to unpack"', args=[d.arg(name='tarball', type=d.T.array)]),
        withTarball(tarball): { content+: { tarball: if std.isArray(v=tarball) then tarball else [tarball] } },
        '#withTarballMixin':: d.fn(help='"tarballs to unpack"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='tarball', type=d.T.array)]),
        withTarballMixin(tarball): { content+: { tarball+: if std.isArray(v=tarball) then tarball else [tarball] } },
      },
      '#execute':: d.obj(help='"execute other Testkube resources"'),
      execute: {
        '#tests':: d.obj(help='"tests to run"'),
        tests: {
          '#executionRequest':: d.obj(help='"pass the execution request overrides"'),
          executionRequest: {
            '#artifactRequest':: d.obj(help='"artifact request body with test artifacts"'),
            artifactRequest: {
              '#withDirs':: d.fn(help='"artifact directories for scraping"', args=[d.arg(name='dirs', type=d.T.array)]),
              withDirs(dirs): { executionRequest+: { artifactRequest+: { dirs: if std.isArray(v=dirs) then dirs else [dirs] } } },
              '#withDirsMixin':: d.fn(help='"artifact directories for scraping"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='dirs', type=d.T.array)]),
              withDirsMixin(dirs): { executionRequest+: { artifactRequest+: { dirs+: if std.isArray(v=dirs) then dirs else [dirs] } } },
              '#withMasks':: d.fn(help='"regexp to filter scraped artifacts, single or comma separated"', args=[d.arg(name='masks', type=d.T.array)]),
              withMasks(masks): { executionRequest+: { artifactRequest+: { masks: if std.isArray(v=masks) then masks else [masks] } } },
              '#withMasksMixin':: d.fn(help='"regexp to filter scraped artifacts, single or comma separated"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='masks', type=d.T.array)]),
              withMasksMixin(masks): { executionRequest+: { artifactRequest+: { masks+: if std.isArray(v=masks) then masks else [masks] } } },
              '#withOmitFolderPerExecution':: d.fn(help="\"don't use a separate folder for execution artifacts\"", args=[d.arg(name='omitFolderPerExecution', type=d.T.boolean)]),
              withOmitFolderPerExecution(omitFolderPerExecution): { executionRequest+: { artifactRequest+: { omitFolderPerExecution: omitFolderPerExecution } } },
              '#withSharedBetweenPods':: d.fn(help='"whether to share volume between pods"', args=[d.arg(name='sharedBetweenPods', type=d.T.boolean)]),
              withSharedBetweenPods(sharedBetweenPods): { executionRequest+: { artifactRequest+: { sharedBetweenPods: sharedBetweenPods } } },
              '#withSidecarScraper':: d.fn(help='"run scraper as pod sidecar container"', args=[d.arg(name='sidecarScraper', type=d.T.boolean)]),
              withSidecarScraper(sidecarScraper): { executionRequest+: { artifactRequest+: { sidecarScraper: sidecarScraper } } },
              '#withStorageBucket':: d.fn(help='"artifact bucket storage"', args=[d.arg(name='storageBucket', type=d.T.string)]),
              withStorageBucket(storageBucket): { executionRequest+: { artifactRequest+: { storageBucket: storageBucket } } },
              '#withStorageClassName':: d.fn(help='"artifact storage class name for container executor"', args=[d.arg(name='storageClassName', type=d.T.string)]),
              withStorageClassName(storageClassName): { executionRequest+: { artifactRequest+: { storageClassName: storageClassName } } },
              '#withUseDefaultStorageClassName':: d.fn(help='"whether to use default storage class name"', args=[d.arg(name='useDefaultStorageClassName', type=d.T.boolean)]),
              withUseDefaultStorageClassName(useDefaultStorageClassName): { executionRequest+: { artifactRequest+: { useDefaultStorageClassName: useDefaultStorageClassName } } },
              '#withVolumeMountPath':: d.fn(help='"artifact volume mount path for container executor"', args=[d.arg(name='volumeMountPath', type=d.T.string)]),
              withVolumeMountPath(volumeMountPath): { executionRequest+: { artifactRequest+: { volumeMountPath: volumeMountPath } } },
            },
            '#envConfigMaps':: d.obj(help='"config map references"'),
            envConfigMaps: {
              '#reference':: d.obj(help='"LocalObjectReference contains enough information to let you locate the\\nreferenced object inside the same namespace."'),
              reference: {
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { reference+: { name: name } },
              },
              '#withMapToVariables':: d.fn(help='"whether we shoud map to variables from resource"', args=[d.arg(name='mapToVariables', type=d.T.boolean)]),
              withMapToVariables(mapToVariables): { mapToVariables: mapToVariables },
              '#withMount':: d.fn(help='"whether we shoud mount resource"', args=[d.arg(name='mount', type=d.T.boolean)]),
              withMount(mount): { mount: mount },
              '#withMountPath':: d.fn(help='"where we shoud mount resource"', args=[d.arg(name='mountPath', type=d.T.string)]),
              withMountPath(mountPath): { mountPath: mountPath },
            },
            '#envSecrets':: d.obj(help='"secret references"'),
            envSecrets: {
              '#reference':: d.obj(help='"LocalObjectReference contains enough information to let you locate the\\nreferenced object inside the same namespace."'),
              reference: {
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { reference+: { name: name } },
              },
              '#withMapToVariables':: d.fn(help='"whether we shoud map to variables from resource"', args=[d.arg(name='mapToVariables', type=d.T.boolean)]),
              withMapToVariables(mapToVariables): { mapToVariables: mapToVariables },
              '#withMount':: d.fn(help='"whether we shoud mount resource"', args=[d.arg(name='mount', type=d.T.boolean)]),
              withMount(mount): { mount: mount },
              '#withMountPath':: d.fn(help='"where we shoud mount resource"', args=[d.arg(name='mountPath', type=d.T.string)]),
              withMountPath(mountPath): { mountPath: mountPath },
            },
            '#imagePullSecrets':: d.obj(help='"container executor image pull secrets"'),
            imagePullSecrets: {
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { name: name },
            },
            '#withActiveDeadlineSeconds':: d.fn(help='"Optional duration in seconds the pod may be active on the node relative to\\nStartTime before the system will actively try to mark it failed and kill associated containers.\\nValue must be a positive integer."', args=[d.arg(name='activeDeadlineSeconds', type=d.T.integer)]),
            withActiveDeadlineSeconds(activeDeadlineSeconds): { executionRequest+: { activeDeadlineSeconds: activeDeadlineSeconds } },
            '#withArgs':: d.fn(help='"additional executor binary arguments"', args=[d.arg(name='args', type=d.T.array)]),
            withArgs(args): { executionRequest+: { args: if std.isArray(v=args) then args else [args] } },
            '#withArgsMixin':: d.fn(help='"additional executor binary arguments"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='args', type=d.T.array)]),
            withArgsMixin(args): { executionRequest+: { args+: if std.isArray(v=args) then args else [args] } },
            '#withArgsMode':: d.fn(help='"usage mode for arguments"', args=[d.arg(name='argsMode', type=d.T.string)]),
            withArgsMode(argsMode): { executionRequest+: { argsMode: argsMode } },
            '#withCommand':: d.fn(help='"executor binary command"', args=[d.arg(name='command', type=d.T.array)]),
            withCommand(command): { executionRequest+: { command: if std.isArray(v=command) then command else [command] } },
            '#withCommandMixin':: d.fn(help='"executor binary command"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='command', type=d.T.array)]),
            withCommandMixin(command): { executionRequest+: { command+: if std.isArray(v=command) then command else [command] } },
            '#withCronJobTemplate':: d.fn(help='"cron job template extensions"', args=[d.arg(name='cronJobTemplate', type=d.T.string)]),
            withCronJobTemplate(cronJobTemplate): { executionRequest+: { cronJobTemplate: cronJobTemplate } },
            '#withEnvConfigMaps':: d.fn(help='"config map references"', args=[d.arg(name='envConfigMaps', type=d.T.array)]),
            withEnvConfigMaps(envConfigMaps): { executionRequest+: { envConfigMaps: if std.isArray(v=envConfigMaps) then envConfigMaps else [envConfigMaps] } },
            '#withEnvConfigMapsMixin':: d.fn(help='"config map references"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='envConfigMaps', type=d.T.array)]),
            withEnvConfigMapsMixin(envConfigMaps): { executionRequest+: { envConfigMaps+: if std.isArray(v=envConfigMaps) then envConfigMaps else [envConfigMaps] } },
            '#withEnvSecrets':: d.fn(help='"secret references"', args=[d.arg(name='envSecrets', type=d.T.array)]),
            withEnvSecrets(envSecrets): { executionRequest+: { envSecrets: if std.isArray(v=envSecrets) then envSecrets else [envSecrets] } },
            '#withEnvSecretsMixin':: d.fn(help='"secret references"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='envSecrets', type=d.T.array)]),
            withEnvSecretsMixin(envSecrets): { executionRequest+: { envSecrets+: if std.isArray(v=envSecrets) then envSecrets else [envSecrets] } },
            '#withExecutePostRunScriptBeforeScraping':: d.fn(help='"execute post run script before scraping (prebuilt executor only)"', args=[d.arg(name='executePostRunScriptBeforeScraping', type=d.T.boolean)]),
            withExecutePostRunScriptBeforeScraping(executePostRunScriptBeforeScraping): { executionRequest+: { executePostRunScriptBeforeScraping: executePostRunScriptBeforeScraping } },
            '#withExecutionLabels':: d.fn(help='"test execution labels"', args=[d.arg(name='executionLabels', type=d.T.object)]),
            withExecutionLabels(executionLabels): { executionRequest+: { executionLabels: executionLabels } },
            '#withExecutionLabelsMixin':: d.fn(help='"test execution labels"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='executionLabels', type=d.T.object)]),
            withExecutionLabelsMixin(executionLabels): { executionRequest+: { executionLabels+: executionLabels } },
            '#withExecutionNamespace':: d.fn(help='"namespace for test execution (Pro edition only)"', args=[d.arg(name='executionNamespace', type=d.T.string)]),
            withExecutionNamespace(executionNamespace): { executionRequest+: { executionNamespace: executionNamespace } },
            '#withHttpProxy':: d.fn(help='"http proxy for executor containers"', args=[d.arg(name='httpProxy', type=d.T.string)]),
            withHttpProxy(httpProxy): { executionRequest+: { httpProxy: httpProxy } },
            '#withHttpsProxy':: d.fn(help='"https proxy for executor containers"', args=[d.arg(name='httpsProxy', type=d.T.string)]),
            withHttpsProxy(httpsProxy): { executionRequest+: { httpsProxy: httpsProxy } },
            '#withImage':: d.fn(help='"container executor image"', args=[d.arg(name='image', type=d.T.string)]),
            withImage(image): { executionRequest+: { image: image } },
            '#withImagePullSecrets':: d.fn(help='"container executor image pull secrets"', args=[d.arg(name='imagePullSecrets', type=d.T.array)]),
            withImagePullSecrets(imagePullSecrets): { executionRequest+: { imagePullSecrets: if std.isArray(v=imagePullSecrets) then imagePullSecrets else [imagePullSecrets] } },
            '#withImagePullSecretsMixin':: d.fn(help='"container executor image pull secrets"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='imagePullSecrets', type=d.T.array)]),
            withImagePullSecretsMixin(imagePullSecrets): { executionRequest+: { imagePullSecrets+: if std.isArray(v=imagePullSecrets) then imagePullSecrets else [imagePullSecrets] } },
            '#withIsVariablesFileUploaded':: d.fn(help='', args=[d.arg(name='isVariablesFileUploaded', type=d.T.boolean)]),
            withIsVariablesFileUploaded(isVariablesFileUploaded): { executionRequest+: { isVariablesFileUploaded: isVariablesFileUploaded } },
            '#withJobTemplate':: d.fn(help='"job template extensions"', args=[d.arg(name='jobTemplate', type=d.T.string)]),
            withJobTemplate(jobTemplate): { executionRequest+: { jobTemplate: jobTemplate } },
            '#withName':: d.fn(help='"test execution custom name"', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { executionRequest+: { name: name } },
            '#withNegativeTest':: d.fn(help='"negative test will fail the execution if it is a success and it will succeed if it is a failure"', args=[d.arg(name='negativeTest', type=d.T.boolean)]),
            withNegativeTest(negativeTest): { executionRequest+: { negativeTest: negativeTest } },
            '#withPostRunScript':: d.fn(help='"script to run after test execution"', args=[d.arg(name='postRunScript', type=d.T.string)]),
            withPostRunScript(postRunScript): { executionRequest+: { postRunScript: postRunScript } },
            '#withPreRunScript':: d.fn(help='"script to run before test execution"', args=[d.arg(name='preRunScript', type=d.T.string)]),
            withPreRunScript(preRunScript): { executionRequest+: { preRunScript: preRunScript } },
            '#withScraperTemplate':: d.fn(help='"scraper template extensions"', args=[d.arg(name='scraperTemplate', type=d.T.string)]),
            withScraperTemplate(scraperTemplate): { executionRequest+: { scraperTemplate: scraperTemplate } },
            '#withSourceScripts':: d.fn(help='"run scripts using source command (container executor only)"', args=[d.arg(name='sourceScripts', type=d.T.boolean)]),
            withSourceScripts(sourceScripts): { executionRequest+: { sourceScripts: sourceScripts } },
            '#withSync':: d.fn(help='"whether to start execution sync or async"', args=[d.arg(name='sync', type=d.T.boolean)]),
            withSync(sync): { executionRequest+: { sync: sync } },
            '#withTestSecretUUID':: d.fn(help='"test secret uuid"', args=[d.arg(name='testSecretUUID', type=d.T.string)]),
            withTestSecretUUID(testSecretUUID): { executionRequest+: { testSecretUUID: testSecretUUID } },
            '#withVariables':: d.fn(help='', args=[d.arg(name='variables', type=d.T.object)]),
            withVariables(variables): { executionRequest+: { variables: variables } },
            '#withVariablesFile':: d.fn(help='"variables file content - need to be in format for particular executor (e.g. postman envs file)"', args=[d.arg(name='variablesFile', type=d.T.string)]),
            withVariablesFile(variablesFile): { executionRequest+: { variablesFile: variablesFile } },
            '#withVariablesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='variables', type=d.T.object)]),
            withVariablesMixin(variables): { executionRequest+: { variables+: variables } },
          },
          '#withCount':: d.fn(help='"static number of sharded instances to spawn"', args=[d.arg(name='count', type=d.T.any)]),
          withCount(count): { count: count },
          '#withDescription':: d.fn(help='"test execution description to display"', args=[d.arg(name='description', type=d.T.string)]),
          withDescription(description): { description: description },
          '#withMatrix':: d.fn(help='"matrix of parameters to spawn instances (static)"', args=[d.arg(name='matrix', type=d.T.object)]),
          withMatrix(matrix): { matrix: matrix },
          '#withMatrixMixin':: d.fn(help='"matrix of parameters to spawn instances (static)"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matrix', type=d.T.object)]),
          withMatrixMixin(matrix): { matrix+: matrix },
          '#withMaxCount':: d.fn(help='"dynamic number of sharded instances to spawn - it will be lowered if there is not enough sharded values"', args=[d.arg(name='maxCount', type=d.T.any)]),
          withMaxCount(maxCount): { maxCount: maxCount },
          '#withName':: d.fn(help='"test name to run"', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { name: name },
          '#withShards':: d.fn(help='"parameters that should be distributed across sharded instances"', args=[d.arg(name='shards', type=d.T.object)]),
          withShards(shards): { shards: shards },
          '#withShardsMixin':: d.fn(help='"parameters that should be distributed across sharded instances"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='shards', type=d.T.object)]),
          withShardsMixin(shards): { shards+: shards },
          '#withTarball':: d.fn(help='"pack some data from the original file system to serve them down"', args=[d.arg(name='tarball', type=d.T.object)]),
          withTarball(tarball): { tarball: tarball },
          '#withTarballMixin':: d.fn(help='"pack some data from the original file system to serve them down"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='tarball', type=d.T.object)]),
          withTarballMixin(tarball): { tarball+: tarball },
        },
        '#withAsync':: d.fn(help="\"only schedule the resources, don't watch the results (unless it is needed for parallelism)\"", args=[d.arg(name='async', type=d.T.boolean)]),
        withAsync(async): { execute+: { async: async } },
        '#withParallelism':: d.fn(help='"how many resources could be scheduled in parallel"', args=[d.arg(name='parallelism', type=d.T.integer)]),
        withParallelism(parallelism): { execute+: { parallelism: parallelism } },
        '#withTests':: d.fn(help='"tests to run"', args=[d.arg(name='tests', type=d.T.array)]),
        withTests(tests): { execute+: { tests: if std.isArray(v=tests) then tests else [tests] } },
        '#withTestsMixin':: d.fn(help='"tests to run"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='tests', type=d.T.array)]),
        withTestsMixin(tests): { execute+: { tests+: if std.isArray(v=tests) then tests else [tests] } },
        '#withWorkflows':: d.fn(help='"workflows to run"', args=[d.arg(name='workflows', type=d.T.array)]),
        withWorkflows(workflows): { execute+: { workflows: if std.isArray(v=workflows) then workflows else [workflows] } },
        '#withWorkflowsMixin':: d.fn(help='"workflows to run"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='workflows', type=d.T.array)]),
        withWorkflowsMixin(workflows): { execute+: { workflows+: if std.isArray(v=workflows) then workflows else [workflows] } },
        '#workflows':: d.obj(help='"workflows to run"'),
        workflows: {
          '#selector':: d.obj(help='"selector is used to identify a group of test workflows based on their metadata labels"'),
          selector: {
            '#matchExpressions':: d.obj(help=''),
            matchExpressions: {
              '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { key: key },
              '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
              withOperator(operator): { operator: operator },
              '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
              withValues(values): { values: if std.isArray(v=values) then values else [values] },
              '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
              withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
            },
            '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
            withMatchExpressions(matchExpressions): { selector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
            '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
            withMatchExpressionsMixin(matchExpressions): { selector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
            '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
            withMatchLabels(matchLabels): { selector+: { matchLabels: matchLabels } },
            '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
            withMatchLabelsMixin(matchLabels): { selector+: { matchLabels+: matchLabels } },
          },
          '#withConfig':: d.fn(help='"configuration to pass for the workflow"', args=[d.arg(name='config', type=d.T.object)]),
          withConfig(config): { config: config },
          '#withConfigMixin':: d.fn(help='"configuration to pass for the workflow"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='config', type=d.T.object)]),
          withConfigMixin(config): { config+: config },
          '#withCount':: d.fn(help='"static number of sharded instances to spawn"', args=[d.arg(name='count', type=d.T.any)]),
          withCount(count): { count: count },
          '#withDescription':: d.fn(help='"test workflow execution description to display"', args=[d.arg(name='description', type=d.T.string)]),
          withDescription(description): { description: description },
          '#withExecutionName':: d.fn(help='"unique execution name to use"', args=[d.arg(name='executionName', type=d.T.string)]),
          withExecutionName(executionName): { executionName: executionName },
          '#withMatrix':: d.fn(help='"matrix of parameters to spawn instances (static)"', args=[d.arg(name='matrix', type=d.T.object)]),
          withMatrix(matrix): { matrix: matrix },
          '#withMatrixMixin':: d.fn(help='"matrix of parameters to spawn instances (static)"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matrix', type=d.T.object)]),
          withMatrixMixin(matrix): { matrix+: matrix },
          '#withMaxCount':: d.fn(help='"dynamic number of sharded instances to spawn - it will be lowered if there is not enough sharded values"', args=[d.arg(name='maxCount', type=d.T.any)]),
          withMaxCount(maxCount): { maxCount: maxCount },
          '#withName':: d.fn(help='"workflow name to run"', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { name: name },
          '#withShards':: d.fn(help='"parameters that should be distributed across sharded instances"', args=[d.arg(name='shards', type=d.T.object)]),
          withShards(shards): { shards: shards },
          '#withShardsMixin':: d.fn(help='"parameters that should be distributed across sharded instances"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='shards', type=d.T.object)]),
          withShardsMixin(shards): { shards+: shards },
          '#withTarball':: d.fn(help='"pack some data from the original file system to serve them down"', args=[d.arg(name='tarball', type=d.T.object)]),
          withTarball(tarball): { tarball: tarball },
          '#withTarballMixin':: d.fn(help='"pack some data from the original file system to serve them down"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='tarball', type=d.T.object)]),
          withTarballMixin(tarball): { tarball+: tarball },
        },
      },
      '#parallel':: d.obj(help='"instructions for parallel execution"'),
      parallel: {
        '#artifacts':: d.obj(help='"scrape artifacts from the volumes"'),
        artifacts: {
          '#compress':: d.obj(help='"compression options for the artifacts"'),
          compress: {
            '#withName':: d.fn(help='"artifact name"', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { parallel+: { artifacts+: { compress+: { name: name } } } },
          },
          '#withPaths':: d.fn(help='"paths to fetch from the container"', args=[d.arg(name='paths', type=d.T.array)]),
          withPaths(paths): { parallel+: { artifacts+: { paths: if std.isArray(v=paths) then paths else [paths] } } },
          '#withPathsMixin':: d.fn(help='"paths to fetch from the container"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='paths', type=d.T.array)]),
          withPathsMixin(paths): { parallel+: { artifacts+: { paths+: if std.isArray(v=paths) then paths else [paths] } } },
          '#withWorkingDir':: d.fn(help='"working directory to override, so it will be used as a base dir"', args=[d.arg(name='workingDir', type=d.T.string)]),
          withWorkingDir(workingDir): { parallel+: { artifacts+: { workingDir: workingDir } } },
        },
        '#execute':: d.obj(help='"execute other Testkube resources"'),
        execute: {
          '#tests':: d.obj(help='"tests to run"'),
          tests: {
            '#executionRequest':: d.obj(help='"pass the execution request overrides"'),
            executionRequest: {
              '#artifactRequest':: d.obj(help='"artifact request body with test artifacts"'),
              artifactRequest: {
                '#withDirs':: d.fn(help='"artifact directories for scraping"', args=[d.arg(name='dirs', type=d.T.array)]),
                withDirs(dirs): { executionRequest+: { artifactRequest+: { dirs: if std.isArray(v=dirs) then dirs else [dirs] } } },
                '#withDirsMixin':: d.fn(help='"artifact directories for scraping"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='dirs', type=d.T.array)]),
                withDirsMixin(dirs): { executionRequest+: { artifactRequest+: { dirs+: if std.isArray(v=dirs) then dirs else [dirs] } } },
                '#withMasks':: d.fn(help='"regexp to filter scraped artifacts, single or comma separated"', args=[d.arg(name='masks', type=d.T.array)]),
                withMasks(masks): { executionRequest+: { artifactRequest+: { masks: if std.isArray(v=masks) then masks else [masks] } } },
                '#withMasksMixin':: d.fn(help='"regexp to filter scraped artifacts, single or comma separated"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='masks', type=d.T.array)]),
                withMasksMixin(masks): { executionRequest+: { artifactRequest+: { masks+: if std.isArray(v=masks) then masks else [masks] } } },
                '#withOmitFolderPerExecution':: d.fn(help="\"don't use a separate folder for execution artifacts\"", args=[d.arg(name='omitFolderPerExecution', type=d.T.boolean)]),
                withOmitFolderPerExecution(omitFolderPerExecution): { executionRequest+: { artifactRequest+: { omitFolderPerExecution: omitFolderPerExecution } } },
                '#withSharedBetweenPods':: d.fn(help='"whether to share volume between pods"', args=[d.arg(name='sharedBetweenPods', type=d.T.boolean)]),
                withSharedBetweenPods(sharedBetweenPods): { executionRequest+: { artifactRequest+: { sharedBetweenPods: sharedBetweenPods } } },
                '#withSidecarScraper':: d.fn(help='"run scraper as pod sidecar container"', args=[d.arg(name='sidecarScraper', type=d.T.boolean)]),
                withSidecarScraper(sidecarScraper): { executionRequest+: { artifactRequest+: { sidecarScraper: sidecarScraper } } },
                '#withStorageBucket':: d.fn(help='"artifact bucket storage"', args=[d.arg(name='storageBucket', type=d.T.string)]),
                withStorageBucket(storageBucket): { executionRequest+: { artifactRequest+: { storageBucket: storageBucket } } },
                '#withStorageClassName':: d.fn(help='"artifact storage class name for container executor"', args=[d.arg(name='storageClassName', type=d.T.string)]),
                withStorageClassName(storageClassName): { executionRequest+: { artifactRequest+: { storageClassName: storageClassName } } },
                '#withUseDefaultStorageClassName':: d.fn(help='"whether to use default storage class name"', args=[d.arg(name='useDefaultStorageClassName', type=d.T.boolean)]),
                withUseDefaultStorageClassName(useDefaultStorageClassName): { executionRequest+: { artifactRequest+: { useDefaultStorageClassName: useDefaultStorageClassName } } },
                '#withVolumeMountPath':: d.fn(help='"artifact volume mount path for container executor"', args=[d.arg(name='volumeMountPath', type=d.T.string)]),
                withVolumeMountPath(volumeMountPath): { executionRequest+: { artifactRequest+: { volumeMountPath: volumeMountPath } } },
              },
              '#envConfigMaps':: d.obj(help='"config map references"'),
              envConfigMaps: {
                '#reference':: d.obj(help='"LocalObjectReference contains enough information to let you locate the\\nreferenced object inside the same namespace."'),
                reference: {
                  '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { reference+: { name: name } },
                },
                '#withMapToVariables':: d.fn(help='"whether we shoud map to variables from resource"', args=[d.arg(name='mapToVariables', type=d.T.boolean)]),
                withMapToVariables(mapToVariables): { mapToVariables: mapToVariables },
                '#withMount':: d.fn(help='"whether we shoud mount resource"', args=[d.arg(name='mount', type=d.T.boolean)]),
                withMount(mount): { mount: mount },
                '#withMountPath':: d.fn(help='"where we shoud mount resource"', args=[d.arg(name='mountPath', type=d.T.string)]),
                withMountPath(mountPath): { mountPath: mountPath },
              },
              '#envSecrets':: d.obj(help='"secret references"'),
              envSecrets: {
                '#reference':: d.obj(help='"LocalObjectReference contains enough information to let you locate the\\nreferenced object inside the same namespace."'),
                reference: {
                  '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { reference+: { name: name } },
                },
                '#withMapToVariables':: d.fn(help='"whether we shoud map to variables from resource"', args=[d.arg(name='mapToVariables', type=d.T.boolean)]),
                withMapToVariables(mapToVariables): { mapToVariables: mapToVariables },
                '#withMount':: d.fn(help='"whether we shoud mount resource"', args=[d.arg(name='mount', type=d.T.boolean)]),
                withMount(mount): { mount: mount },
                '#withMountPath':: d.fn(help='"where we shoud mount resource"', args=[d.arg(name='mountPath', type=d.T.string)]),
                withMountPath(mountPath): { mountPath: mountPath },
              },
              '#imagePullSecrets':: d.obj(help='"container executor image pull secrets"'),
              imagePullSecrets: {
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { name: name },
              },
              '#withActiveDeadlineSeconds':: d.fn(help='"Optional duration in seconds the pod may be active on the node relative to\\nStartTime before the system will actively try to mark it failed and kill associated containers.\\nValue must be a positive integer."', args=[d.arg(name='activeDeadlineSeconds', type=d.T.integer)]),
              withActiveDeadlineSeconds(activeDeadlineSeconds): { executionRequest+: { activeDeadlineSeconds: activeDeadlineSeconds } },
              '#withArgs':: d.fn(help='"additional executor binary arguments"', args=[d.arg(name='args', type=d.T.array)]),
              withArgs(args): { executionRequest+: { args: if std.isArray(v=args) then args else [args] } },
              '#withArgsMixin':: d.fn(help='"additional executor binary arguments"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='args', type=d.T.array)]),
              withArgsMixin(args): { executionRequest+: { args+: if std.isArray(v=args) then args else [args] } },
              '#withArgsMode':: d.fn(help='"usage mode for arguments"', args=[d.arg(name='argsMode', type=d.T.string)]),
              withArgsMode(argsMode): { executionRequest+: { argsMode: argsMode } },
              '#withCommand':: d.fn(help='"executor binary command"', args=[d.arg(name='command', type=d.T.array)]),
              withCommand(command): { executionRequest+: { command: if std.isArray(v=command) then command else [command] } },
              '#withCommandMixin':: d.fn(help='"executor binary command"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='command', type=d.T.array)]),
              withCommandMixin(command): { executionRequest+: { command+: if std.isArray(v=command) then command else [command] } },
              '#withCronJobTemplate':: d.fn(help='"cron job template extensions"', args=[d.arg(name='cronJobTemplate', type=d.T.string)]),
              withCronJobTemplate(cronJobTemplate): { executionRequest+: { cronJobTemplate: cronJobTemplate } },
              '#withEnvConfigMaps':: d.fn(help='"config map references"', args=[d.arg(name='envConfigMaps', type=d.T.array)]),
              withEnvConfigMaps(envConfigMaps): { executionRequest+: { envConfigMaps: if std.isArray(v=envConfigMaps) then envConfigMaps else [envConfigMaps] } },
              '#withEnvConfigMapsMixin':: d.fn(help='"config map references"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='envConfigMaps', type=d.T.array)]),
              withEnvConfigMapsMixin(envConfigMaps): { executionRequest+: { envConfigMaps+: if std.isArray(v=envConfigMaps) then envConfigMaps else [envConfigMaps] } },
              '#withEnvSecrets':: d.fn(help='"secret references"', args=[d.arg(name='envSecrets', type=d.T.array)]),
              withEnvSecrets(envSecrets): { executionRequest+: { envSecrets: if std.isArray(v=envSecrets) then envSecrets else [envSecrets] } },
              '#withEnvSecretsMixin':: d.fn(help='"secret references"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='envSecrets', type=d.T.array)]),
              withEnvSecretsMixin(envSecrets): { executionRequest+: { envSecrets+: if std.isArray(v=envSecrets) then envSecrets else [envSecrets] } },
              '#withExecutePostRunScriptBeforeScraping':: d.fn(help='"execute post run script before scraping (prebuilt executor only)"', args=[d.arg(name='executePostRunScriptBeforeScraping', type=d.T.boolean)]),
              withExecutePostRunScriptBeforeScraping(executePostRunScriptBeforeScraping): { executionRequest+: { executePostRunScriptBeforeScraping: executePostRunScriptBeforeScraping } },
              '#withExecutionLabels':: d.fn(help='"test execution labels"', args=[d.arg(name='executionLabels', type=d.T.object)]),
              withExecutionLabels(executionLabels): { executionRequest+: { executionLabels: executionLabels } },
              '#withExecutionLabelsMixin':: d.fn(help='"test execution labels"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='executionLabels', type=d.T.object)]),
              withExecutionLabelsMixin(executionLabels): { executionRequest+: { executionLabels+: executionLabels } },
              '#withExecutionNamespace':: d.fn(help='"namespace for test execution (Pro edition only)"', args=[d.arg(name='executionNamespace', type=d.T.string)]),
              withExecutionNamespace(executionNamespace): { executionRequest+: { executionNamespace: executionNamespace } },
              '#withHttpProxy':: d.fn(help='"http proxy for executor containers"', args=[d.arg(name='httpProxy', type=d.T.string)]),
              withHttpProxy(httpProxy): { executionRequest+: { httpProxy: httpProxy } },
              '#withHttpsProxy':: d.fn(help='"https proxy for executor containers"', args=[d.arg(name='httpsProxy', type=d.T.string)]),
              withHttpsProxy(httpsProxy): { executionRequest+: { httpsProxy: httpsProxy } },
              '#withImage':: d.fn(help='"container executor image"', args=[d.arg(name='image', type=d.T.string)]),
              withImage(image): { executionRequest+: { image: image } },
              '#withImagePullSecrets':: d.fn(help='"container executor image pull secrets"', args=[d.arg(name='imagePullSecrets', type=d.T.array)]),
              withImagePullSecrets(imagePullSecrets): { executionRequest+: { imagePullSecrets: if std.isArray(v=imagePullSecrets) then imagePullSecrets else [imagePullSecrets] } },
              '#withImagePullSecretsMixin':: d.fn(help='"container executor image pull secrets"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='imagePullSecrets', type=d.T.array)]),
              withImagePullSecretsMixin(imagePullSecrets): { executionRequest+: { imagePullSecrets+: if std.isArray(v=imagePullSecrets) then imagePullSecrets else [imagePullSecrets] } },
              '#withIsVariablesFileUploaded':: d.fn(help='', args=[d.arg(name='isVariablesFileUploaded', type=d.T.boolean)]),
              withIsVariablesFileUploaded(isVariablesFileUploaded): { executionRequest+: { isVariablesFileUploaded: isVariablesFileUploaded } },
              '#withJobTemplate':: d.fn(help='"job template extensions"', args=[d.arg(name='jobTemplate', type=d.T.string)]),
              withJobTemplate(jobTemplate): { executionRequest+: { jobTemplate: jobTemplate } },
              '#withName':: d.fn(help='"test execution custom name"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { executionRequest+: { name: name } },
              '#withNegativeTest':: d.fn(help='"negative test will fail the execution if it is a success and it will succeed if it is a failure"', args=[d.arg(name='negativeTest', type=d.T.boolean)]),
              withNegativeTest(negativeTest): { executionRequest+: { negativeTest: negativeTest } },
              '#withPostRunScript':: d.fn(help='"script to run after test execution"', args=[d.arg(name='postRunScript', type=d.T.string)]),
              withPostRunScript(postRunScript): { executionRequest+: { postRunScript: postRunScript } },
              '#withPreRunScript':: d.fn(help='"script to run before test execution"', args=[d.arg(name='preRunScript', type=d.T.string)]),
              withPreRunScript(preRunScript): { executionRequest+: { preRunScript: preRunScript } },
              '#withScraperTemplate':: d.fn(help='"scraper template extensions"', args=[d.arg(name='scraperTemplate', type=d.T.string)]),
              withScraperTemplate(scraperTemplate): { executionRequest+: { scraperTemplate: scraperTemplate } },
              '#withSourceScripts':: d.fn(help='"run scripts using source command (container executor only)"', args=[d.arg(name='sourceScripts', type=d.T.boolean)]),
              withSourceScripts(sourceScripts): { executionRequest+: { sourceScripts: sourceScripts } },
              '#withSync':: d.fn(help='"whether to start execution sync or async"', args=[d.arg(name='sync', type=d.T.boolean)]),
              withSync(sync): { executionRequest+: { sync: sync } },
              '#withTestSecretUUID':: d.fn(help='"test secret uuid"', args=[d.arg(name='testSecretUUID', type=d.T.string)]),
              withTestSecretUUID(testSecretUUID): { executionRequest+: { testSecretUUID: testSecretUUID } },
              '#withVariables':: d.fn(help='', args=[d.arg(name='variables', type=d.T.object)]),
              withVariables(variables): { executionRequest+: { variables: variables } },
              '#withVariablesFile':: d.fn(help='"variables file content - need to be in format for particular executor (e.g. postman envs file)"', args=[d.arg(name='variablesFile', type=d.T.string)]),
              withVariablesFile(variablesFile): { executionRequest+: { variablesFile: variablesFile } },
              '#withVariablesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='variables', type=d.T.object)]),
              withVariablesMixin(variables): { executionRequest+: { variables+: variables } },
            },
            '#withCount':: d.fn(help='"static number of sharded instances to spawn"', args=[d.arg(name='count', type=d.T.any)]),
            withCount(count): { count: count },
            '#withDescription':: d.fn(help='"test execution description to display"', args=[d.arg(name='description', type=d.T.string)]),
            withDescription(description): { description: description },
            '#withMatrix':: d.fn(help='"matrix of parameters to spawn instances (static)"', args=[d.arg(name='matrix', type=d.T.object)]),
            withMatrix(matrix): { matrix: matrix },
            '#withMatrixMixin':: d.fn(help='"matrix of parameters to spawn instances (static)"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matrix', type=d.T.object)]),
            withMatrixMixin(matrix): { matrix+: matrix },
            '#withMaxCount':: d.fn(help='"dynamic number of sharded instances to spawn - it will be lowered if there is not enough sharded values"', args=[d.arg(name='maxCount', type=d.T.any)]),
            withMaxCount(maxCount): { maxCount: maxCount },
            '#withName':: d.fn(help='"test name to run"', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { name: name },
            '#withShards':: d.fn(help='"parameters that should be distributed across sharded instances"', args=[d.arg(name='shards', type=d.T.object)]),
            withShards(shards): { shards: shards },
            '#withShardsMixin':: d.fn(help='"parameters that should be distributed across sharded instances"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='shards', type=d.T.object)]),
            withShardsMixin(shards): { shards+: shards },
            '#withTarball':: d.fn(help='"pack some data from the original file system to serve them down"', args=[d.arg(name='tarball', type=d.T.object)]),
            withTarball(tarball): { tarball: tarball },
            '#withTarballMixin':: d.fn(help='"pack some data from the original file system to serve them down"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='tarball', type=d.T.object)]),
            withTarballMixin(tarball): { tarball+: tarball },
          },
          '#withAsync':: d.fn(help="\"only schedule the resources, don't watch the results (unless it is needed for parallelism)\"", args=[d.arg(name='async', type=d.T.boolean)]),
          withAsync(async): { parallel+: { execute+: { async: async } } },
          '#withParallelism':: d.fn(help='"how many resources could be scheduled in parallel"', args=[d.arg(name='parallelism', type=d.T.integer)]),
          withParallelism(parallelism): { parallel+: { execute+: { parallelism: parallelism } } },
          '#withTests':: d.fn(help='"tests to run"', args=[d.arg(name='tests', type=d.T.array)]),
          withTests(tests): { parallel+: { execute+: { tests: if std.isArray(v=tests) then tests else [tests] } } },
          '#withTestsMixin':: d.fn(help='"tests to run"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='tests', type=d.T.array)]),
          withTestsMixin(tests): { parallel+: { execute+: { tests+: if std.isArray(v=tests) then tests else [tests] } } },
          '#withWorkflows':: d.fn(help='"workflows to run"', args=[d.arg(name='workflows', type=d.T.array)]),
          withWorkflows(workflows): { parallel+: { execute+: { workflows: if std.isArray(v=workflows) then workflows else [workflows] } } },
          '#withWorkflowsMixin':: d.fn(help='"workflows to run"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='workflows', type=d.T.array)]),
          withWorkflowsMixin(workflows): { parallel+: { execute+: { workflows+: if std.isArray(v=workflows) then workflows else [workflows] } } },
          '#workflows':: d.obj(help='"workflows to run"'),
          workflows: {
            '#selector':: d.obj(help='"selector is used to identify a group of test workflows based on their metadata labels"'),
            selector: {
              '#matchExpressions':: d.obj(help=''),
              matchExpressions: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                withOperator(operator): { operator: operator },
                '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                withValues(values): { values: if std.isArray(v=values) then values else [values] },
                '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
              },
              '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressions(matchExpressions): { selector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressionsMixin(matchExpressions): { selector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabels(matchLabels): { selector+: { matchLabels: matchLabels } },
              '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabelsMixin(matchLabels): { selector+: { matchLabels+: matchLabels } },
            },
            '#withConfig':: d.fn(help='"configuration to pass for the workflow"', args=[d.arg(name='config', type=d.T.object)]),
            withConfig(config): { config: config },
            '#withConfigMixin':: d.fn(help='"configuration to pass for the workflow"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='config', type=d.T.object)]),
            withConfigMixin(config): { config+: config },
            '#withCount':: d.fn(help='"static number of sharded instances to spawn"', args=[d.arg(name='count', type=d.T.any)]),
            withCount(count): { count: count },
            '#withDescription':: d.fn(help='"test workflow execution description to display"', args=[d.arg(name='description', type=d.T.string)]),
            withDescription(description): { description: description },
            '#withExecutionName':: d.fn(help='"unique execution name to use"', args=[d.arg(name='executionName', type=d.T.string)]),
            withExecutionName(executionName): { executionName: executionName },
            '#withMatrix':: d.fn(help='"matrix of parameters to spawn instances (static)"', args=[d.arg(name='matrix', type=d.T.object)]),
            withMatrix(matrix): { matrix: matrix },
            '#withMatrixMixin':: d.fn(help='"matrix of parameters to spawn instances (static)"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matrix', type=d.T.object)]),
            withMatrixMixin(matrix): { matrix+: matrix },
            '#withMaxCount':: d.fn(help='"dynamic number of sharded instances to spawn - it will be lowered if there is not enough sharded values"', args=[d.arg(name='maxCount', type=d.T.any)]),
            withMaxCount(maxCount): { maxCount: maxCount },
            '#withName':: d.fn(help='"workflow name to run"', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { name: name },
            '#withShards':: d.fn(help='"parameters that should be distributed across sharded instances"', args=[d.arg(name='shards', type=d.T.object)]),
            withShards(shards): { shards: shards },
            '#withShardsMixin':: d.fn(help='"parameters that should be distributed across sharded instances"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='shards', type=d.T.object)]),
            withShardsMixin(shards): { shards+: shards },
            '#withTarball':: d.fn(help='"pack some data from the original file system to serve them down"', args=[d.arg(name='tarball', type=d.T.object)]),
            withTarball(tarball): { tarball: tarball },
            '#withTarballMixin':: d.fn(help='"pack some data from the original file system to serve them down"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='tarball', type=d.T.object)]),
            withTarballMixin(tarball): { tarball+: tarball },
          },
        },
        '#retry':: d.obj(help='"policy for retrying the step"'),
        retry: {
          '#withCount':: d.fn(help='"how many times at most it should retry"', args=[d.arg(name='count', type=d.T.integer)]),
          withCount(count): { parallel+: { retry+: { count: count } } },
          '#withUntil':: d.fn(help='"until when it should retry (defaults to: \\"passed\\")"', args=[d.arg(name='until', type=d.T.string)]),
          withUntil(until): { parallel+: { retry+: { until: until } } },
        },
        '#run':: d.obj(help='"run specific container in the current step"'),
        run: {
          '#env':: d.obj(help=''),
          env: {
            '#valueFrom':: d.obj(help=''),
            valueFrom: {
              '#configMapKeyRef':: d.obj(help=''),
              configMapKeyRef: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { valueFrom+: { configMapKeyRef+: { key: key } } },
                '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { valueFrom+: { configMapKeyRef+: { name: name } } },
                '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { valueFrom+: { configMapKeyRef+: { optional: optional } } },
              },
              '#fieldRef':: d.obj(help=''),
              fieldRef: {
                '#withApiVersion':: d.fn(help='', args=[d.arg(name='apiVersion', type=d.T.string)]),
                withApiVersion(apiVersion): { valueFrom+: { fieldRef+: { apiVersion: apiVersion } } },
                '#withFieldPath':: d.fn(help='', args=[d.arg(name='fieldPath', type=d.T.string)]),
                withFieldPath(fieldPath): { valueFrom+: { fieldRef+: { fieldPath: fieldPath } } },
              },
              '#resourceFieldRef':: d.obj(help=''),
              resourceFieldRef: {
                '#withContainerName':: d.fn(help='', args=[d.arg(name='containerName', type=d.T.string)]),
                withContainerName(containerName): { valueFrom+: { resourceFieldRef+: { containerName: containerName } } },
                '#withDivisor':: d.fn(help='', args=[d.arg(name='divisor', type=d.T.any)]),
                withDivisor(divisor): { valueFrom+: { resourceFieldRef+: { divisor: divisor } } },
                '#withResource':: d.fn(help='', args=[d.arg(name='resource', type=d.T.string)]),
                withResource(resource): { valueFrom+: { resourceFieldRef+: { resource: resource } } },
              },
              '#secretKeyRef':: d.obj(help=''),
              secretKeyRef: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { valueFrom+: { secretKeyRef+: { key: key } } },
                '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { valueFrom+: { secretKeyRef+: { name: name } } },
                '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { valueFrom+: { secretKeyRef+: { optional: optional } } },
              },
            },
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { name: name },
            '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
            withValue(value): { value: value },
          },
          '#envFrom':: d.obj(help=''),
          envFrom: {
            '#configMapRef':: d.obj(help=''),
            configMapRef: {
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { configMapRef+: { name: name } },
              '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { configMapRef+: { optional: optional } },
            },
            '#secretRef':: d.obj(help=''),
            secretRef: {
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { secretRef+: { name: name } },
              '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { secretRef+: { optional: optional } },
            },
            '#withPrefix':: d.fn(help='', args=[d.arg(name='prefix', type=d.T.string)]),
            withPrefix(prefix): { prefix: prefix },
          },
          '#resources':: d.obj(help='"expected resources for the container"'),
          resources: {
            '#withLimits':: d.fn(help='"resource limits for the container"', args=[d.arg(name='limits', type=d.T.object)]),
            withLimits(limits): { parallel+: { run+: { resources+: { limits: limits } } } },
            '#withLimitsMixin':: d.fn(help='"resource limits for the container"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='limits', type=d.T.object)]),
            withLimitsMixin(limits): { parallel+: { run+: { resources+: { limits+: limits } } } },
            '#withRequests':: d.fn(help='"resource requests for the container"', args=[d.arg(name='requests', type=d.T.object)]),
            withRequests(requests): { parallel+: { run+: { resources+: { requests: requests } } } },
            '#withRequestsMixin':: d.fn(help='"resource requests for the container"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requests', type=d.T.object)]),
            withRequestsMixin(requests): { parallel+: { run+: { resources+: { requests+: requests } } } },
          },
          '#securityContext':: d.obj(help=''),
          securityContext: {
            '#appArmorProfile':: d.obj(help=''),
            appArmorProfile: {
              '#withLocalhostProfile':: d.fn(help='', args=[d.arg(name='localhostProfile', type=d.T.string)]),
              withLocalhostProfile(localhostProfile): { parallel+: { run+: { securityContext+: { appArmorProfile+: { localhostProfile: localhostProfile } } } } },
              '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
              withType(type): { parallel+: { run+: { securityContext+: { appArmorProfile+: { type: type } } } } },
            },
            '#capabilities':: d.obj(help=''),
            capabilities: {
              '#withAdd':: d.fn(help='', args=[d.arg(name='add', type=d.T.array)]),
              withAdd(add): { parallel+: { run+: { securityContext+: { capabilities+: { add: if std.isArray(v=add) then add else [add] } } } } },
              '#withAddMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='add', type=d.T.array)]),
              withAddMixin(add): { parallel+: { run+: { securityContext+: { capabilities+: { add+: if std.isArray(v=add) then add else [add] } } } } },
              '#withDrop':: d.fn(help='', args=[d.arg(name='drop', type=d.T.array)]),
              withDrop(drop): { parallel+: { run+: { securityContext+: { capabilities+: { drop: if std.isArray(v=drop) then drop else [drop] } } } } },
              '#withDropMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='drop', type=d.T.array)]),
              withDropMixin(drop): { parallel+: { run+: { securityContext+: { capabilities+: { drop+: if std.isArray(v=drop) then drop else [drop] } } } } },
            },
            '#seLinuxOptions':: d.obj(help=''),
            seLinuxOptions: {
              '#withLevel':: d.fn(help='', args=[d.arg(name='level', type=d.T.string)]),
              withLevel(level): { parallel+: { run+: { securityContext+: { seLinuxOptions+: { level: level } } } } },
              '#withRole':: d.fn(help='', args=[d.arg(name='role', type=d.T.string)]),
              withRole(role): { parallel+: { run+: { securityContext+: { seLinuxOptions+: { role: role } } } } },
              '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
              withType(type): { parallel+: { run+: { securityContext+: { seLinuxOptions+: { type: type } } } } },
              '#withUser':: d.fn(help='', args=[d.arg(name='user', type=d.T.string)]),
              withUser(user): { parallel+: { run+: { securityContext+: { seLinuxOptions+: { user: user } } } } },
            },
            '#seccompProfile':: d.obj(help=''),
            seccompProfile: {
              '#withLocalhostProfile':: d.fn(help='', args=[d.arg(name='localhostProfile', type=d.T.string)]),
              withLocalhostProfile(localhostProfile): { parallel+: { run+: { securityContext+: { seccompProfile+: { localhostProfile: localhostProfile } } } } },
              '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
              withType(type): { parallel+: { run+: { securityContext+: { seccompProfile+: { type: type } } } } },
            },
            '#windowsOptions':: d.obj(help=''),
            windowsOptions: {
              '#withGmsaCredentialSpec':: d.fn(help='', args=[d.arg(name='gmsaCredentialSpec', type=d.T.string)]),
              withGmsaCredentialSpec(gmsaCredentialSpec): { parallel+: { run+: { securityContext+: { windowsOptions+: { gmsaCredentialSpec: gmsaCredentialSpec } } } } },
              '#withGmsaCredentialSpecName':: d.fn(help='', args=[d.arg(name='gmsaCredentialSpecName', type=d.T.string)]),
              withGmsaCredentialSpecName(gmsaCredentialSpecName): { parallel+: { run+: { securityContext+: { windowsOptions+: { gmsaCredentialSpecName: gmsaCredentialSpecName } } } } },
              '#withHostProcess':: d.fn(help='', args=[d.arg(name='hostProcess', type=d.T.boolean)]),
              withHostProcess(hostProcess): { parallel+: { run+: { securityContext+: { windowsOptions+: { hostProcess: hostProcess } } } } },
              '#withRunAsUserName':: d.fn(help='', args=[d.arg(name='runAsUserName', type=d.T.string)]),
              withRunAsUserName(runAsUserName): { parallel+: { run+: { securityContext+: { windowsOptions+: { runAsUserName: runAsUserName } } } } },
            },
            '#withAllowPrivilegeEscalation':: d.fn(help='', args=[d.arg(name='allowPrivilegeEscalation', type=d.T.boolean)]),
            withAllowPrivilegeEscalation(allowPrivilegeEscalation): { parallel+: { run+: { securityContext+: { allowPrivilegeEscalation: allowPrivilegeEscalation } } } },
            '#withPrivileged':: d.fn(help='', args=[d.arg(name='privileged', type=d.T.boolean)]),
            withPrivileged(privileged): { parallel+: { run+: { securityContext+: { privileged: privileged } } } },
            '#withProcMount':: d.fn(help='', args=[d.arg(name='procMount', type=d.T.string)]),
            withProcMount(procMount): { parallel+: { run+: { securityContext+: { procMount: procMount } } } },
            '#withReadOnlyRootFilesystem':: d.fn(help='', args=[d.arg(name='readOnlyRootFilesystem', type=d.T.boolean)]),
            withReadOnlyRootFilesystem(readOnlyRootFilesystem): { parallel+: { run+: { securityContext+: { readOnlyRootFilesystem: readOnlyRootFilesystem } } } },
            '#withRunAsGroup':: d.fn(help='', args=[d.arg(name='runAsGroup', type=d.T.integer)]),
            withRunAsGroup(runAsGroup): { parallel+: { run+: { securityContext+: { runAsGroup: runAsGroup } } } },
            '#withRunAsNonRoot':: d.fn(help='', args=[d.arg(name='runAsNonRoot', type=d.T.boolean)]),
            withRunAsNonRoot(runAsNonRoot): { parallel+: { run+: { securityContext+: { runAsNonRoot: runAsNonRoot } } } },
            '#withRunAsUser':: d.fn(help='', args=[d.arg(name='runAsUser', type=d.T.integer)]),
            withRunAsUser(runAsUser): { parallel+: { run+: { securityContext+: { runAsUser: runAsUser } } } },
          },
          '#volumeMounts':: d.obj(help=''),
          volumeMounts: {
            '#withMountPath':: d.fn(help='', args=[d.arg(name='mountPath', type=d.T.string)]),
            withMountPath(mountPath): { mountPath: mountPath },
            '#withMountPropagation':: d.fn(help='', args=[d.arg(name='mountPropagation', type=d.T.string)]),
            withMountPropagation(mountPropagation): { mountPropagation: mountPropagation },
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { name: name },
            '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
            withReadOnly(readOnly): { readOnly: readOnly },
            '#withRecursiveReadOnly':: d.fn(help='', args=[d.arg(name='recursiveReadOnly', type=d.T.string)]),
            withRecursiveReadOnly(recursiveReadOnly): { recursiveReadOnly: recursiveReadOnly },
            '#withSubPath':: d.fn(help='', args=[d.arg(name='subPath', type=d.T.string)]),
            withSubPath(subPath): { subPath: subPath },
            '#withSubPathExpr':: d.fn(help='', args=[d.arg(name='subPathExpr', type=d.T.string)]),
            withSubPathExpr(subPathExpr): { subPathExpr: subPathExpr },
          },
          '#withArgs':: d.fn(help='"override default command in the image (empty string to default CMD of the image)"', args=[d.arg(name='args', type=d.T.array)]),
          withArgs(args): { parallel+: { run+: { args: if std.isArray(v=args) then args else [args] } } },
          '#withArgsMixin':: d.fn(help='"override default command in the image (empty string to default CMD of the image)"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='args', type=d.T.array)]),
          withArgsMixin(args): { parallel+: { run+: { args+: if std.isArray(v=args) then args else [args] } } },
          '#withCommand':: d.fn(help='"override default command in the image (empty string to default ENTRYPOINT of the image)"', args=[d.arg(name='command', type=d.T.array)]),
          withCommand(command): { parallel+: { run+: { command: if std.isArray(v=command) then command else [command] } } },
          '#withCommandMixin':: d.fn(help='"override default command in the image (empty string to default ENTRYPOINT of the image)"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='command', type=d.T.array)]),
          withCommandMixin(command): { parallel+: { run+: { command+: if std.isArray(v=command) then command else [command] } } },
          '#withEnv':: d.fn(help='', args=[d.arg(name='env', type=d.T.array)]),
          withEnv(env): { parallel+: { run+: { env: if std.isArray(v=env) then env else [env] } } },
          '#withEnvFrom':: d.fn(help='', args=[d.arg(name='envFrom', type=d.T.array)]),
          withEnvFrom(envFrom): { parallel+: { run+: { envFrom: if std.isArray(v=envFrom) then envFrom else [envFrom] } } },
          '#withEnvFromMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='envFrom', type=d.T.array)]),
          withEnvFromMixin(envFrom): { parallel+: { run+: { envFrom+: if std.isArray(v=envFrom) then envFrom else [envFrom] } } },
          '#withEnvMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='env', type=d.T.array)]),
          withEnvMixin(env): { parallel+: { run+: { env+: if std.isArray(v=env) then env else [env] } } },
          '#withImage':: d.fn(help='"image to be used for the container"', args=[d.arg(name='image', type=d.T.string)]),
          withImage(image): { parallel+: { run+: { image: image } } },
          '#withImagePullPolicy':: d.fn(help='"pulling policy for the image"', args=[d.arg(name='imagePullPolicy', type=d.T.string)]),
          withImagePullPolicy(imagePullPolicy): { parallel+: { run+: { imagePullPolicy: imagePullPolicy } } },
          '#withShell':: d.fn(help='"script to run in a default shell for the container"', args=[d.arg(name='shell', type=d.T.string)]),
          withShell(shell): { parallel+: { run+: { shell: shell } } },
          '#withVolumeMounts':: d.fn(help='', args=[d.arg(name='volumeMounts', type=d.T.array)]),
          withVolumeMounts(volumeMounts): { parallel+: { run+: { volumeMounts: if std.isArray(v=volumeMounts) then volumeMounts else [volumeMounts] } } },
          '#withVolumeMountsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='volumeMounts', type=d.T.array)]),
          withVolumeMountsMixin(volumeMounts): { parallel+: { run+: { volumeMounts+: if std.isArray(v=volumeMounts) then volumeMounts else [volumeMounts] } } },
          '#withWorkingDir':: d.fn(help='"override default working directory in the image (empty string to default WORKDIR for the image)"', args=[d.arg(name='workingDir', type=d.T.string)]),
          withWorkingDir(workingDir): { parallel+: { run+: { workingDir: workingDir } } },
        },
        '#withCount':: d.fn(help='"static number of sharded instances to spawn"', args=[d.arg(name='count', type=d.T.any)]),
        withCount(count): { parallel+: { count: count } },
        '#withDelay':: d.fn(help='"delay before the step"', args=[d.arg(name='delay', type=d.T.string)]),
        withDelay(delay): { parallel+: { delay: delay } },
        '#withDescription':: d.fn(help='"worker description to display"', args=[d.arg(name='description', type=d.T.string)]),
        withDescription(description): { parallel+: { description: description } },
        '#withFetch':: d.fn(help='"instructions for fetching files back"', args=[d.arg(name='fetch', type=d.T.array)]),
        withFetch(fetch): { parallel+: { fetch: if std.isArray(v=fetch) then fetch else [fetch] } },
        '#withFetchMixin':: d.fn(help='"instructions for fetching files back"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='fetch', type=d.T.array)]),
        withFetchMixin(fetch): { parallel+: { fetch+: if std.isArray(v=fetch) then fetch else [fetch] } },
        '#withLogs':: d.fn(help='"should save logs for the parallel step (true if not specified)"', args=[d.arg(name='logs', type=d.T.string)]),
        withLogs(logs): { parallel+: { logs: logs } },
        '#withMatrix':: d.fn(help='"matrix of parameters to spawn instances (static)"', args=[d.arg(name='matrix', type=d.T.object)]),
        withMatrix(matrix): { parallel+: { matrix: matrix } },
        '#withMatrixMixin':: d.fn(help='"matrix of parameters to spawn instances (static)"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matrix', type=d.T.object)]),
        withMatrixMixin(matrix): { parallel+: { matrix+: matrix } },
        '#withMaxCount':: d.fn(help='"dynamic number of sharded instances to spawn - it will be lowered if there is not enough sharded values"', args=[d.arg(name='maxCount', type=d.T.any)]),
        withMaxCount(maxCount): { parallel+: { maxCount: maxCount } },
        '#withNegative':: d.fn(help='"is the step expected to fail"', args=[d.arg(name='negative', type=d.T.boolean)]),
        withNegative(negative): { parallel+: { negative: negative } },
        '#withOptional':: d.fn(help="\"is the step optional, so its failure won't affect the TestWorkflow result\"", args=[d.arg(name='optional', type=d.T.boolean)]),
        withOptional(optional): { parallel+: { optional: optional } },
        '#withParallelism':: d.fn(help='"how many resources could be scheduled in parallel"', args=[d.arg(name='parallelism', type=d.T.integer)]),
        withParallelism(parallelism): { parallel+: { parallelism: parallelism } },
        '#withPaused':: d.fn(help='"pause the step initially"', args=[d.arg(name='paused', type=d.T.boolean)]),
        withPaused(paused): { parallel+: { paused: paused } },
        '#withShards':: d.fn(help='"parameters that should be distributed across sharded instances"', args=[d.arg(name='shards', type=d.T.object)]),
        withShards(shards): { parallel+: { shards: shards } },
        '#withShardsMixin':: d.fn(help='"parameters that should be distributed across sharded instances"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='shards', type=d.T.object)]),
        withShardsMixin(shards): { parallel+: { shards+: shards } },
        '#withShell':: d.fn(help='"script to run in a default shell for the container"', args=[d.arg(name='shell', type=d.T.string)]),
        withShell(shell): { parallel+: { shell: shell } },
        '#withTimeout':: d.fn(help='"maximum time this step may take"', args=[d.arg(name='timeout', type=d.T.string)]),
        withTimeout(timeout): { parallel+: { timeout: timeout } },
        '#withTransfer':: d.fn(help='"instructions for transferring files"', args=[d.arg(name='transfer', type=d.T.array)]),
        withTransfer(transfer): { parallel+: { transfer: if std.isArray(v=transfer) then transfer else [transfer] } },
        '#withTransferMixin':: d.fn(help='"instructions for transferring files"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='transfer', type=d.T.array)]),
        withTransferMixin(transfer): { parallel+: { transfer+: if std.isArray(v=transfer) then transfer else [transfer] } },
      },
      '#retry':: d.obj(help='"policy for retrying the step"'),
      retry: {
        '#withCount':: d.fn(help='"how many times at most it should retry"', args=[d.arg(name='count', type=d.T.integer)]),
        withCount(count): { retry+: { count: count } },
        '#withUntil':: d.fn(help='"until when it should retry (defaults to: \\"passed\\")"', args=[d.arg(name='until', type=d.T.string)]),
        withUntil(until): { retry+: { until: until } },
      },
      '#run':: d.obj(help='"run specific container in the current step"'),
      run: {
        '#env':: d.obj(help=''),
        env: {
          '#valueFrom':: d.obj(help=''),
          valueFrom: {
            '#configMapKeyRef':: d.obj(help=''),
            configMapKeyRef: {
              '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { valueFrom+: { configMapKeyRef+: { key: key } } },
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { valueFrom+: { configMapKeyRef+: { name: name } } },
              '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { valueFrom+: { configMapKeyRef+: { optional: optional } } },
            },
            '#fieldRef':: d.obj(help=''),
            fieldRef: {
              '#withApiVersion':: d.fn(help='', args=[d.arg(name='apiVersion', type=d.T.string)]),
              withApiVersion(apiVersion): { valueFrom+: { fieldRef+: { apiVersion: apiVersion } } },
              '#withFieldPath':: d.fn(help='', args=[d.arg(name='fieldPath', type=d.T.string)]),
              withFieldPath(fieldPath): { valueFrom+: { fieldRef+: { fieldPath: fieldPath } } },
            },
            '#resourceFieldRef':: d.obj(help=''),
            resourceFieldRef: {
              '#withContainerName':: d.fn(help='', args=[d.arg(name='containerName', type=d.T.string)]),
              withContainerName(containerName): { valueFrom+: { resourceFieldRef+: { containerName: containerName } } },
              '#withDivisor':: d.fn(help='', args=[d.arg(name='divisor', type=d.T.any)]),
              withDivisor(divisor): { valueFrom+: { resourceFieldRef+: { divisor: divisor } } },
              '#withResource':: d.fn(help='', args=[d.arg(name='resource', type=d.T.string)]),
              withResource(resource): { valueFrom+: { resourceFieldRef+: { resource: resource } } },
            },
            '#secretKeyRef':: d.obj(help=''),
            secretKeyRef: {
              '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { valueFrom+: { secretKeyRef+: { key: key } } },
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { valueFrom+: { secretKeyRef+: { name: name } } },
              '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { valueFrom+: { secretKeyRef+: { optional: optional } } },
            },
          },
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { name: name },
          '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#envFrom':: d.obj(help=''),
        envFrom: {
          '#configMapRef':: d.obj(help=''),
          configMapRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { configMapRef+: { name: name } },
            '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { configMapRef+: { optional: optional } },
          },
          '#secretRef':: d.obj(help=''),
          secretRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { secretRef+: { name: name } },
            '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { secretRef+: { optional: optional } },
          },
          '#withPrefix':: d.fn(help='', args=[d.arg(name='prefix', type=d.T.string)]),
          withPrefix(prefix): { prefix: prefix },
        },
        '#resources':: d.obj(help='"expected resources for the container"'),
        resources: {
          '#withLimits':: d.fn(help='"resource limits for the container"', args=[d.arg(name='limits', type=d.T.object)]),
          withLimits(limits): { run+: { resources+: { limits: limits } } },
          '#withLimitsMixin':: d.fn(help='"resource limits for the container"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='limits', type=d.T.object)]),
          withLimitsMixin(limits): { run+: { resources+: { limits+: limits } } },
          '#withRequests':: d.fn(help='"resource requests for the container"', args=[d.arg(name='requests', type=d.T.object)]),
          withRequests(requests): { run+: { resources+: { requests: requests } } },
          '#withRequestsMixin':: d.fn(help='"resource requests for the container"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requests', type=d.T.object)]),
          withRequestsMixin(requests): { run+: { resources+: { requests+: requests } } },
        },
        '#securityContext':: d.obj(help=''),
        securityContext: {
          '#appArmorProfile':: d.obj(help=''),
          appArmorProfile: {
            '#withLocalhostProfile':: d.fn(help='', args=[d.arg(name='localhostProfile', type=d.T.string)]),
            withLocalhostProfile(localhostProfile): { run+: { securityContext+: { appArmorProfile+: { localhostProfile: localhostProfile } } } },
            '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
            withType(type): { run+: { securityContext+: { appArmorProfile+: { type: type } } } },
          },
          '#capabilities':: d.obj(help=''),
          capabilities: {
            '#withAdd':: d.fn(help='', args=[d.arg(name='add', type=d.T.array)]),
            withAdd(add): { run+: { securityContext+: { capabilities+: { add: if std.isArray(v=add) then add else [add] } } } },
            '#withAddMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='add', type=d.T.array)]),
            withAddMixin(add): { run+: { securityContext+: { capabilities+: { add+: if std.isArray(v=add) then add else [add] } } } },
            '#withDrop':: d.fn(help='', args=[d.arg(name='drop', type=d.T.array)]),
            withDrop(drop): { run+: { securityContext+: { capabilities+: { drop: if std.isArray(v=drop) then drop else [drop] } } } },
            '#withDropMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='drop', type=d.T.array)]),
            withDropMixin(drop): { run+: { securityContext+: { capabilities+: { drop+: if std.isArray(v=drop) then drop else [drop] } } } },
          },
          '#seLinuxOptions':: d.obj(help=''),
          seLinuxOptions: {
            '#withLevel':: d.fn(help='', args=[d.arg(name='level', type=d.T.string)]),
            withLevel(level): { run+: { securityContext+: { seLinuxOptions+: { level: level } } } },
            '#withRole':: d.fn(help='', args=[d.arg(name='role', type=d.T.string)]),
            withRole(role): { run+: { securityContext+: { seLinuxOptions+: { role: role } } } },
            '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
            withType(type): { run+: { securityContext+: { seLinuxOptions+: { type: type } } } },
            '#withUser':: d.fn(help='', args=[d.arg(name='user', type=d.T.string)]),
            withUser(user): { run+: { securityContext+: { seLinuxOptions+: { user: user } } } },
          },
          '#seccompProfile':: d.obj(help=''),
          seccompProfile: {
            '#withLocalhostProfile':: d.fn(help='', args=[d.arg(name='localhostProfile', type=d.T.string)]),
            withLocalhostProfile(localhostProfile): { run+: { securityContext+: { seccompProfile+: { localhostProfile: localhostProfile } } } },
            '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
            withType(type): { run+: { securityContext+: { seccompProfile+: { type: type } } } },
          },
          '#windowsOptions':: d.obj(help=''),
          windowsOptions: {
            '#withGmsaCredentialSpec':: d.fn(help='', args=[d.arg(name='gmsaCredentialSpec', type=d.T.string)]),
            withGmsaCredentialSpec(gmsaCredentialSpec): { run+: { securityContext+: { windowsOptions+: { gmsaCredentialSpec: gmsaCredentialSpec } } } },
            '#withGmsaCredentialSpecName':: d.fn(help='', args=[d.arg(name='gmsaCredentialSpecName', type=d.T.string)]),
            withGmsaCredentialSpecName(gmsaCredentialSpecName): { run+: { securityContext+: { windowsOptions+: { gmsaCredentialSpecName: gmsaCredentialSpecName } } } },
            '#withHostProcess':: d.fn(help='', args=[d.arg(name='hostProcess', type=d.T.boolean)]),
            withHostProcess(hostProcess): { run+: { securityContext+: { windowsOptions+: { hostProcess: hostProcess } } } },
            '#withRunAsUserName':: d.fn(help='', args=[d.arg(name='runAsUserName', type=d.T.string)]),
            withRunAsUserName(runAsUserName): { run+: { securityContext+: { windowsOptions+: { runAsUserName: runAsUserName } } } },
          },
          '#withAllowPrivilegeEscalation':: d.fn(help='', args=[d.arg(name='allowPrivilegeEscalation', type=d.T.boolean)]),
          withAllowPrivilegeEscalation(allowPrivilegeEscalation): { run+: { securityContext+: { allowPrivilegeEscalation: allowPrivilegeEscalation } } },
          '#withPrivileged':: d.fn(help='', args=[d.arg(name='privileged', type=d.T.boolean)]),
          withPrivileged(privileged): { run+: { securityContext+: { privileged: privileged } } },
          '#withProcMount':: d.fn(help='', args=[d.arg(name='procMount', type=d.T.string)]),
          withProcMount(procMount): { run+: { securityContext+: { procMount: procMount } } },
          '#withReadOnlyRootFilesystem':: d.fn(help='', args=[d.arg(name='readOnlyRootFilesystem', type=d.T.boolean)]),
          withReadOnlyRootFilesystem(readOnlyRootFilesystem): { run+: { securityContext+: { readOnlyRootFilesystem: readOnlyRootFilesystem } } },
          '#withRunAsGroup':: d.fn(help='', args=[d.arg(name='runAsGroup', type=d.T.integer)]),
          withRunAsGroup(runAsGroup): { run+: { securityContext+: { runAsGroup: runAsGroup } } },
          '#withRunAsNonRoot':: d.fn(help='', args=[d.arg(name='runAsNonRoot', type=d.T.boolean)]),
          withRunAsNonRoot(runAsNonRoot): { run+: { securityContext+: { runAsNonRoot: runAsNonRoot } } },
          '#withRunAsUser':: d.fn(help='', args=[d.arg(name='runAsUser', type=d.T.integer)]),
          withRunAsUser(runAsUser): { run+: { securityContext+: { runAsUser: runAsUser } } },
        },
        '#volumeMounts':: d.obj(help=''),
        volumeMounts: {
          '#withMountPath':: d.fn(help='', args=[d.arg(name='mountPath', type=d.T.string)]),
          withMountPath(mountPath): { mountPath: mountPath },
          '#withMountPropagation':: d.fn(help='', args=[d.arg(name='mountPropagation', type=d.T.string)]),
          withMountPropagation(mountPropagation): { mountPropagation: mountPropagation },
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { name: name },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { readOnly: readOnly },
          '#withRecursiveReadOnly':: d.fn(help='', args=[d.arg(name='recursiveReadOnly', type=d.T.string)]),
          withRecursiveReadOnly(recursiveReadOnly): { recursiveReadOnly: recursiveReadOnly },
          '#withSubPath':: d.fn(help='', args=[d.arg(name='subPath', type=d.T.string)]),
          withSubPath(subPath): { subPath: subPath },
          '#withSubPathExpr':: d.fn(help='', args=[d.arg(name='subPathExpr', type=d.T.string)]),
          withSubPathExpr(subPathExpr): { subPathExpr: subPathExpr },
        },
        '#withArgs':: d.fn(help='"override default command in the image (empty string to default CMD of the image)"', args=[d.arg(name='args', type=d.T.array)]),
        withArgs(args): { run+: { args: if std.isArray(v=args) then args else [args] } },
        '#withArgsMixin':: d.fn(help='"override default command in the image (empty string to default CMD of the image)"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='args', type=d.T.array)]),
        withArgsMixin(args): { run+: { args+: if std.isArray(v=args) then args else [args] } },
        '#withCommand':: d.fn(help='"override default command in the image (empty string to default ENTRYPOINT of the image)"', args=[d.arg(name='command', type=d.T.array)]),
        withCommand(command): { run+: { command: if std.isArray(v=command) then command else [command] } },
        '#withCommandMixin':: d.fn(help='"override default command in the image (empty string to default ENTRYPOINT of the image)"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='command', type=d.T.array)]),
        withCommandMixin(command): { run+: { command+: if std.isArray(v=command) then command else [command] } },
        '#withEnv':: d.fn(help='', args=[d.arg(name='env', type=d.T.array)]),
        withEnv(env): { run+: { env: if std.isArray(v=env) then env else [env] } },
        '#withEnvFrom':: d.fn(help='', args=[d.arg(name='envFrom', type=d.T.array)]),
        withEnvFrom(envFrom): { run+: { envFrom: if std.isArray(v=envFrom) then envFrom else [envFrom] } },
        '#withEnvFromMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='envFrom', type=d.T.array)]),
        withEnvFromMixin(envFrom): { run+: { envFrom+: if std.isArray(v=envFrom) then envFrom else [envFrom] } },
        '#withEnvMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='env', type=d.T.array)]),
        withEnvMixin(env): { run+: { env+: if std.isArray(v=env) then env else [env] } },
        '#withImage':: d.fn(help='"image to be used for the container"', args=[d.arg(name='image', type=d.T.string)]),
        withImage(image): { run+: { image: image } },
        '#withImagePullPolicy':: d.fn(help='"pulling policy for the image"', args=[d.arg(name='imagePullPolicy', type=d.T.string)]),
        withImagePullPolicy(imagePullPolicy): { run+: { imagePullPolicy: imagePullPolicy } },
        '#withShell':: d.fn(help='"script to run in a default shell for the container"', args=[d.arg(name='shell', type=d.T.string)]),
        withShell(shell): { run+: { shell: shell } },
        '#withVolumeMounts':: d.fn(help='', args=[d.arg(name='volumeMounts', type=d.T.array)]),
        withVolumeMounts(volumeMounts): { run+: { volumeMounts: if std.isArray(v=volumeMounts) then volumeMounts else [volumeMounts] } },
        '#withVolumeMountsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='volumeMounts', type=d.T.array)]),
        withVolumeMountsMixin(volumeMounts): { run+: { volumeMounts+: if std.isArray(v=volumeMounts) then volumeMounts else [volumeMounts] } },
        '#withWorkingDir':: d.fn(help='"override default working directory in the image (empty string to default WORKDIR for the image)"', args=[d.arg(name='workingDir', type=d.T.string)]),
        withWorkingDir(workingDir): { run+: { workingDir: workingDir } },
      },
      '#withCondition':: d.fn(help='"expression to declare under which conditions the step should be run\\ndefaults to: \\"passed\\", except artifacts where it defaults to \\"always\\', args=[d.arg(name='condition', type=d.T.string)]),
      withCondition(condition): { condition: condition },
      '#withDelay':: d.fn(help='"delay before the step"', args=[d.arg(name='delay', type=d.T.string)]),
      withDelay(delay): { delay: delay },
      '#withName':: d.fn(help='"readable name for the step"', args=[d.arg(name='name', type=d.T.string)]),
      withName(name): { name: name },
      '#withNegative':: d.fn(help='"is the step expected to fail"', args=[d.arg(name='negative', type=d.T.boolean)]),
      withNegative(negative): { negative: negative },
      '#withOptional':: d.fn(help="\"is the step optional, so its failure won't affect the TestWorkflow result\"", args=[d.arg(name='optional', type=d.T.boolean)]),
      withOptional(optional): { optional: optional },
      '#withPaused':: d.fn(help='"pause the step initially"', args=[d.arg(name='paused', type=d.T.boolean)]),
      withPaused(paused): { paused: paused },
      '#withPure':: d.fn(help='"mark the step as pure, applying optimizations to merge the containers together"', args=[d.arg(name='pure', type=d.T.boolean)]),
      withPure(pure): { pure: pure },
      '#withServices':: d.fn(help='"list of accompanying services to start"', args=[d.arg(name='services', type=d.T.object)]),
      withServices(services): { services: services },
      '#withServicesMixin':: d.fn(help='"list of accompanying services to start"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='services', type=d.T.object)]),
      withServicesMixin(services): { services+: services },
      '#withSetup':: d.fn(help='"steps to run before other operations in this step"', args=[d.arg(name='setup', type=d.T.any)]),
      withSetup(setup): { setup: setup },
      '#withShell':: d.fn(help='"script to run in a default shell for the container"', args=[d.arg(name='shell', type=d.T.string)]),
      withShell(shell): { shell: shell },
      '#withSteps':: d.fn(help='"sub-steps to run"', args=[d.arg(name='steps', type=d.T.any)]),
      withSteps(steps): { steps: steps },
      '#withTimeout':: d.fn(help='"maximum time this step may take"', args=[d.arg(name='timeout', type=d.T.string)]),
      withTimeout(timeout): { timeout: timeout },
      '#withWorkingDir':: d.fn(help='"working directory to use for this step"', args=[d.arg(name='workingDir', type=d.T.string)]),
      withWorkingDir(workingDir): { workingDir: workingDir },
    },
    '#container':: d.obj(help='"defaults for the containers for all the TestWorkflow steps"'),
    container: {
      '#env':: d.obj(help=''),
      env: {
        '#valueFrom':: d.obj(help=''),
        valueFrom: {
          '#configMapKeyRef':: d.obj(help=''),
          configMapKeyRef: {
            '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { valueFrom+: { configMapKeyRef+: { key: key } } },
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { valueFrom+: { configMapKeyRef+: { name: name } } },
            '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { valueFrom+: { configMapKeyRef+: { optional: optional } } },
          },
          '#fieldRef':: d.obj(help=''),
          fieldRef: {
            '#withApiVersion':: d.fn(help='', args=[d.arg(name='apiVersion', type=d.T.string)]),
            withApiVersion(apiVersion): { valueFrom+: { fieldRef+: { apiVersion: apiVersion } } },
            '#withFieldPath':: d.fn(help='', args=[d.arg(name='fieldPath', type=d.T.string)]),
            withFieldPath(fieldPath): { valueFrom+: { fieldRef+: { fieldPath: fieldPath } } },
          },
          '#resourceFieldRef':: d.obj(help=''),
          resourceFieldRef: {
            '#withContainerName':: d.fn(help='', args=[d.arg(name='containerName', type=d.T.string)]),
            withContainerName(containerName): { valueFrom+: { resourceFieldRef+: { containerName: containerName } } },
            '#withDivisor':: d.fn(help='', args=[d.arg(name='divisor', type=d.T.any)]),
            withDivisor(divisor): { valueFrom+: { resourceFieldRef+: { divisor: divisor } } },
            '#withResource':: d.fn(help='', args=[d.arg(name='resource', type=d.T.string)]),
            withResource(resource): { valueFrom+: { resourceFieldRef+: { resource: resource } } },
          },
          '#secretKeyRef':: d.obj(help=''),
          secretKeyRef: {
            '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { valueFrom+: { secretKeyRef+: { key: key } } },
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { valueFrom+: { secretKeyRef+: { name: name } } },
            '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { valueFrom+: { secretKeyRef+: { optional: optional } } },
          },
        },
        '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { name: name },
        '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
        withValue(value): { value: value },
      },
      '#envFrom':: d.obj(help=''),
      envFrom: {
        '#configMapRef':: d.obj(help=''),
        configMapRef: {
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { configMapRef+: { name: name } },
          '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
          withOptional(optional): { configMapRef+: { optional: optional } },
        },
        '#secretRef':: d.obj(help=''),
        secretRef: {
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { secretRef+: { name: name } },
          '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
          withOptional(optional): { secretRef+: { optional: optional } },
        },
        '#withPrefix':: d.fn(help='', args=[d.arg(name='prefix', type=d.T.string)]),
        withPrefix(prefix): { prefix: prefix },
      },
      '#resources':: d.obj(help='"expected resources for the container"'),
      resources: {
        '#withLimits':: d.fn(help='"resource limits for the container"', args=[d.arg(name='limits', type=d.T.object)]),
        withLimits(limits): { spec+: { container+: { resources+: { limits: limits } } } },
        '#withLimitsMixin':: d.fn(help='"resource limits for the container"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='limits', type=d.T.object)]),
        withLimitsMixin(limits): { spec+: { container+: { resources+: { limits+: limits } } } },
        '#withRequests':: d.fn(help='"resource requests for the container"', args=[d.arg(name='requests', type=d.T.object)]),
        withRequests(requests): { spec+: { container+: { resources+: { requests: requests } } } },
        '#withRequestsMixin':: d.fn(help='"resource requests for the container"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requests', type=d.T.object)]),
        withRequestsMixin(requests): { spec+: { container+: { resources+: { requests+: requests } } } },
      },
      '#securityContext':: d.obj(help=''),
      securityContext: {
        '#appArmorProfile':: d.obj(help=''),
        appArmorProfile: {
          '#withLocalhostProfile':: d.fn(help='', args=[d.arg(name='localhostProfile', type=d.T.string)]),
          withLocalhostProfile(localhostProfile): { spec+: { container+: { securityContext+: { appArmorProfile+: { localhostProfile: localhostProfile } } } } },
          '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
          withType(type): { spec+: { container+: { securityContext+: { appArmorProfile+: { type: type } } } } },
        },
        '#capabilities':: d.obj(help=''),
        capabilities: {
          '#withAdd':: d.fn(help='', args=[d.arg(name='add', type=d.T.array)]),
          withAdd(add): { spec+: { container+: { securityContext+: { capabilities+: { add: if std.isArray(v=add) then add else [add] } } } } },
          '#withAddMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='add', type=d.T.array)]),
          withAddMixin(add): { spec+: { container+: { securityContext+: { capabilities+: { add+: if std.isArray(v=add) then add else [add] } } } } },
          '#withDrop':: d.fn(help='', args=[d.arg(name='drop', type=d.T.array)]),
          withDrop(drop): { spec+: { container+: { securityContext+: { capabilities+: { drop: if std.isArray(v=drop) then drop else [drop] } } } } },
          '#withDropMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='drop', type=d.T.array)]),
          withDropMixin(drop): { spec+: { container+: { securityContext+: { capabilities+: { drop+: if std.isArray(v=drop) then drop else [drop] } } } } },
        },
        '#seLinuxOptions':: d.obj(help=''),
        seLinuxOptions: {
          '#withLevel':: d.fn(help='', args=[d.arg(name='level', type=d.T.string)]),
          withLevel(level): { spec+: { container+: { securityContext+: { seLinuxOptions+: { level: level } } } } },
          '#withRole':: d.fn(help='', args=[d.arg(name='role', type=d.T.string)]),
          withRole(role): { spec+: { container+: { securityContext+: { seLinuxOptions+: { role: role } } } } },
          '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
          withType(type): { spec+: { container+: { securityContext+: { seLinuxOptions+: { type: type } } } } },
          '#withUser':: d.fn(help='', args=[d.arg(name='user', type=d.T.string)]),
          withUser(user): { spec+: { container+: { securityContext+: { seLinuxOptions+: { user: user } } } } },
        },
        '#seccompProfile':: d.obj(help=''),
        seccompProfile: {
          '#withLocalhostProfile':: d.fn(help='', args=[d.arg(name='localhostProfile', type=d.T.string)]),
          withLocalhostProfile(localhostProfile): { spec+: { container+: { securityContext+: { seccompProfile+: { localhostProfile: localhostProfile } } } } },
          '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
          withType(type): { spec+: { container+: { securityContext+: { seccompProfile+: { type: type } } } } },
        },
        '#windowsOptions':: d.obj(help=''),
        windowsOptions: {
          '#withGmsaCredentialSpec':: d.fn(help='', args=[d.arg(name='gmsaCredentialSpec', type=d.T.string)]),
          withGmsaCredentialSpec(gmsaCredentialSpec): { spec+: { container+: { securityContext+: { windowsOptions+: { gmsaCredentialSpec: gmsaCredentialSpec } } } } },
          '#withGmsaCredentialSpecName':: d.fn(help='', args=[d.arg(name='gmsaCredentialSpecName', type=d.T.string)]),
          withGmsaCredentialSpecName(gmsaCredentialSpecName): { spec+: { container+: { securityContext+: { windowsOptions+: { gmsaCredentialSpecName: gmsaCredentialSpecName } } } } },
          '#withHostProcess':: d.fn(help='', args=[d.arg(name='hostProcess', type=d.T.boolean)]),
          withHostProcess(hostProcess): { spec+: { container+: { securityContext+: { windowsOptions+: { hostProcess: hostProcess } } } } },
          '#withRunAsUserName':: d.fn(help='', args=[d.arg(name='runAsUserName', type=d.T.string)]),
          withRunAsUserName(runAsUserName): { spec+: { container+: { securityContext+: { windowsOptions+: { runAsUserName: runAsUserName } } } } },
        },
        '#withAllowPrivilegeEscalation':: d.fn(help='', args=[d.arg(name='allowPrivilegeEscalation', type=d.T.boolean)]),
        withAllowPrivilegeEscalation(allowPrivilegeEscalation): { spec+: { container+: { securityContext+: { allowPrivilegeEscalation: allowPrivilegeEscalation } } } },
        '#withPrivileged':: d.fn(help='', args=[d.arg(name='privileged', type=d.T.boolean)]),
        withPrivileged(privileged): { spec+: { container+: { securityContext+: { privileged: privileged } } } },
        '#withProcMount':: d.fn(help='', args=[d.arg(name='procMount', type=d.T.string)]),
        withProcMount(procMount): { spec+: { container+: { securityContext+: { procMount: procMount } } } },
        '#withReadOnlyRootFilesystem':: d.fn(help='', args=[d.arg(name='readOnlyRootFilesystem', type=d.T.boolean)]),
        withReadOnlyRootFilesystem(readOnlyRootFilesystem): { spec+: { container+: { securityContext+: { readOnlyRootFilesystem: readOnlyRootFilesystem } } } },
        '#withRunAsGroup':: d.fn(help='', args=[d.arg(name='runAsGroup', type=d.T.integer)]),
        withRunAsGroup(runAsGroup): { spec+: { container+: { securityContext+: { runAsGroup: runAsGroup } } } },
        '#withRunAsNonRoot':: d.fn(help='', args=[d.arg(name='runAsNonRoot', type=d.T.boolean)]),
        withRunAsNonRoot(runAsNonRoot): { spec+: { container+: { securityContext+: { runAsNonRoot: runAsNonRoot } } } },
        '#withRunAsUser':: d.fn(help='', args=[d.arg(name='runAsUser', type=d.T.integer)]),
        withRunAsUser(runAsUser): { spec+: { container+: { securityContext+: { runAsUser: runAsUser } } } },
      },
      '#volumeMounts':: d.obj(help=''),
      volumeMounts: {
        '#withMountPath':: d.fn(help='', args=[d.arg(name='mountPath', type=d.T.string)]),
        withMountPath(mountPath): { mountPath: mountPath },
        '#withMountPropagation':: d.fn(help='', args=[d.arg(name='mountPropagation', type=d.T.string)]),
        withMountPropagation(mountPropagation): { mountPropagation: mountPropagation },
        '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { name: name },
        '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
        withReadOnly(readOnly): { readOnly: readOnly },
        '#withRecursiveReadOnly':: d.fn(help='', args=[d.arg(name='recursiveReadOnly', type=d.T.string)]),
        withRecursiveReadOnly(recursiveReadOnly): { recursiveReadOnly: recursiveReadOnly },
        '#withSubPath':: d.fn(help='', args=[d.arg(name='subPath', type=d.T.string)]),
        withSubPath(subPath): { subPath: subPath },
        '#withSubPathExpr':: d.fn(help='', args=[d.arg(name='subPathExpr', type=d.T.string)]),
        withSubPathExpr(subPathExpr): { subPathExpr: subPathExpr },
      },
      '#withArgs':: d.fn(help='"override default command in the image (empty string to default CMD of the image)"', args=[d.arg(name='args', type=d.T.array)]),
      withArgs(args): { spec+: { container+: { args: if std.isArray(v=args) then args else [args] } } },
      '#withArgsMixin':: d.fn(help='"override default command in the image (empty string to default CMD of the image)"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='args', type=d.T.array)]),
      withArgsMixin(args): { spec+: { container+: { args+: if std.isArray(v=args) then args else [args] } } },
      '#withCommand':: d.fn(help='"override default command in the image (empty string to default ENTRYPOINT of the image)"', args=[d.arg(name='command', type=d.T.array)]),
      withCommand(command): { spec+: { container+: { command: if std.isArray(v=command) then command else [command] } } },
      '#withCommandMixin':: d.fn(help='"override default command in the image (empty string to default ENTRYPOINT of the image)"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='command', type=d.T.array)]),
      withCommandMixin(command): { spec+: { container+: { command+: if std.isArray(v=command) then command else [command] } } },
      '#withEnv':: d.fn(help='', args=[d.arg(name='env', type=d.T.array)]),
      withEnv(env): { spec+: { container+: { env: if std.isArray(v=env) then env else [env] } } },
      '#withEnvFrom':: d.fn(help='', args=[d.arg(name='envFrom', type=d.T.array)]),
      withEnvFrom(envFrom): { spec+: { container+: { envFrom: if std.isArray(v=envFrom) then envFrom else [envFrom] } } },
      '#withEnvFromMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='envFrom', type=d.T.array)]),
      withEnvFromMixin(envFrom): { spec+: { container+: { envFrom+: if std.isArray(v=envFrom) then envFrom else [envFrom] } } },
      '#withEnvMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='env', type=d.T.array)]),
      withEnvMixin(env): { spec+: { container+: { env+: if std.isArray(v=env) then env else [env] } } },
      '#withImage':: d.fn(help='"image to be used for the container"', args=[d.arg(name='image', type=d.T.string)]),
      withImage(image): { spec+: { container+: { image: image } } },
      '#withImagePullPolicy':: d.fn(help='"pulling policy for the image"', args=[d.arg(name='imagePullPolicy', type=d.T.string)]),
      withImagePullPolicy(imagePullPolicy): { spec+: { container+: { imagePullPolicy: imagePullPolicy } } },
      '#withVolumeMounts':: d.fn(help='', args=[d.arg(name='volumeMounts', type=d.T.array)]),
      withVolumeMounts(volumeMounts): { spec+: { container+: { volumeMounts: if std.isArray(v=volumeMounts) then volumeMounts else [volumeMounts] } } },
      '#withVolumeMountsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='volumeMounts', type=d.T.array)]),
      withVolumeMountsMixin(volumeMounts): { spec+: { container+: { volumeMounts+: if std.isArray(v=volumeMounts) then volumeMounts else [volumeMounts] } } },
      '#withWorkingDir':: d.fn(help='"override default working directory in the image (empty string to default WORKDIR for the image)"', args=[d.arg(name='workingDir', type=d.T.string)]),
      withWorkingDir(workingDir): { spec+: { container+: { workingDir: workingDir } } },
    },
    '#content':: d.obj(help='"global content that should be fetched into all containers"'),
    content: {
      '#files':: d.obj(help='"files to load"'),
      files: {
        '#contentFrom':: d.obj(help='"external source to use"'),
        contentFrom: {
          '#configMapKeyRef':: d.obj(help=''),
          configMapKeyRef: {
            '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { contentFrom+: { configMapKeyRef+: { key: key } } },
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { contentFrom+: { configMapKeyRef+: { name: name } } },
            '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { contentFrom+: { configMapKeyRef+: { optional: optional } } },
          },
          '#fieldRef':: d.obj(help=''),
          fieldRef: {
            '#withApiVersion':: d.fn(help='', args=[d.arg(name='apiVersion', type=d.T.string)]),
            withApiVersion(apiVersion): { contentFrom+: { fieldRef+: { apiVersion: apiVersion } } },
            '#withFieldPath':: d.fn(help='', args=[d.arg(name='fieldPath', type=d.T.string)]),
            withFieldPath(fieldPath): { contentFrom+: { fieldRef+: { fieldPath: fieldPath } } },
          },
          '#resourceFieldRef':: d.obj(help=''),
          resourceFieldRef: {
            '#withContainerName':: d.fn(help='', args=[d.arg(name='containerName', type=d.T.string)]),
            withContainerName(containerName): { contentFrom+: { resourceFieldRef+: { containerName: containerName } } },
            '#withDivisor':: d.fn(help='', args=[d.arg(name='divisor', type=d.T.any)]),
            withDivisor(divisor): { contentFrom+: { resourceFieldRef+: { divisor: divisor } } },
            '#withResource':: d.fn(help='', args=[d.arg(name='resource', type=d.T.string)]),
            withResource(resource): { contentFrom+: { resourceFieldRef+: { resource: resource } } },
          },
          '#secretKeyRef':: d.obj(help=''),
          secretKeyRef: {
            '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { contentFrom+: { secretKeyRef+: { key: key } } },
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { contentFrom+: { secretKeyRef+: { name: name } } },
            '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { contentFrom+: { secretKeyRef+: { optional: optional } } },
          },
        },
        '#withContent':: d.fn(help='"plain-text content to put inside"', args=[d.arg(name='content', type=d.T.string)]),
        withContent(content): { content: content },
        '#withMode':: d.fn(help='"mode to use for the file"', args=[d.arg(name='mode', type=d.T.integer)]),
        withMode(mode): { mode: mode },
        '#withPath':: d.fn(help='"path where the file should be accessible at"', args=[d.arg(name='path', type=d.T.string)]),
        withPath(path): { path: path },
      },
      '#git':: d.obj(help='"git repository details"'),
      git: {
        '#sshKeyFrom':: d.obj(help='"external SSH private key to fetch with"'),
        sshKeyFrom: {
          '#configMapKeyRef':: d.obj(help=''),
          configMapKeyRef: {
            '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { spec+: { content+: { git+: { sshKeyFrom+: { configMapKeyRef+: { key: key } } } } } },
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { spec+: { content+: { git+: { sshKeyFrom+: { configMapKeyRef+: { name: name } } } } } },
            '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { spec+: { content+: { git+: { sshKeyFrom+: { configMapKeyRef+: { optional: optional } } } } } },
          },
          '#fieldRef':: d.obj(help=''),
          fieldRef: {
            '#withApiVersion':: d.fn(help='', args=[d.arg(name='apiVersion', type=d.T.string)]),
            withApiVersion(apiVersion): { spec+: { content+: { git+: { sshKeyFrom+: { fieldRef+: { apiVersion: apiVersion } } } } } },
            '#withFieldPath':: d.fn(help='', args=[d.arg(name='fieldPath', type=d.T.string)]),
            withFieldPath(fieldPath): { spec+: { content+: { git+: { sshKeyFrom+: { fieldRef+: { fieldPath: fieldPath } } } } } },
          },
          '#resourceFieldRef':: d.obj(help=''),
          resourceFieldRef: {
            '#withContainerName':: d.fn(help='', args=[d.arg(name='containerName', type=d.T.string)]),
            withContainerName(containerName): { spec+: { content+: { git+: { sshKeyFrom+: { resourceFieldRef+: { containerName: containerName } } } } } },
            '#withDivisor':: d.fn(help='', args=[d.arg(name='divisor', type=d.T.any)]),
            withDivisor(divisor): { spec+: { content+: { git+: { sshKeyFrom+: { resourceFieldRef+: { divisor: divisor } } } } } },
            '#withResource':: d.fn(help='', args=[d.arg(name='resource', type=d.T.string)]),
            withResource(resource): { spec+: { content+: { git+: { sshKeyFrom+: { resourceFieldRef+: { resource: resource } } } } } },
          },
          '#secretKeyRef':: d.obj(help=''),
          secretKeyRef: {
            '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { spec+: { content+: { git+: { sshKeyFrom+: { secretKeyRef+: { key: key } } } } } },
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { spec+: { content+: { git+: { sshKeyFrom+: { secretKeyRef+: { name: name } } } } } },
            '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { spec+: { content+: { git+: { sshKeyFrom+: { secretKeyRef+: { optional: optional } } } } } },
          },
        },
        '#tokenFrom':: d.obj(help='"external token to fetch with"'),
        tokenFrom: {
          '#configMapKeyRef':: d.obj(help=''),
          configMapKeyRef: {
            '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { spec+: { content+: { git+: { tokenFrom+: { configMapKeyRef+: { key: key } } } } } },
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { spec+: { content+: { git+: { tokenFrom+: { configMapKeyRef+: { name: name } } } } } },
            '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { spec+: { content+: { git+: { tokenFrom+: { configMapKeyRef+: { optional: optional } } } } } },
          },
          '#fieldRef':: d.obj(help=''),
          fieldRef: {
            '#withApiVersion':: d.fn(help='', args=[d.arg(name='apiVersion', type=d.T.string)]),
            withApiVersion(apiVersion): { spec+: { content+: { git+: { tokenFrom+: { fieldRef+: { apiVersion: apiVersion } } } } } },
            '#withFieldPath':: d.fn(help='', args=[d.arg(name='fieldPath', type=d.T.string)]),
            withFieldPath(fieldPath): { spec+: { content+: { git+: { tokenFrom+: { fieldRef+: { fieldPath: fieldPath } } } } } },
          },
          '#resourceFieldRef':: d.obj(help=''),
          resourceFieldRef: {
            '#withContainerName':: d.fn(help='', args=[d.arg(name='containerName', type=d.T.string)]),
            withContainerName(containerName): { spec+: { content+: { git+: { tokenFrom+: { resourceFieldRef+: { containerName: containerName } } } } } },
            '#withDivisor':: d.fn(help='', args=[d.arg(name='divisor', type=d.T.any)]),
            withDivisor(divisor): { spec+: { content+: { git+: { tokenFrom+: { resourceFieldRef+: { divisor: divisor } } } } } },
            '#withResource':: d.fn(help='', args=[d.arg(name='resource', type=d.T.string)]),
            withResource(resource): { spec+: { content+: { git+: { tokenFrom+: { resourceFieldRef+: { resource: resource } } } } } },
          },
          '#secretKeyRef':: d.obj(help=''),
          secretKeyRef: {
            '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { spec+: { content+: { git+: { tokenFrom+: { secretKeyRef+: { key: key } } } } } },
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { spec+: { content+: { git+: { tokenFrom+: { secretKeyRef+: { name: name } } } } } },
            '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { spec+: { content+: { git+: { tokenFrom+: { secretKeyRef+: { optional: optional } } } } } },
          },
        },
        '#usernameFrom':: d.obj(help='"external username to fetch with"'),
        usernameFrom: {
          '#configMapKeyRef':: d.obj(help=''),
          configMapKeyRef: {
            '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { spec+: { content+: { git+: { usernameFrom+: { configMapKeyRef+: { key: key } } } } } },
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { spec+: { content+: { git+: { usernameFrom+: { configMapKeyRef+: { name: name } } } } } },
            '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { spec+: { content+: { git+: { usernameFrom+: { configMapKeyRef+: { optional: optional } } } } } },
          },
          '#fieldRef':: d.obj(help=''),
          fieldRef: {
            '#withApiVersion':: d.fn(help='', args=[d.arg(name='apiVersion', type=d.T.string)]),
            withApiVersion(apiVersion): { spec+: { content+: { git+: { usernameFrom+: { fieldRef+: { apiVersion: apiVersion } } } } } },
            '#withFieldPath':: d.fn(help='', args=[d.arg(name='fieldPath', type=d.T.string)]),
            withFieldPath(fieldPath): { spec+: { content+: { git+: { usernameFrom+: { fieldRef+: { fieldPath: fieldPath } } } } } },
          },
          '#resourceFieldRef':: d.obj(help=''),
          resourceFieldRef: {
            '#withContainerName':: d.fn(help='', args=[d.arg(name='containerName', type=d.T.string)]),
            withContainerName(containerName): { spec+: { content+: { git+: { usernameFrom+: { resourceFieldRef+: { containerName: containerName } } } } } },
            '#withDivisor':: d.fn(help='', args=[d.arg(name='divisor', type=d.T.any)]),
            withDivisor(divisor): { spec+: { content+: { git+: { usernameFrom+: { resourceFieldRef+: { divisor: divisor } } } } } },
            '#withResource':: d.fn(help='', args=[d.arg(name='resource', type=d.T.string)]),
            withResource(resource): { spec+: { content+: { git+: { usernameFrom+: { resourceFieldRef+: { resource: resource } } } } } },
          },
          '#secretKeyRef':: d.obj(help=''),
          secretKeyRef: {
            '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { spec+: { content+: { git+: { usernameFrom+: { secretKeyRef+: { key: key } } } } } },
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { spec+: { content+: { git+: { usernameFrom+: { secretKeyRef+: { name: name } } } } } },
            '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { spec+: { content+: { git+: { usernameFrom+: { secretKeyRef+: { optional: optional } } } } } },
          },
        },
        '#withAuthType':: d.fn(help='"authorization type for the credentials"', args=[d.arg(name='authType', type=d.T.string)]),
        withAuthType(authType): { spec+: { content+: { git+: { authType: authType } } } },
        '#withCone':: d.fn(help='"enable cone mode for sparse checkout with paths"', args=[d.arg(name='cone', type=d.T.boolean)]),
        withCone(cone): { spec+: { content+: { git+: { cone: cone } } } },
        '#withMountPath':: d.fn(help='"where to mount the fetched repository contents (defaults to \\"repo\\" directory in the data volume)"', args=[d.arg(name='mountPath', type=d.T.string)]),
        withMountPath(mountPath): { spec+: { content+: { git+: { mountPath: mountPath } } } },
        '#withPaths':: d.fn(help='"paths to fetch for the sparse checkout"', args=[d.arg(name='paths', type=d.T.array)]),
        withPaths(paths): { spec+: { content+: { git+: { paths: if std.isArray(v=paths) then paths else [paths] } } } },
        '#withPathsMixin':: d.fn(help='"paths to fetch for the sparse checkout"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='paths', type=d.T.array)]),
        withPathsMixin(paths): { spec+: { content+: { git+: { paths+: if std.isArray(v=paths) then paths else [paths] } } } },
        '#withRevision':: d.fn(help='"branch, commit or a tag name to fetch"', args=[d.arg(name='revision', type=d.T.string)]),
        withRevision(revision): { spec+: { content+: { git+: { revision: revision } } } },
        '#withSshKey':: d.fn(help='"plain text SSH private key to fetch with"', args=[d.arg(name='sshKey', type=d.T.string)]),
        withSshKey(sshKey): { spec+: { content+: { git+: { sshKey: sshKey } } } },
        '#withToken':: d.fn(help='"plain text token to fetch with"', args=[d.arg(name='token', type=d.T.string)]),
        withToken(token): { spec+: { content+: { git+: { token: token } } } },
        '#withUri':: d.fn(help='"uri for the Git repository"', args=[d.arg(name='uri', type=d.T.string)]),
        withUri(uri): { spec+: { content+: { git+: { uri: uri } } } },
        '#withUsername':: d.fn(help='"plain text username to fetch with"', args=[d.arg(name='username', type=d.T.string)]),
        withUsername(username): { spec+: { content+: { git+: { username: username } } } },
      },
      '#tarball':: d.obj(help='"tarballs to unpack"'),
      tarball: {
        '#withMount':: d.fn(help='"should it mount a new volume there"', args=[d.arg(name='mount', type=d.T.boolean)]),
        withMount(mount): { mount: mount },
        '#withPath':: d.fn(help='"path where the tarball should be extracted"', args=[d.arg(name='path', type=d.T.string)]),
        withPath(path): { path: path },
        '#withUrl':: d.fn(help='"url for the tarball to extract"', args=[d.arg(name='url', type=d.T.string)]),
        withUrl(url): { url: url },
      },
      '#withFiles':: d.fn(help='"files to load"', args=[d.arg(name='files', type=d.T.array)]),
      withFiles(files): { spec+: { content+: { files: if std.isArray(v=files) then files else [files] } } },
      '#withFilesMixin':: d.fn(help='"files to load"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='files', type=d.T.array)]),
      withFilesMixin(files): { spec+: { content+: { files+: if std.isArray(v=files) then files else [files] } } },
      '#withTarball':: d.fn(help='"tarballs to unpack"', args=[d.arg(name='tarball', type=d.T.array)]),
      withTarball(tarball): { spec+: { content+: { tarball: if std.isArray(v=tarball) then tarball else [tarball] } } },
      '#withTarballMixin':: d.fn(help='"tarballs to unpack"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='tarball', type=d.T.array)]),
      withTarballMixin(tarball): { spec+: { content+: { tarball+: if std.isArray(v=tarball) then tarball else [tarball] } } },
    },
    '#events':: d.obj(help='"events triggering execution of the test workflow"'),
    events: {
      '#cronjob':: d.obj(help='"cron job configuration"'),
      cronjob: {
        '#withAnnotations':: d.fn(help='"annotations to attach to the cron job"', args=[d.arg(name='annotations', type=d.T.object)]),
        withAnnotations(annotations): { cronjob+: { annotations: annotations } },
        '#withAnnotationsMixin':: d.fn(help='"annotations to attach to the cron job"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='annotations', type=d.T.object)]),
        withAnnotationsMixin(annotations): { cronjob+: { annotations+: annotations } },
        '#withConfig':: d.fn(help='"configuration to pass for the workflow"', args=[d.arg(name='config', type=d.T.object)]),
        withConfig(config): { cronjob+: { config: config } },
        '#withConfigMixin':: d.fn(help='"configuration to pass for the workflow"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='config', type=d.T.object)]),
        withConfigMixin(config): { cronjob+: { config+: config } },
        '#withCron':: d.fn(help='"cron schedule to run a test workflow"', args=[d.arg(name='cron', type=d.T.string)]),
        withCron(cron): { cronjob+: { cron: cron } },
        '#withLabels':: d.fn(help='"labels to attach to the cron job"', args=[d.arg(name='labels', type=d.T.object)]),
        withLabels(labels): { cronjob+: { labels: labels } },
        '#withLabelsMixin':: d.fn(help='"labels to attach to the cron job"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='labels', type=d.T.object)]),
        withLabelsMixin(labels): { cronjob+: { labels+: labels } },
      },
    },
    '#execution':: d.obj(help='"values to be used for test workflow execution"'),
    execution: {
      '#withTags':: d.fn(help='"test workflow execution tags"', args=[d.arg(name='tags', type=d.T.object)]),
      withTags(tags): { spec+: { execution+: { tags: tags } } },
      '#withTagsMixin':: d.fn(help='"test workflow execution tags"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='tags', type=d.T.object)]),
      withTagsMixin(tags): { spec+: { execution+: { tags+: tags } } },
    },
    '#job':: d.obj(help='"configuration for the scheduled job"'),
    job: {
      '#withActiveDeadlineSeconds':: d.fn(help='"duration in seconds the job may be active on the node"', args=[d.arg(name='activeDeadlineSeconds', type=d.T.integer)]),
      withActiveDeadlineSeconds(activeDeadlineSeconds): { spec+: { job+: { activeDeadlineSeconds: activeDeadlineSeconds } } },
      '#withAnnotations':: d.fn(help='"annotations added to the scheduled job"', args=[d.arg(name='annotations', type=d.T.object)]),
      withAnnotations(annotations): { spec+: { job+: { annotations: annotations } } },
      '#withAnnotationsMixin':: d.fn(help='"annotations added to the scheduled job"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='annotations', type=d.T.object)]),
      withAnnotationsMixin(annotations): { spec+: { job+: { annotations+: annotations } } },
      '#withLabels':: d.fn(help='"labels added to the scheduled job"', args=[d.arg(name='labels', type=d.T.object)]),
      withLabels(labels): { spec+: { job+: { labels: labels } } },
      '#withLabelsMixin':: d.fn(help='"labels added to the scheduled job"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='labels', type=d.T.object)]),
      withLabelsMixin(labels): { spec+: { job+: { labels+: labels } } },
      '#withNamespace':: d.fn(help='"namespace for execution of test workflow"', args=[d.arg(name='namespace', type=d.T.string)]),
      withNamespace(namespace): { spec+: { job+: { namespace: namespace } } },
    },
    '#notifications':: d.obj(help='"configuration for notifications\\nDeprecated: field is not used"'),
    notifications: {
      '#withDisableWebhooks':: d.fn(help='', args=[d.arg(name='disableWebhooks', type=d.T.boolean)]),
      withDisableWebhooks(disableWebhooks): { spec+: { notifications+: { disableWebhooks: disableWebhooks } } },
    },
    '#pod':: d.obj(help='"configuration for the scheduled pod"'),
    pod: {
      '#dnsConfig':: d.obj(help=''),
      dnsConfig: {
        '#options':: d.obj(help=''),
        options: {
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { name: name },
          '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#withNameservers':: d.fn(help='', args=[d.arg(name='nameservers', type=d.T.array)]),
        withNameservers(nameservers): { spec+: { pod+: { dnsConfig+: { nameservers: if std.isArray(v=nameservers) then nameservers else [nameservers] } } } },
        '#withNameserversMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='nameservers', type=d.T.array)]),
        withNameserversMixin(nameservers): { spec+: { pod+: { dnsConfig+: { nameservers+: if std.isArray(v=nameservers) then nameservers else [nameservers] } } } },
        '#withOptions':: d.fn(help='', args=[d.arg(name='options', type=d.T.array)]),
        withOptions(options): { spec+: { pod+: { dnsConfig+: { options: if std.isArray(v=options) then options else [options] } } } },
        '#withOptionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='options', type=d.T.array)]),
        withOptionsMixin(options): { spec+: { pod+: { dnsConfig+: { options+: if std.isArray(v=options) then options else [options] } } } },
        '#withSearches':: d.fn(help='', args=[d.arg(name='searches', type=d.T.array)]),
        withSearches(searches): { spec+: { pod+: { dnsConfig+: { searches: if std.isArray(v=searches) then searches else [searches] } } } },
        '#withSearchesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='searches', type=d.T.array)]),
        withSearchesMixin(searches): { spec+: { pod+: { dnsConfig+: { searches+: if std.isArray(v=searches) then searches else [searches] } } } },
      },
      '#hostAliases':: d.obj(help=''),
      hostAliases: {
        '#withHostnames':: d.fn(help='', args=[d.arg(name='hostnames', type=d.T.array)]),
        withHostnames(hostnames): { hostnames: if std.isArray(v=hostnames) then hostnames else [hostnames] },
        '#withHostnamesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='hostnames', type=d.T.array)]),
        withHostnamesMixin(hostnames): { hostnames+: if std.isArray(v=hostnames) then hostnames else [hostnames] },
        '#withIp':: d.fn(help='', args=[d.arg(name='ip', type=d.T.string)]),
        withIp(ip): { ip: ip },
      },
      '#imagePullSecrets':: d.obj(help='"references to secrets with credentials for pulling the images from registry"'),
      imagePullSecrets: {
        '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { name: name },
      },
      '#resourceClaims':: d.obj(help=''),
      resourceClaims: {
        '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { name: name },
        '#withResourceClaimName':: d.fn(help='', args=[d.arg(name='resourceClaimName', type=d.T.string)]),
        withResourceClaimName(resourceClaimName): { resourceClaimName: resourceClaimName },
        '#withResourceClaimTemplateName':: d.fn(help='', args=[d.arg(name='resourceClaimTemplateName', type=d.T.string)]),
        withResourceClaimTemplateName(resourceClaimTemplateName): { resourceClaimTemplateName: resourceClaimTemplateName },
      },
      '#schedulingGates':: d.obj(help=''),
      schedulingGates: {
        '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { name: name },
      },
      '#securityContext':: d.obj(help=''),
      securityContext: {
        '#appArmorProfile':: d.obj(help=''),
        appArmorProfile: {
          '#withLocalhostProfile':: d.fn(help='', args=[d.arg(name='localhostProfile', type=d.T.string)]),
          withLocalhostProfile(localhostProfile): { spec+: { pod+: { securityContext+: { appArmorProfile+: { localhostProfile: localhostProfile } } } } },
          '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
          withType(type): { spec+: { pod+: { securityContext+: { appArmorProfile+: { type: type } } } } },
        },
        '#seLinuxOptions':: d.obj(help=''),
        seLinuxOptions: {
          '#withLevel':: d.fn(help='', args=[d.arg(name='level', type=d.T.string)]),
          withLevel(level): { spec+: { pod+: { securityContext+: { seLinuxOptions+: { level: level } } } } },
          '#withRole':: d.fn(help='', args=[d.arg(name='role', type=d.T.string)]),
          withRole(role): { spec+: { pod+: { securityContext+: { seLinuxOptions+: { role: role } } } } },
          '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
          withType(type): { spec+: { pod+: { securityContext+: { seLinuxOptions+: { type: type } } } } },
          '#withUser':: d.fn(help='', args=[d.arg(name='user', type=d.T.string)]),
          withUser(user): { spec+: { pod+: { securityContext+: { seLinuxOptions+: { user: user } } } } },
        },
        '#seccompProfile':: d.obj(help=''),
        seccompProfile: {
          '#withLocalhostProfile':: d.fn(help='', args=[d.arg(name='localhostProfile', type=d.T.string)]),
          withLocalhostProfile(localhostProfile): { spec+: { pod+: { securityContext+: { seccompProfile+: { localhostProfile: localhostProfile } } } } },
          '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
          withType(type): { spec+: { pod+: { securityContext+: { seccompProfile+: { type: type } } } } },
        },
        '#sysctls':: d.obj(help=''),
        sysctls: {
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { name: name },
          '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#windowsOptions':: d.obj(help=''),
        windowsOptions: {
          '#withGmsaCredentialSpec':: d.fn(help='', args=[d.arg(name='gmsaCredentialSpec', type=d.T.string)]),
          withGmsaCredentialSpec(gmsaCredentialSpec): { spec+: { pod+: { securityContext+: { windowsOptions+: { gmsaCredentialSpec: gmsaCredentialSpec } } } } },
          '#withGmsaCredentialSpecName':: d.fn(help='', args=[d.arg(name='gmsaCredentialSpecName', type=d.T.string)]),
          withGmsaCredentialSpecName(gmsaCredentialSpecName): { spec+: { pod+: { securityContext+: { windowsOptions+: { gmsaCredentialSpecName: gmsaCredentialSpecName } } } } },
          '#withHostProcess':: d.fn(help='', args=[d.arg(name='hostProcess', type=d.T.boolean)]),
          withHostProcess(hostProcess): { spec+: { pod+: { securityContext+: { windowsOptions+: { hostProcess: hostProcess } } } } },
          '#withRunAsUserName':: d.fn(help='', args=[d.arg(name='runAsUserName', type=d.T.string)]),
          withRunAsUserName(runAsUserName): { spec+: { pod+: { securityContext+: { windowsOptions+: { runAsUserName: runAsUserName } } } } },
        },
        '#withFsGroup':: d.fn(help='', args=[d.arg(name='fsGroup', type=d.T.integer)]),
        withFsGroup(fsGroup): { spec+: { pod+: { securityContext+: { fsGroup: fsGroup } } } },
        '#withFsGroupChangePolicy':: d.fn(help='', args=[d.arg(name='fsGroupChangePolicy', type=d.T.string)]),
        withFsGroupChangePolicy(fsGroupChangePolicy): { spec+: { pod+: { securityContext+: { fsGroupChangePolicy: fsGroupChangePolicy } } } },
        '#withRunAsGroup':: d.fn(help='', args=[d.arg(name='runAsGroup', type=d.T.integer)]),
        withRunAsGroup(runAsGroup): { spec+: { pod+: { securityContext+: { runAsGroup: runAsGroup } } } },
        '#withRunAsNonRoot':: d.fn(help='', args=[d.arg(name='runAsNonRoot', type=d.T.boolean)]),
        withRunAsNonRoot(runAsNonRoot): { spec+: { pod+: { securityContext+: { runAsNonRoot: runAsNonRoot } } } },
        '#withRunAsUser':: d.fn(help='', args=[d.arg(name='runAsUser', type=d.T.integer)]),
        withRunAsUser(runAsUser): { spec+: { pod+: { securityContext+: { runAsUser: runAsUser } } } },
        '#withSeLinuxChangePolicy':: d.fn(help='', args=[d.arg(name='seLinuxChangePolicy', type=d.T.string)]),
        withSeLinuxChangePolicy(seLinuxChangePolicy): { spec+: { pod+: { securityContext+: { seLinuxChangePolicy: seLinuxChangePolicy } } } },
        '#withSupplementalGroups':: d.fn(help='', args=[d.arg(name='supplementalGroups', type=d.T.array)]),
        withSupplementalGroups(supplementalGroups): { spec+: { pod+: { securityContext+: { supplementalGroups: if std.isArray(v=supplementalGroups) then supplementalGroups else [supplementalGroups] } } } },
        '#withSupplementalGroupsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='supplementalGroups', type=d.T.array)]),
        withSupplementalGroupsMixin(supplementalGroups): { spec+: { pod+: { securityContext+: { supplementalGroups+: if std.isArray(v=supplementalGroups) then supplementalGroups else [supplementalGroups] } } } },
        '#withSupplementalGroupsPolicy':: d.fn(help='', args=[d.arg(name='supplementalGroupsPolicy', type=d.T.string)]),
        withSupplementalGroupsPolicy(supplementalGroupsPolicy): { spec+: { pod+: { securityContext+: { supplementalGroupsPolicy: supplementalGroupsPolicy } } } },
        '#withSysctls':: d.fn(help='', args=[d.arg(name='sysctls', type=d.T.array)]),
        withSysctls(sysctls): { spec+: { pod+: { securityContext+: { sysctls: if std.isArray(v=sysctls) then sysctls else [sysctls] } } } },
        '#withSysctlsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='sysctls', type=d.T.array)]),
        withSysctlsMixin(sysctls): { spec+: { pod+: { securityContext+: { sysctls+: if std.isArray(v=sysctls) then sysctls else [sysctls] } } } },
      },
      '#tolerations':: d.obj(help=''),
      tolerations: {
        '#withEffect':: d.fn(help='', args=[d.arg(name='effect', type=d.T.string)]),
        withEffect(effect): { effect: effect },
        '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
        withKey(key): { key: key },
        '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
        withOperator(operator): { operator: operator },
        '#withTolerationSeconds':: d.fn(help='', args=[d.arg(name='tolerationSeconds', type=d.T.integer)]),
        withTolerationSeconds(tolerationSeconds): { tolerationSeconds: tolerationSeconds },
        '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
        withValue(value): { value: value },
      },
      '#withActiveDeadlineSeconds':: d.fn(help='"duration in seconds the pod may be active on the node"', args=[d.arg(name='activeDeadlineSeconds', type=d.T.integer)]),
      withActiveDeadlineSeconds(activeDeadlineSeconds): { spec+: { pod+: { activeDeadlineSeconds: activeDeadlineSeconds } } },
      '#withAffinity':: d.fn(help='', args=[d.arg(name='affinity', type=d.T.any)]),
      withAffinity(affinity): { spec+: { pod+: { affinity: affinity } } },
      '#withAnnotations':: d.fn(help='"annotations added to the scheduled pod"', args=[d.arg(name='annotations', type=d.T.object)]),
      withAnnotations(annotations): { spec+: { pod+: { annotations: annotations } } },
      '#withAnnotationsMixin':: d.fn(help='"annotations added to the scheduled pod"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='annotations', type=d.T.object)]),
      withAnnotationsMixin(annotations): { spec+: { pod+: { annotations+: annotations } } },
      '#withDnsPolicy':: d.fn(help='', args=[d.arg(name='dnsPolicy', type=d.T.string)]),
      withDnsPolicy(dnsPolicy): { spec+: { pod+: { dnsPolicy: dnsPolicy } } },
      '#withHostAliases':: d.fn(help='', args=[d.arg(name='hostAliases', type=d.T.array)]),
      withHostAliases(hostAliases): { spec+: { pod+: { hostAliases: if std.isArray(v=hostAliases) then hostAliases else [hostAliases] } } },
      '#withHostAliasesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='hostAliases', type=d.T.array)]),
      withHostAliasesMixin(hostAliases): { spec+: { pod+: { hostAliases+: if std.isArray(v=hostAliases) then hostAliases else [hostAliases] } } },
      '#withHostname':: d.fn(help='"Specifies the hostname of the Pod"', args=[d.arg(name='hostname', type=d.T.string)]),
      withHostname(hostname): { spec+: { pod+: { hostname: hostname } } },
      '#withImagePullSecrets':: d.fn(help='"references to secrets with credentials for pulling the images from registry"', args=[d.arg(name='imagePullSecrets', type=d.T.array)]),
      withImagePullSecrets(imagePullSecrets): { spec+: { pod+: { imagePullSecrets: if std.isArray(v=imagePullSecrets) then imagePullSecrets else [imagePullSecrets] } } },
      '#withImagePullSecretsMixin':: d.fn(help='"references to secrets with credentials for pulling the images from registry"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='imagePullSecrets', type=d.T.array)]),
      withImagePullSecretsMixin(imagePullSecrets): { spec+: { pod+: { imagePullSecrets+: if std.isArray(v=imagePullSecrets) then imagePullSecrets else [imagePullSecrets] } } },
      '#withLabels':: d.fn(help='"labels added to the scheduled pod"', args=[d.arg(name='labels', type=d.T.object)]),
      withLabels(labels): { spec+: { pod+: { labels: labels } } },
      '#withLabelsMixin':: d.fn(help='"labels added to the scheduled pod"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='labels', type=d.T.object)]),
      withLabelsMixin(labels): { spec+: { pod+: { labels+: labels } } },
      '#withNodeName':: d.fn(help='"NodeName is a request to schedule this pod onto a specific node."', args=[d.arg(name='nodeName', type=d.T.string)]),
      withNodeName(nodeName): { spec+: { pod+: { nodeName: nodeName } } },
      '#withNodeSelector':: d.fn(help='"node selector to define on which node the pod should land"', args=[d.arg(name='nodeSelector', type=d.T.object)]),
      withNodeSelector(nodeSelector): { spec+: { pod+: { nodeSelector: nodeSelector } } },
      '#withNodeSelectorMixin':: d.fn(help='"node selector to define on which node the pod should land"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='nodeSelector', type=d.T.object)]),
      withNodeSelectorMixin(nodeSelector): { spec+: { pod+: { nodeSelector+: nodeSelector } } },
      '#withPreemptionPolicy':: d.fn(help='"PreemptionPolicy is the Policy for preempting pods with lower priority."', args=[d.arg(name='preemptionPolicy', type=d.T.string)]),
      withPreemptionPolicy(preemptionPolicy): { spec+: { pod+: { preemptionPolicy: preemptionPolicy } } },
      '#withPriority':: d.fn(help='"The priority value. Various system components use this field to find the priority of the pod."', args=[d.arg(name='priority', type=d.T.integer)]),
      withPriority(priority): { spec+: { pod+: { priority: priority } } },
      '#withPriorityClassName':: d.fn(help="\"If specified, indicates the pod's priority.\"", args=[d.arg(name='priorityClassName', type=d.T.string)]),
      withPriorityClassName(priorityClassName): { spec+: { pod+: { priorityClassName: priorityClassName } } },
      '#withResourceClaims':: d.fn(help='', args=[d.arg(name='resourceClaims', type=d.T.array)]),
      withResourceClaims(resourceClaims): { spec+: { pod+: { resourceClaims: if std.isArray(v=resourceClaims) then resourceClaims else [resourceClaims] } } },
      '#withResourceClaimsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='resourceClaims', type=d.T.array)]),
      withResourceClaimsMixin(resourceClaims): { spec+: { pod+: { resourceClaims+: if std.isArray(v=resourceClaims) then resourceClaims else [resourceClaims] } } },
      '#withSchedulingGates':: d.fn(help='', args=[d.arg(name='schedulingGates', type=d.T.array)]),
      withSchedulingGates(schedulingGates): { spec+: { pod+: { schedulingGates: if std.isArray(v=schedulingGates) then schedulingGates else [schedulingGates] } } },
      '#withSchedulingGatesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='schedulingGates', type=d.T.array)]),
      withSchedulingGatesMixin(schedulingGates): { spec+: { pod+: { schedulingGates+: if std.isArray(v=schedulingGates) then schedulingGates else [schedulingGates] } } },
      '#withServiceAccountName':: d.fn(help='"default service account name for the scheduled pod"', args=[d.arg(name='serviceAccountName', type=d.T.string)]),
      withServiceAccountName(serviceAccountName): { spec+: { pod+: { serviceAccountName: serviceAccountName } } },
      '#withSubdomain':: d.fn(help='"If specified, the fully qualified Pod hostname will be \\"<hostname>.<subdomain>.<pod namespace>.svc.<cluster domain>\\"."', args=[d.arg(name='subdomain', type=d.T.string)]),
      withSubdomain(subdomain): { spec+: { pod+: { subdomain: subdomain } } },
      '#withTolerations':: d.fn(help='', args=[d.arg(name='tolerations', type=d.T.array)]),
      withTolerations(tolerations): { spec+: { pod+: { tolerations: if std.isArray(v=tolerations) then tolerations else [tolerations] } } },
      '#withTolerationsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='tolerations', type=d.T.array)]),
      withTolerationsMixin(tolerations): { spec+: { pod+: { tolerations+: if std.isArray(v=tolerations) then tolerations else [tolerations] } } },
      '#withTopologySpreadConstraints':: d.fn(help='', args=[d.arg(name='topologySpreadConstraints', type=d.T.any)]),
      withTopologySpreadConstraints(topologySpreadConstraints): { spec+: { pod+: { topologySpreadConstraints: topologySpreadConstraints } } },
      '#withVolumes':: d.fn(help='', args=[d.arg(name='volumes', type=d.T.any)]),
      withVolumes(volumes): { spec+: { pod+: { volumes: volumes } } },
    },
    '#setup':: d.obj(help='"steps for setting up the workflow"'),
    setup: {
      '#artifacts':: d.obj(help='"scrape artifacts from the volumes"'),
      artifacts: {
        '#compress':: d.obj(help='"compression options for the artifacts"'),
        compress: {
          '#withName':: d.fn(help='"artifact name"', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { artifacts+: { compress+: { name: name } } },
        },
        '#withPaths':: d.fn(help='"paths to fetch from the container"', args=[d.arg(name='paths', type=d.T.array)]),
        withPaths(paths): { artifacts+: { paths: if std.isArray(v=paths) then paths else [paths] } },
        '#withPathsMixin':: d.fn(help='"paths to fetch from the container"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='paths', type=d.T.array)]),
        withPathsMixin(paths): { artifacts+: { paths+: if std.isArray(v=paths) then paths else [paths] } },
        '#withWorkingDir':: d.fn(help='"working directory to override, so it will be used as a base dir"', args=[d.arg(name='workingDir', type=d.T.string)]),
        withWorkingDir(workingDir): { artifacts+: { workingDir: workingDir } },
      },
      '#container':: d.obj(help='"defaults for the containers in this step"'),
      container: {
        '#env':: d.obj(help=''),
        env: {
          '#valueFrom':: d.obj(help=''),
          valueFrom: {
            '#configMapKeyRef':: d.obj(help=''),
            configMapKeyRef: {
              '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { valueFrom+: { configMapKeyRef+: { key: key } } },
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { valueFrom+: { configMapKeyRef+: { name: name } } },
              '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { valueFrom+: { configMapKeyRef+: { optional: optional } } },
            },
            '#fieldRef':: d.obj(help=''),
            fieldRef: {
              '#withApiVersion':: d.fn(help='', args=[d.arg(name='apiVersion', type=d.T.string)]),
              withApiVersion(apiVersion): { valueFrom+: { fieldRef+: { apiVersion: apiVersion } } },
              '#withFieldPath':: d.fn(help='', args=[d.arg(name='fieldPath', type=d.T.string)]),
              withFieldPath(fieldPath): { valueFrom+: { fieldRef+: { fieldPath: fieldPath } } },
            },
            '#resourceFieldRef':: d.obj(help=''),
            resourceFieldRef: {
              '#withContainerName':: d.fn(help='', args=[d.arg(name='containerName', type=d.T.string)]),
              withContainerName(containerName): { valueFrom+: { resourceFieldRef+: { containerName: containerName } } },
              '#withDivisor':: d.fn(help='', args=[d.arg(name='divisor', type=d.T.any)]),
              withDivisor(divisor): { valueFrom+: { resourceFieldRef+: { divisor: divisor } } },
              '#withResource':: d.fn(help='', args=[d.arg(name='resource', type=d.T.string)]),
              withResource(resource): { valueFrom+: { resourceFieldRef+: { resource: resource } } },
            },
            '#secretKeyRef':: d.obj(help=''),
            secretKeyRef: {
              '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { valueFrom+: { secretKeyRef+: { key: key } } },
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { valueFrom+: { secretKeyRef+: { name: name } } },
              '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { valueFrom+: { secretKeyRef+: { optional: optional } } },
            },
          },
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { name: name },
          '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#envFrom':: d.obj(help=''),
        envFrom: {
          '#configMapRef':: d.obj(help=''),
          configMapRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { configMapRef+: { name: name } },
            '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { configMapRef+: { optional: optional } },
          },
          '#secretRef':: d.obj(help=''),
          secretRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { secretRef+: { name: name } },
            '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { secretRef+: { optional: optional } },
          },
          '#withPrefix':: d.fn(help='', args=[d.arg(name='prefix', type=d.T.string)]),
          withPrefix(prefix): { prefix: prefix },
        },
        '#resources':: d.obj(help='"expected resources for the container"'),
        resources: {
          '#withLimits':: d.fn(help='"resource limits for the container"', args=[d.arg(name='limits', type=d.T.object)]),
          withLimits(limits): { container+: { resources+: { limits: limits } } },
          '#withLimitsMixin':: d.fn(help='"resource limits for the container"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='limits', type=d.T.object)]),
          withLimitsMixin(limits): { container+: { resources+: { limits+: limits } } },
          '#withRequests':: d.fn(help='"resource requests for the container"', args=[d.arg(name='requests', type=d.T.object)]),
          withRequests(requests): { container+: { resources+: { requests: requests } } },
          '#withRequestsMixin':: d.fn(help='"resource requests for the container"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requests', type=d.T.object)]),
          withRequestsMixin(requests): { container+: { resources+: { requests+: requests } } },
        },
        '#securityContext':: d.obj(help=''),
        securityContext: {
          '#appArmorProfile':: d.obj(help=''),
          appArmorProfile: {
            '#withLocalhostProfile':: d.fn(help='', args=[d.arg(name='localhostProfile', type=d.T.string)]),
            withLocalhostProfile(localhostProfile): { container+: { securityContext+: { appArmorProfile+: { localhostProfile: localhostProfile } } } },
            '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
            withType(type): { container+: { securityContext+: { appArmorProfile+: { type: type } } } },
          },
          '#capabilities':: d.obj(help=''),
          capabilities: {
            '#withAdd':: d.fn(help='', args=[d.arg(name='add', type=d.T.array)]),
            withAdd(add): { container+: { securityContext+: { capabilities+: { add: if std.isArray(v=add) then add else [add] } } } },
            '#withAddMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='add', type=d.T.array)]),
            withAddMixin(add): { container+: { securityContext+: { capabilities+: { add+: if std.isArray(v=add) then add else [add] } } } },
            '#withDrop':: d.fn(help='', args=[d.arg(name='drop', type=d.T.array)]),
            withDrop(drop): { container+: { securityContext+: { capabilities+: { drop: if std.isArray(v=drop) then drop else [drop] } } } },
            '#withDropMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='drop', type=d.T.array)]),
            withDropMixin(drop): { container+: { securityContext+: { capabilities+: { drop+: if std.isArray(v=drop) then drop else [drop] } } } },
          },
          '#seLinuxOptions':: d.obj(help=''),
          seLinuxOptions: {
            '#withLevel':: d.fn(help='', args=[d.arg(name='level', type=d.T.string)]),
            withLevel(level): { container+: { securityContext+: { seLinuxOptions+: { level: level } } } },
            '#withRole':: d.fn(help='', args=[d.arg(name='role', type=d.T.string)]),
            withRole(role): { container+: { securityContext+: { seLinuxOptions+: { role: role } } } },
            '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
            withType(type): { container+: { securityContext+: { seLinuxOptions+: { type: type } } } },
            '#withUser':: d.fn(help='', args=[d.arg(name='user', type=d.T.string)]),
            withUser(user): { container+: { securityContext+: { seLinuxOptions+: { user: user } } } },
          },
          '#seccompProfile':: d.obj(help=''),
          seccompProfile: {
            '#withLocalhostProfile':: d.fn(help='', args=[d.arg(name='localhostProfile', type=d.T.string)]),
            withLocalhostProfile(localhostProfile): { container+: { securityContext+: { seccompProfile+: { localhostProfile: localhostProfile } } } },
            '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
            withType(type): { container+: { securityContext+: { seccompProfile+: { type: type } } } },
          },
          '#windowsOptions':: d.obj(help=''),
          windowsOptions: {
            '#withGmsaCredentialSpec':: d.fn(help='', args=[d.arg(name='gmsaCredentialSpec', type=d.T.string)]),
            withGmsaCredentialSpec(gmsaCredentialSpec): { container+: { securityContext+: { windowsOptions+: { gmsaCredentialSpec: gmsaCredentialSpec } } } },
            '#withGmsaCredentialSpecName':: d.fn(help='', args=[d.arg(name='gmsaCredentialSpecName', type=d.T.string)]),
            withGmsaCredentialSpecName(gmsaCredentialSpecName): { container+: { securityContext+: { windowsOptions+: { gmsaCredentialSpecName: gmsaCredentialSpecName } } } },
            '#withHostProcess':: d.fn(help='', args=[d.arg(name='hostProcess', type=d.T.boolean)]),
            withHostProcess(hostProcess): { container+: { securityContext+: { windowsOptions+: { hostProcess: hostProcess } } } },
            '#withRunAsUserName':: d.fn(help='', args=[d.arg(name='runAsUserName', type=d.T.string)]),
            withRunAsUserName(runAsUserName): { container+: { securityContext+: { windowsOptions+: { runAsUserName: runAsUserName } } } },
          },
          '#withAllowPrivilegeEscalation':: d.fn(help='', args=[d.arg(name='allowPrivilegeEscalation', type=d.T.boolean)]),
          withAllowPrivilegeEscalation(allowPrivilegeEscalation): { container+: { securityContext+: { allowPrivilegeEscalation: allowPrivilegeEscalation } } },
          '#withPrivileged':: d.fn(help='', args=[d.arg(name='privileged', type=d.T.boolean)]),
          withPrivileged(privileged): { container+: { securityContext+: { privileged: privileged } } },
          '#withProcMount':: d.fn(help='', args=[d.arg(name='procMount', type=d.T.string)]),
          withProcMount(procMount): { container+: { securityContext+: { procMount: procMount } } },
          '#withReadOnlyRootFilesystem':: d.fn(help='', args=[d.arg(name='readOnlyRootFilesystem', type=d.T.boolean)]),
          withReadOnlyRootFilesystem(readOnlyRootFilesystem): { container+: { securityContext+: { readOnlyRootFilesystem: readOnlyRootFilesystem } } },
          '#withRunAsGroup':: d.fn(help='', args=[d.arg(name='runAsGroup', type=d.T.integer)]),
          withRunAsGroup(runAsGroup): { container+: { securityContext+: { runAsGroup: runAsGroup } } },
          '#withRunAsNonRoot':: d.fn(help='', args=[d.arg(name='runAsNonRoot', type=d.T.boolean)]),
          withRunAsNonRoot(runAsNonRoot): { container+: { securityContext+: { runAsNonRoot: runAsNonRoot } } },
          '#withRunAsUser':: d.fn(help='', args=[d.arg(name='runAsUser', type=d.T.integer)]),
          withRunAsUser(runAsUser): { container+: { securityContext+: { runAsUser: runAsUser } } },
        },
        '#volumeMounts':: d.obj(help=''),
        volumeMounts: {
          '#withMountPath':: d.fn(help='', args=[d.arg(name='mountPath', type=d.T.string)]),
          withMountPath(mountPath): { mountPath: mountPath },
          '#withMountPropagation':: d.fn(help='', args=[d.arg(name='mountPropagation', type=d.T.string)]),
          withMountPropagation(mountPropagation): { mountPropagation: mountPropagation },
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { name: name },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { readOnly: readOnly },
          '#withRecursiveReadOnly':: d.fn(help='', args=[d.arg(name='recursiveReadOnly', type=d.T.string)]),
          withRecursiveReadOnly(recursiveReadOnly): { recursiveReadOnly: recursiveReadOnly },
          '#withSubPath':: d.fn(help='', args=[d.arg(name='subPath', type=d.T.string)]),
          withSubPath(subPath): { subPath: subPath },
          '#withSubPathExpr':: d.fn(help='', args=[d.arg(name='subPathExpr', type=d.T.string)]),
          withSubPathExpr(subPathExpr): { subPathExpr: subPathExpr },
        },
        '#withArgs':: d.fn(help='"override default command in the image (empty string to default CMD of the image)"', args=[d.arg(name='args', type=d.T.array)]),
        withArgs(args): { container+: { args: if std.isArray(v=args) then args else [args] } },
        '#withArgsMixin':: d.fn(help='"override default command in the image (empty string to default CMD of the image)"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='args', type=d.T.array)]),
        withArgsMixin(args): { container+: { args+: if std.isArray(v=args) then args else [args] } },
        '#withCommand':: d.fn(help='"override default command in the image (empty string to default ENTRYPOINT of the image)"', args=[d.arg(name='command', type=d.T.array)]),
        withCommand(command): { container+: { command: if std.isArray(v=command) then command else [command] } },
        '#withCommandMixin':: d.fn(help='"override default command in the image (empty string to default ENTRYPOINT of the image)"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='command', type=d.T.array)]),
        withCommandMixin(command): { container+: { command+: if std.isArray(v=command) then command else [command] } },
        '#withEnv':: d.fn(help='', args=[d.arg(name='env', type=d.T.array)]),
        withEnv(env): { container+: { env: if std.isArray(v=env) then env else [env] } },
        '#withEnvFrom':: d.fn(help='', args=[d.arg(name='envFrom', type=d.T.array)]),
        withEnvFrom(envFrom): { container+: { envFrom: if std.isArray(v=envFrom) then envFrom else [envFrom] } },
        '#withEnvFromMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='envFrom', type=d.T.array)]),
        withEnvFromMixin(envFrom): { container+: { envFrom+: if std.isArray(v=envFrom) then envFrom else [envFrom] } },
        '#withEnvMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='env', type=d.T.array)]),
        withEnvMixin(env): { container+: { env+: if std.isArray(v=env) then env else [env] } },
        '#withImage':: d.fn(help='"image to be used for the container"', args=[d.arg(name='image', type=d.T.string)]),
        withImage(image): { container+: { image: image } },
        '#withImagePullPolicy':: d.fn(help='"pulling policy for the image"', args=[d.arg(name='imagePullPolicy', type=d.T.string)]),
        withImagePullPolicy(imagePullPolicy): { container+: { imagePullPolicy: imagePullPolicy } },
        '#withVolumeMounts':: d.fn(help='', args=[d.arg(name='volumeMounts', type=d.T.array)]),
        withVolumeMounts(volumeMounts): { container+: { volumeMounts: if std.isArray(v=volumeMounts) then volumeMounts else [volumeMounts] } },
        '#withVolumeMountsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='volumeMounts', type=d.T.array)]),
        withVolumeMountsMixin(volumeMounts): { container+: { volumeMounts+: if std.isArray(v=volumeMounts) then volumeMounts else [volumeMounts] } },
        '#withWorkingDir':: d.fn(help='"override default working directory in the image (empty string to default WORKDIR for the image)"', args=[d.arg(name='workingDir', type=d.T.string)]),
        withWorkingDir(workingDir): { container+: { workingDir: workingDir } },
      },
      '#content':: d.obj(help='"content that should be fetched for this step"'),
      content: {
        '#files':: d.obj(help='"files to load"'),
        files: {
          '#contentFrom':: d.obj(help='"external source to use"'),
          contentFrom: {
            '#configMapKeyRef':: d.obj(help=''),
            configMapKeyRef: {
              '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { contentFrom+: { configMapKeyRef+: { key: key } } },
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { contentFrom+: { configMapKeyRef+: { name: name } } },
              '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { contentFrom+: { configMapKeyRef+: { optional: optional } } },
            },
            '#fieldRef':: d.obj(help=''),
            fieldRef: {
              '#withApiVersion':: d.fn(help='', args=[d.arg(name='apiVersion', type=d.T.string)]),
              withApiVersion(apiVersion): { contentFrom+: { fieldRef+: { apiVersion: apiVersion } } },
              '#withFieldPath':: d.fn(help='', args=[d.arg(name='fieldPath', type=d.T.string)]),
              withFieldPath(fieldPath): { contentFrom+: { fieldRef+: { fieldPath: fieldPath } } },
            },
            '#resourceFieldRef':: d.obj(help=''),
            resourceFieldRef: {
              '#withContainerName':: d.fn(help='', args=[d.arg(name='containerName', type=d.T.string)]),
              withContainerName(containerName): { contentFrom+: { resourceFieldRef+: { containerName: containerName } } },
              '#withDivisor':: d.fn(help='', args=[d.arg(name='divisor', type=d.T.any)]),
              withDivisor(divisor): { contentFrom+: { resourceFieldRef+: { divisor: divisor } } },
              '#withResource':: d.fn(help='', args=[d.arg(name='resource', type=d.T.string)]),
              withResource(resource): { contentFrom+: { resourceFieldRef+: { resource: resource } } },
            },
            '#secretKeyRef':: d.obj(help=''),
            secretKeyRef: {
              '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { contentFrom+: { secretKeyRef+: { key: key } } },
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { contentFrom+: { secretKeyRef+: { name: name } } },
              '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { contentFrom+: { secretKeyRef+: { optional: optional } } },
            },
          },
          '#withContent':: d.fn(help='"plain-text content to put inside"', args=[d.arg(name='content', type=d.T.string)]),
          withContent(content): { content: content },
          '#withMode':: d.fn(help='"mode to use for the file"', args=[d.arg(name='mode', type=d.T.integer)]),
          withMode(mode): { mode: mode },
          '#withPath':: d.fn(help='"path where the file should be accessible at"', args=[d.arg(name='path', type=d.T.string)]),
          withPath(path): { path: path },
        },
        '#git':: d.obj(help='"git repository details"'),
        git: {
          '#sshKeyFrom':: d.obj(help='"external SSH private key to fetch with"'),
          sshKeyFrom: {
            '#configMapKeyRef':: d.obj(help=''),
            configMapKeyRef: {
              '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { content+: { git+: { sshKeyFrom+: { configMapKeyRef+: { key: key } } } } },
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { content+: { git+: { sshKeyFrom+: { configMapKeyRef+: { name: name } } } } },
              '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { content+: { git+: { sshKeyFrom+: { configMapKeyRef+: { optional: optional } } } } },
            },
            '#fieldRef':: d.obj(help=''),
            fieldRef: {
              '#withApiVersion':: d.fn(help='', args=[d.arg(name='apiVersion', type=d.T.string)]),
              withApiVersion(apiVersion): { content+: { git+: { sshKeyFrom+: { fieldRef+: { apiVersion: apiVersion } } } } },
              '#withFieldPath':: d.fn(help='', args=[d.arg(name='fieldPath', type=d.T.string)]),
              withFieldPath(fieldPath): { content+: { git+: { sshKeyFrom+: { fieldRef+: { fieldPath: fieldPath } } } } },
            },
            '#resourceFieldRef':: d.obj(help=''),
            resourceFieldRef: {
              '#withContainerName':: d.fn(help='', args=[d.arg(name='containerName', type=d.T.string)]),
              withContainerName(containerName): { content+: { git+: { sshKeyFrom+: { resourceFieldRef+: { containerName: containerName } } } } },
              '#withDivisor':: d.fn(help='', args=[d.arg(name='divisor', type=d.T.any)]),
              withDivisor(divisor): { content+: { git+: { sshKeyFrom+: { resourceFieldRef+: { divisor: divisor } } } } },
              '#withResource':: d.fn(help='', args=[d.arg(name='resource', type=d.T.string)]),
              withResource(resource): { content+: { git+: { sshKeyFrom+: { resourceFieldRef+: { resource: resource } } } } },
            },
            '#secretKeyRef':: d.obj(help=''),
            secretKeyRef: {
              '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { content+: { git+: { sshKeyFrom+: { secretKeyRef+: { key: key } } } } },
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { content+: { git+: { sshKeyFrom+: { secretKeyRef+: { name: name } } } } },
              '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { content+: { git+: { sshKeyFrom+: { secretKeyRef+: { optional: optional } } } } },
            },
          },
          '#tokenFrom':: d.obj(help='"external token to fetch with"'),
          tokenFrom: {
            '#configMapKeyRef':: d.obj(help=''),
            configMapKeyRef: {
              '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { content+: { git+: { tokenFrom+: { configMapKeyRef+: { key: key } } } } },
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { content+: { git+: { tokenFrom+: { configMapKeyRef+: { name: name } } } } },
              '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { content+: { git+: { tokenFrom+: { configMapKeyRef+: { optional: optional } } } } },
            },
            '#fieldRef':: d.obj(help=''),
            fieldRef: {
              '#withApiVersion':: d.fn(help='', args=[d.arg(name='apiVersion', type=d.T.string)]),
              withApiVersion(apiVersion): { content+: { git+: { tokenFrom+: { fieldRef+: { apiVersion: apiVersion } } } } },
              '#withFieldPath':: d.fn(help='', args=[d.arg(name='fieldPath', type=d.T.string)]),
              withFieldPath(fieldPath): { content+: { git+: { tokenFrom+: { fieldRef+: { fieldPath: fieldPath } } } } },
            },
            '#resourceFieldRef':: d.obj(help=''),
            resourceFieldRef: {
              '#withContainerName':: d.fn(help='', args=[d.arg(name='containerName', type=d.T.string)]),
              withContainerName(containerName): { content+: { git+: { tokenFrom+: { resourceFieldRef+: { containerName: containerName } } } } },
              '#withDivisor':: d.fn(help='', args=[d.arg(name='divisor', type=d.T.any)]),
              withDivisor(divisor): { content+: { git+: { tokenFrom+: { resourceFieldRef+: { divisor: divisor } } } } },
              '#withResource':: d.fn(help='', args=[d.arg(name='resource', type=d.T.string)]),
              withResource(resource): { content+: { git+: { tokenFrom+: { resourceFieldRef+: { resource: resource } } } } },
            },
            '#secretKeyRef':: d.obj(help=''),
            secretKeyRef: {
              '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { content+: { git+: { tokenFrom+: { secretKeyRef+: { key: key } } } } },
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { content+: { git+: { tokenFrom+: { secretKeyRef+: { name: name } } } } },
              '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { content+: { git+: { tokenFrom+: { secretKeyRef+: { optional: optional } } } } },
            },
          },
          '#usernameFrom':: d.obj(help='"external username to fetch with"'),
          usernameFrom: {
            '#configMapKeyRef':: d.obj(help=''),
            configMapKeyRef: {
              '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { content+: { git+: { usernameFrom+: { configMapKeyRef+: { key: key } } } } },
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { content+: { git+: { usernameFrom+: { configMapKeyRef+: { name: name } } } } },
              '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { content+: { git+: { usernameFrom+: { configMapKeyRef+: { optional: optional } } } } },
            },
            '#fieldRef':: d.obj(help=''),
            fieldRef: {
              '#withApiVersion':: d.fn(help='', args=[d.arg(name='apiVersion', type=d.T.string)]),
              withApiVersion(apiVersion): { content+: { git+: { usernameFrom+: { fieldRef+: { apiVersion: apiVersion } } } } },
              '#withFieldPath':: d.fn(help='', args=[d.arg(name='fieldPath', type=d.T.string)]),
              withFieldPath(fieldPath): { content+: { git+: { usernameFrom+: { fieldRef+: { fieldPath: fieldPath } } } } },
            },
            '#resourceFieldRef':: d.obj(help=''),
            resourceFieldRef: {
              '#withContainerName':: d.fn(help='', args=[d.arg(name='containerName', type=d.T.string)]),
              withContainerName(containerName): { content+: { git+: { usernameFrom+: { resourceFieldRef+: { containerName: containerName } } } } },
              '#withDivisor':: d.fn(help='', args=[d.arg(name='divisor', type=d.T.any)]),
              withDivisor(divisor): { content+: { git+: { usernameFrom+: { resourceFieldRef+: { divisor: divisor } } } } },
              '#withResource':: d.fn(help='', args=[d.arg(name='resource', type=d.T.string)]),
              withResource(resource): { content+: { git+: { usernameFrom+: { resourceFieldRef+: { resource: resource } } } } },
            },
            '#secretKeyRef':: d.obj(help=''),
            secretKeyRef: {
              '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { content+: { git+: { usernameFrom+: { secretKeyRef+: { key: key } } } } },
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { content+: { git+: { usernameFrom+: { secretKeyRef+: { name: name } } } } },
              '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { content+: { git+: { usernameFrom+: { secretKeyRef+: { optional: optional } } } } },
            },
          },
          '#withAuthType':: d.fn(help='"authorization type for the credentials"', args=[d.arg(name='authType', type=d.T.string)]),
          withAuthType(authType): { content+: { git+: { authType: authType } } },
          '#withCone':: d.fn(help='"enable cone mode for sparse checkout with paths"', args=[d.arg(name='cone', type=d.T.boolean)]),
          withCone(cone): { content+: { git+: { cone: cone } } },
          '#withMountPath':: d.fn(help='"where to mount the fetched repository contents (defaults to \\"repo\\" directory in the data volume)"', args=[d.arg(name='mountPath', type=d.T.string)]),
          withMountPath(mountPath): { content+: { git+: { mountPath: mountPath } } },
          '#withPaths':: d.fn(help='"paths to fetch for the sparse checkout"', args=[d.arg(name='paths', type=d.T.array)]),
          withPaths(paths): { content+: { git+: { paths: if std.isArray(v=paths) then paths else [paths] } } },
          '#withPathsMixin':: d.fn(help='"paths to fetch for the sparse checkout"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='paths', type=d.T.array)]),
          withPathsMixin(paths): { content+: { git+: { paths+: if std.isArray(v=paths) then paths else [paths] } } },
          '#withRevision':: d.fn(help='"branch, commit or a tag name to fetch"', args=[d.arg(name='revision', type=d.T.string)]),
          withRevision(revision): { content+: { git+: { revision: revision } } },
          '#withSshKey':: d.fn(help='"plain text SSH private key to fetch with"', args=[d.arg(name='sshKey', type=d.T.string)]),
          withSshKey(sshKey): { content+: { git+: { sshKey: sshKey } } },
          '#withToken':: d.fn(help='"plain text token to fetch with"', args=[d.arg(name='token', type=d.T.string)]),
          withToken(token): { content+: { git+: { token: token } } },
          '#withUri':: d.fn(help='"uri for the Git repository"', args=[d.arg(name='uri', type=d.T.string)]),
          withUri(uri): { content+: { git+: { uri: uri } } },
          '#withUsername':: d.fn(help='"plain text username to fetch with"', args=[d.arg(name='username', type=d.T.string)]),
          withUsername(username): { content+: { git+: { username: username } } },
        },
        '#tarball':: d.obj(help='"tarballs to unpack"'),
        tarball: {
          '#withMount':: d.fn(help='"should it mount a new volume there"', args=[d.arg(name='mount', type=d.T.boolean)]),
          withMount(mount): { mount: mount },
          '#withPath':: d.fn(help='"path where the tarball should be extracted"', args=[d.arg(name='path', type=d.T.string)]),
          withPath(path): { path: path },
          '#withUrl':: d.fn(help='"url for the tarball to extract"', args=[d.arg(name='url', type=d.T.string)]),
          withUrl(url): { url: url },
        },
        '#withFiles':: d.fn(help='"files to load"', args=[d.arg(name='files', type=d.T.array)]),
        withFiles(files): { content+: { files: if std.isArray(v=files) then files else [files] } },
        '#withFilesMixin':: d.fn(help='"files to load"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='files', type=d.T.array)]),
        withFilesMixin(files): { content+: { files+: if std.isArray(v=files) then files else [files] } },
        '#withTarball':: d.fn(help='"tarballs to unpack"', args=[d.arg(name='tarball', type=d.T.array)]),
        withTarball(tarball): { content+: { tarball: if std.isArray(v=tarball) then tarball else [tarball] } },
        '#withTarballMixin':: d.fn(help='"tarballs to unpack"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='tarball', type=d.T.array)]),
        withTarballMixin(tarball): { content+: { tarball+: if std.isArray(v=tarball) then tarball else [tarball] } },
      },
      '#execute':: d.obj(help='"execute other Testkube resources"'),
      execute: {
        '#tests':: d.obj(help='"tests to run"'),
        tests: {
          '#executionRequest':: d.obj(help='"pass the execution request overrides"'),
          executionRequest: {
            '#artifactRequest':: d.obj(help='"artifact request body with test artifacts"'),
            artifactRequest: {
              '#withDirs':: d.fn(help='"artifact directories for scraping"', args=[d.arg(name='dirs', type=d.T.array)]),
              withDirs(dirs): { executionRequest+: { artifactRequest+: { dirs: if std.isArray(v=dirs) then dirs else [dirs] } } },
              '#withDirsMixin':: d.fn(help='"artifact directories for scraping"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='dirs', type=d.T.array)]),
              withDirsMixin(dirs): { executionRequest+: { artifactRequest+: { dirs+: if std.isArray(v=dirs) then dirs else [dirs] } } },
              '#withMasks':: d.fn(help='"regexp to filter scraped artifacts, single or comma separated"', args=[d.arg(name='masks', type=d.T.array)]),
              withMasks(masks): { executionRequest+: { artifactRequest+: { masks: if std.isArray(v=masks) then masks else [masks] } } },
              '#withMasksMixin':: d.fn(help='"regexp to filter scraped artifacts, single or comma separated"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='masks', type=d.T.array)]),
              withMasksMixin(masks): { executionRequest+: { artifactRequest+: { masks+: if std.isArray(v=masks) then masks else [masks] } } },
              '#withOmitFolderPerExecution':: d.fn(help="\"don't use a separate folder for execution artifacts\"", args=[d.arg(name='omitFolderPerExecution', type=d.T.boolean)]),
              withOmitFolderPerExecution(omitFolderPerExecution): { executionRequest+: { artifactRequest+: { omitFolderPerExecution: omitFolderPerExecution } } },
              '#withSharedBetweenPods':: d.fn(help='"whether to share volume between pods"', args=[d.arg(name='sharedBetweenPods', type=d.T.boolean)]),
              withSharedBetweenPods(sharedBetweenPods): { executionRequest+: { artifactRequest+: { sharedBetweenPods: sharedBetweenPods } } },
              '#withSidecarScraper':: d.fn(help='"run scraper as pod sidecar container"', args=[d.arg(name='sidecarScraper', type=d.T.boolean)]),
              withSidecarScraper(sidecarScraper): { executionRequest+: { artifactRequest+: { sidecarScraper: sidecarScraper } } },
              '#withStorageBucket':: d.fn(help='"artifact bucket storage"', args=[d.arg(name='storageBucket', type=d.T.string)]),
              withStorageBucket(storageBucket): { executionRequest+: { artifactRequest+: { storageBucket: storageBucket } } },
              '#withStorageClassName':: d.fn(help='"artifact storage class name for container executor"', args=[d.arg(name='storageClassName', type=d.T.string)]),
              withStorageClassName(storageClassName): { executionRequest+: { artifactRequest+: { storageClassName: storageClassName } } },
              '#withUseDefaultStorageClassName':: d.fn(help='"whether to use default storage class name"', args=[d.arg(name='useDefaultStorageClassName', type=d.T.boolean)]),
              withUseDefaultStorageClassName(useDefaultStorageClassName): { executionRequest+: { artifactRequest+: { useDefaultStorageClassName: useDefaultStorageClassName } } },
              '#withVolumeMountPath':: d.fn(help='"artifact volume mount path for container executor"', args=[d.arg(name='volumeMountPath', type=d.T.string)]),
              withVolumeMountPath(volumeMountPath): { executionRequest+: { artifactRequest+: { volumeMountPath: volumeMountPath } } },
            },
            '#envConfigMaps':: d.obj(help='"config map references"'),
            envConfigMaps: {
              '#reference':: d.obj(help='"LocalObjectReference contains enough information to let you locate the\\nreferenced object inside the same namespace."'),
              reference: {
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { reference+: { name: name } },
              },
              '#withMapToVariables':: d.fn(help='"whether we shoud map to variables from resource"', args=[d.arg(name='mapToVariables', type=d.T.boolean)]),
              withMapToVariables(mapToVariables): { mapToVariables: mapToVariables },
              '#withMount':: d.fn(help='"whether we shoud mount resource"', args=[d.arg(name='mount', type=d.T.boolean)]),
              withMount(mount): { mount: mount },
              '#withMountPath':: d.fn(help='"where we shoud mount resource"', args=[d.arg(name='mountPath', type=d.T.string)]),
              withMountPath(mountPath): { mountPath: mountPath },
            },
            '#envSecrets':: d.obj(help='"secret references"'),
            envSecrets: {
              '#reference':: d.obj(help='"LocalObjectReference contains enough information to let you locate the\\nreferenced object inside the same namespace."'),
              reference: {
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { reference+: { name: name } },
              },
              '#withMapToVariables':: d.fn(help='"whether we shoud map to variables from resource"', args=[d.arg(name='mapToVariables', type=d.T.boolean)]),
              withMapToVariables(mapToVariables): { mapToVariables: mapToVariables },
              '#withMount':: d.fn(help='"whether we shoud mount resource"', args=[d.arg(name='mount', type=d.T.boolean)]),
              withMount(mount): { mount: mount },
              '#withMountPath':: d.fn(help='"where we shoud mount resource"', args=[d.arg(name='mountPath', type=d.T.string)]),
              withMountPath(mountPath): { mountPath: mountPath },
            },
            '#imagePullSecrets':: d.obj(help='"container executor image pull secrets"'),
            imagePullSecrets: {
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { name: name },
            },
            '#withActiveDeadlineSeconds':: d.fn(help='"Optional duration in seconds the pod may be active on the node relative to\\nStartTime before the system will actively try to mark it failed and kill associated containers.\\nValue must be a positive integer."', args=[d.arg(name='activeDeadlineSeconds', type=d.T.integer)]),
            withActiveDeadlineSeconds(activeDeadlineSeconds): { executionRequest+: { activeDeadlineSeconds: activeDeadlineSeconds } },
            '#withArgs':: d.fn(help='"additional executor binary arguments"', args=[d.arg(name='args', type=d.T.array)]),
            withArgs(args): { executionRequest+: { args: if std.isArray(v=args) then args else [args] } },
            '#withArgsMixin':: d.fn(help='"additional executor binary arguments"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='args', type=d.T.array)]),
            withArgsMixin(args): { executionRequest+: { args+: if std.isArray(v=args) then args else [args] } },
            '#withArgsMode':: d.fn(help='"usage mode for arguments"', args=[d.arg(name='argsMode', type=d.T.string)]),
            withArgsMode(argsMode): { executionRequest+: { argsMode: argsMode } },
            '#withCommand':: d.fn(help='"executor binary command"', args=[d.arg(name='command', type=d.T.array)]),
            withCommand(command): { executionRequest+: { command: if std.isArray(v=command) then command else [command] } },
            '#withCommandMixin':: d.fn(help='"executor binary command"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='command', type=d.T.array)]),
            withCommandMixin(command): { executionRequest+: { command+: if std.isArray(v=command) then command else [command] } },
            '#withCronJobTemplate':: d.fn(help='"cron job template extensions"', args=[d.arg(name='cronJobTemplate', type=d.T.string)]),
            withCronJobTemplate(cronJobTemplate): { executionRequest+: { cronJobTemplate: cronJobTemplate } },
            '#withEnvConfigMaps':: d.fn(help='"config map references"', args=[d.arg(name='envConfigMaps', type=d.T.array)]),
            withEnvConfigMaps(envConfigMaps): { executionRequest+: { envConfigMaps: if std.isArray(v=envConfigMaps) then envConfigMaps else [envConfigMaps] } },
            '#withEnvConfigMapsMixin':: d.fn(help='"config map references"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='envConfigMaps', type=d.T.array)]),
            withEnvConfigMapsMixin(envConfigMaps): { executionRequest+: { envConfigMaps+: if std.isArray(v=envConfigMaps) then envConfigMaps else [envConfigMaps] } },
            '#withEnvSecrets':: d.fn(help='"secret references"', args=[d.arg(name='envSecrets', type=d.T.array)]),
            withEnvSecrets(envSecrets): { executionRequest+: { envSecrets: if std.isArray(v=envSecrets) then envSecrets else [envSecrets] } },
            '#withEnvSecretsMixin':: d.fn(help='"secret references"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='envSecrets', type=d.T.array)]),
            withEnvSecretsMixin(envSecrets): { executionRequest+: { envSecrets+: if std.isArray(v=envSecrets) then envSecrets else [envSecrets] } },
            '#withExecutePostRunScriptBeforeScraping':: d.fn(help='"execute post run script before scraping (prebuilt executor only)"', args=[d.arg(name='executePostRunScriptBeforeScraping', type=d.T.boolean)]),
            withExecutePostRunScriptBeforeScraping(executePostRunScriptBeforeScraping): { executionRequest+: { executePostRunScriptBeforeScraping: executePostRunScriptBeforeScraping } },
            '#withExecutionLabels':: d.fn(help='"test execution labels"', args=[d.arg(name='executionLabels', type=d.T.object)]),
            withExecutionLabels(executionLabels): { executionRequest+: { executionLabels: executionLabels } },
            '#withExecutionLabelsMixin':: d.fn(help='"test execution labels"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='executionLabels', type=d.T.object)]),
            withExecutionLabelsMixin(executionLabels): { executionRequest+: { executionLabels+: executionLabels } },
            '#withExecutionNamespace':: d.fn(help='"namespace for test execution (Pro edition only)"', args=[d.arg(name='executionNamespace', type=d.T.string)]),
            withExecutionNamespace(executionNamespace): { executionRequest+: { executionNamespace: executionNamespace } },
            '#withHttpProxy':: d.fn(help='"http proxy for executor containers"', args=[d.arg(name='httpProxy', type=d.T.string)]),
            withHttpProxy(httpProxy): { executionRequest+: { httpProxy: httpProxy } },
            '#withHttpsProxy':: d.fn(help='"https proxy for executor containers"', args=[d.arg(name='httpsProxy', type=d.T.string)]),
            withHttpsProxy(httpsProxy): { executionRequest+: { httpsProxy: httpsProxy } },
            '#withImage':: d.fn(help='"container executor image"', args=[d.arg(name='image', type=d.T.string)]),
            withImage(image): { executionRequest+: { image: image } },
            '#withImagePullSecrets':: d.fn(help='"container executor image pull secrets"', args=[d.arg(name='imagePullSecrets', type=d.T.array)]),
            withImagePullSecrets(imagePullSecrets): { executionRequest+: { imagePullSecrets: if std.isArray(v=imagePullSecrets) then imagePullSecrets else [imagePullSecrets] } },
            '#withImagePullSecretsMixin':: d.fn(help='"container executor image pull secrets"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='imagePullSecrets', type=d.T.array)]),
            withImagePullSecretsMixin(imagePullSecrets): { executionRequest+: { imagePullSecrets+: if std.isArray(v=imagePullSecrets) then imagePullSecrets else [imagePullSecrets] } },
            '#withIsVariablesFileUploaded':: d.fn(help='', args=[d.arg(name='isVariablesFileUploaded', type=d.T.boolean)]),
            withIsVariablesFileUploaded(isVariablesFileUploaded): { executionRequest+: { isVariablesFileUploaded: isVariablesFileUploaded } },
            '#withJobTemplate':: d.fn(help='"job template extensions"', args=[d.arg(name='jobTemplate', type=d.T.string)]),
            withJobTemplate(jobTemplate): { executionRequest+: { jobTemplate: jobTemplate } },
            '#withName':: d.fn(help='"test execution custom name"', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { executionRequest+: { name: name } },
            '#withNegativeTest':: d.fn(help='"negative test will fail the execution if it is a success and it will succeed if it is a failure"', args=[d.arg(name='negativeTest', type=d.T.boolean)]),
            withNegativeTest(negativeTest): { executionRequest+: { negativeTest: negativeTest } },
            '#withPostRunScript':: d.fn(help='"script to run after test execution"', args=[d.arg(name='postRunScript', type=d.T.string)]),
            withPostRunScript(postRunScript): { executionRequest+: { postRunScript: postRunScript } },
            '#withPreRunScript':: d.fn(help='"script to run before test execution"', args=[d.arg(name='preRunScript', type=d.T.string)]),
            withPreRunScript(preRunScript): { executionRequest+: { preRunScript: preRunScript } },
            '#withScraperTemplate':: d.fn(help='"scraper template extensions"', args=[d.arg(name='scraperTemplate', type=d.T.string)]),
            withScraperTemplate(scraperTemplate): { executionRequest+: { scraperTemplate: scraperTemplate } },
            '#withSourceScripts':: d.fn(help='"run scripts using source command (container executor only)"', args=[d.arg(name='sourceScripts', type=d.T.boolean)]),
            withSourceScripts(sourceScripts): { executionRequest+: { sourceScripts: sourceScripts } },
            '#withSync':: d.fn(help='"whether to start execution sync or async"', args=[d.arg(name='sync', type=d.T.boolean)]),
            withSync(sync): { executionRequest+: { sync: sync } },
            '#withTestSecretUUID':: d.fn(help='"test secret uuid"', args=[d.arg(name='testSecretUUID', type=d.T.string)]),
            withTestSecretUUID(testSecretUUID): { executionRequest+: { testSecretUUID: testSecretUUID } },
            '#withVariables':: d.fn(help='', args=[d.arg(name='variables', type=d.T.object)]),
            withVariables(variables): { executionRequest+: { variables: variables } },
            '#withVariablesFile':: d.fn(help='"variables file content - need to be in format for particular executor (e.g. postman envs file)"', args=[d.arg(name='variablesFile', type=d.T.string)]),
            withVariablesFile(variablesFile): { executionRequest+: { variablesFile: variablesFile } },
            '#withVariablesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='variables', type=d.T.object)]),
            withVariablesMixin(variables): { executionRequest+: { variables+: variables } },
          },
          '#withCount':: d.fn(help='"static number of sharded instances to spawn"', args=[d.arg(name='count', type=d.T.any)]),
          withCount(count): { count: count },
          '#withDescription':: d.fn(help='"test execution description to display"', args=[d.arg(name='description', type=d.T.string)]),
          withDescription(description): { description: description },
          '#withMatrix':: d.fn(help='"matrix of parameters to spawn instances (static)"', args=[d.arg(name='matrix', type=d.T.object)]),
          withMatrix(matrix): { matrix: matrix },
          '#withMatrixMixin':: d.fn(help='"matrix of parameters to spawn instances (static)"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matrix', type=d.T.object)]),
          withMatrixMixin(matrix): { matrix+: matrix },
          '#withMaxCount':: d.fn(help='"dynamic number of sharded instances to spawn - it will be lowered if there is not enough sharded values"', args=[d.arg(name='maxCount', type=d.T.any)]),
          withMaxCount(maxCount): { maxCount: maxCount },
          '#withName':: d.fn(help='"test name to run"', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { name: name },
          '#withShards':: d.fn(help='"parameters that should be distributed across sharded instances"', args=[d.arg(name='shards', type=d.T.object)]),
          withShards(shards): { shards: shards },
          '#withShardsMixin':: d.fn(help='"parameters that should be distributed across sharded instances"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='shards', type=d.T.object)]),
          withShardsMixin(shards): { shards+: shards },
          '#withTarball':: d.fn(help='"pack some data from the original file system to serve them down"', args=[d.arg(name='tarball', type=d.T.object)]),
          withTarball(tarball): { tarball: tarball },
          '#withTarballMixin':: d.fn(help='"pack some data from the original file system to serve them down"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='tarball', type=d.T.object)]),
          withTarballMixin(tarball): { tarball+: tarball },
        },
        '#withAsync':: d.fn(help="\"only schedule the resources, don't watch the results (unless it is needed for parallelism)\"", args=[d.arg(name='async', type=d.T.boolean)]),
        withAsync(async): { execute+: { async: async } },
        '#withParallelism':: d.fn(help='"how many resources could be scheduled in parallel"', args=[d.arg(name='parallelism', type=d.T.integer)]),
        withParallelism(parallelism): { execute+: { parallelism: parallelism } },
        '#withTests':: d.fn(help='"tests to run"', args=[d.arg(name='tests', type=d.T.array)]),
        withTests(tests): { execute+: { tests: if std.isArray(v=tests) then tests else [tests] } },
        '#withTestsMixin':: d.fn(help='"tests to run"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='tests', type=d.T.array)]),
        withTestsMixin(tests): { execute+: { tests+: if std.isArray(v=tests) then tests else [tests] } },
        '#withWorkflows':: d.fn(help='"workflows to run"', args=[d.arg(name='workflows', type=d.T.array)]),
        withWorkflows(workflows): { execute+: { workflows: if std.isArray(v=workflows) then workflows else [workflows] } },
        '#withWorkflowsMixin':: d.fn(help='"workflows to run"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='workflows', type=d.T.array)]),
        withWorkflowsMixin(workflows): { execute+: { workflows+: if std.isArray(v=workflows) then workflows else [workflows] } },
        '#workflows':: d.obj(help='"workflows to run"'),
        workflows: {
          '#selector':: d.obj(help='"selector is used to identify a group of test workflows based on their metadata labels"'),
          selector: {
            '#matchExpressions':: d.obj(help=''),
            matchExpressions: {
              '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { key: key },
              '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
              withOperator(operator): { operator: operator },
              '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
              withValues(values): { values: if std.isArray(v=values) then values else [values] },
              '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
              withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
            },
            '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
            withMatchExpressions(matchExpressions): { selector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
            '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
            withMatchExpressionsMixin(matchExpressions): { selector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
            '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
            withMatchLabels(matchLabels): { selector+: { matchLabels: matchLabels } },
            '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
            withMatchLabelsMixin(matchLabels): { selector+: { matchLabels+: matchLabels } },
          },
          '#withConfig':: d.fn(help='"configuration to pass for the workflow"', args=[d.arg(name='config', type=d.T.object)]),
          withConfig(config): { config: config },
          '#withConfigMixin':: d.fn(help='"configuration to pass for the workflow"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='config', type=d.T.object)]),
          withConfigMixin(config): { config+: config },
          '#withCount':: d.fn(help='"static number of sharded instances to spawn"', args=[d.arg(name='count', type=d.T.any)]),
          withCount(count): { count: count },
          '#withDescription':: d.fn(help='"test workflow execution description to display"', args=[d.arg(name='description', type=d.T.string)]),
          withDescription(description): { description: description },
          '#withExecutionName':: d.fn(help='"unique execution name to use"', args=[d.arg(name='executionName', type=d.T.string)]),
          withExecutionName(executionName): { executionName: executionName },
          '#withMatrix':: d.fn(help='"matrix of parameters to spawn instances (static)"', args=[d.arg(name='matrix', type=d.T.object)]),
          withMatrix(matrix): { matrix: matrix },
          '#withMatrixMixin':: d.fn(help='"matrix of parameters to spawn instances (static)"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matrix', type=d.T.object)]),
          withMatrixMixin(matrix): { matrix+: matrix },
          '#withMaxCount':: d.fn(help='"dynamic number of sharded instances to spawn - it will be lowered if there is not enough sharded values"', args=[d.arg(name='maxCount', type=d.T.any)]),
          withMaxCount(maxCount): { maxCount: maxCount },
          '#withName':: d.fn(help='"workflow name to run"', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { name: name },
          '#withShards':: d.fn(help='"parameters that should be distributed across sharded instances"', args=[d.arg(name='shards', type=d.T.object)]),
          withShards(shards): { shards: shards },
          '#withShardsMixin':: d.fn(help='"parameters that should be distributed across sharded instances"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='shards', type=d.T.object)]),
          withShardsMixin(shards): { shards+: shards },
          '#withTarball':: d.fn(help='"pack some data from the original file system to serve them down"', args=[d.arg(name='tarball', type=d.T.object)]),
          withTarball(tarball): { tarball: tarball },
          '#withTarballMixin':: d.fn(help='"pack some data from the original file system to serve them down"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='tarball', type=d.T.object)]),
          withTarballMixin(tarball): { tarball+: tarball },
        },
      },
      '#parallel':: d.obj(help='"instructions for parallel execution"'),
      parallel: {
        '#artifacts':: d.obj(help='"scrape artifacts from the volumes"'),
        artifacts: {
          '#compress':: d.obj(help='"compression options for the artifacts"'),
          compress: {
            '#withName':: d.fn(help='"artifact name"', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { parallel+: { artifacts+: { compress+: { name: name } } } },
          },
          '#withPaths':: d.fn(help='"paths to fetch from the container"', args=[d.arg(name='paths', type=d.T.array)]),
          withPaths(paths): { parallel+: { artifacts+: { paths: if std.isArray(v=paths) then paths else [paths] } } },
          '#withPathsMixin':: d.fn(help='"paths to fetch from the container"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='paths', type=d.T.array)]),
          withPathsMixin(paths): { parallel+: { artifacts+: { paths+: if std.isArray(v=paths) then paths else [paths] } } },
          '#withWorkingDir':: d.fn(help='"working directory to override, so it will be used as a base dir"', args=[d.arg(name='workingDir', type=d.T.string)]),
          withWorkingDir(workingDir): { parallel+: { artifacts+: { workingDir: workingDir } } },
        },
        '#execute':: d.obj(help='"execute other Testkube resources"'),
        execute: {
          '#tests':: d.obj(help='"tests to run"'),
          tests: {
            '#executionRequest':: d.obj(help='"pass the execution request overrides"'),
            executionRequest: {
              '#artifactRequest':: d.obj(help='"artifact request body with test artifacts"'),
              artifactRequest: {
                '#withDirs':: d.fn(help='"artifact directories for scraping"', args=[d.arg(name='dirs', type=d.T.array)]),
                withDirs(dirs): { executionRequest+: { artifactRequest+: { dirs: if std.isArray(v=dirs) then dirs else [dirs] } } },
                '#withDirsMixin':: d.fn(help='"artifact directories for scraping"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='dirs', type=d.T.array)]),
                withDirsMixin(dirs): { executionRequest+: { artifactRequest+: { dirs+: if std.isArray(v=dirs) then dirs else [dirs] } } },
                '#withMasks':: d.fn(help='"regexp to filter scraped artifacts, single or comma separated"', args=[d.arg(name='masks', type=d.T.array)]),
                withMasks(masks): { executionRequest+: { artifactRequest+: { masks: if std.isArray(v=masks) then masks else [masks] } } },
                '#withMasksMixin':: d.fn(help='"regexp to filter scraped artifacts, single or comma separated"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='masks', type=d.T.array)]),
                withMasksMixin(masks): { executionRequest+: { artifactRequest+: { masks+: if std.isArray(v=masks) then masks else [masks] } } },
                '#withOmitFolderPerExecution':: d.fn(help="\"don't use a separate folder for execution artifacts\"", args=[d.arg(name='omitFolderPerExecution', type=d.T.boolean)]),
                withOmitFolderPerExecution(omitFolderPerExecution): { executionRequest+: { artifactRequest+: { omitFolderPerExecution: omitFolderPerExecution } } },
                '#withSharedBetweenPods':: d.fn(help='"whether to share volume between pods"', args=[d.arg(name='sharedBetweenPods', type=d.T.boolean)]),
                withSharedBetweenPods(sharedBetweenPods): { executionRequest+: { artifactRequest+: { sharedBetweenPods: sharedBetweenPods } } },
                '#withSidecarScraper':: d.fn(help='"run scraper as pod sidecar container"', args=[d.arg(name='sidecarScraper', type=d.T.boolean)]),
                withSidecarScraper(sidecarScraper): { executionRequest+: { artifactRequest+: { sidecarScraper: sidecarScraper } } },
                '#withStorageBucket':: d.fn(help='"artifact bucket storage"', args=[d.arg(name='storageBucket', type=d.T.string)]),
                withStorageBucket(storageBucket): { executionRequest+: { artifactRequest+: { storageBucket: storageBucket } } },
                '#withStorageClassName':: d.fn(help='"artifact storage class name for container executor"', args=[d.arg(name='storageClassName', type=d.T.string)]),
                withStorageClassName(storageClassName): { executionRequest+: { artifactRequest+: { storageClassName: storageClassName } } },
                '#withUseDefaultStorageClassName':: d.fn(help='"whether to use default storage class name"', args=[d.arg(name='useDefaultStorageClassName', type=d.T.boolean)]),
                withUseDefaultStorageClassName(useDefaultStorageClassName): { executionRequest+: { artifactRequest+: { useDefaultStorageClassName: useDefaultStorageClassName } } },
                '#withVolumeMountPath':: d.fn(help='"artifact volume mount path for container executor"', args=[d.arg(name='volumeMountPath', type=d.T.string)]),
                withVolumeMountPath(volumeMountPath): { executionRequest+: { artifactRequest+: { volumeMountPath: volumeMountPath } } },
              },
              '#envConfigMaps':: d.obj(help='"config map references"'),
              envConfigMaps: {
                '#reference':: d.obj(help='"LocalObjectReference contains enough information to let you locate the\\nreferenced object inside the same namespace."'),
                reference: {
                  '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { reference+: { name: name } },
                },
                '#withMapToVariables':: d.fn(help='"whether we shoud map to variables from resource"', args=[d.arg(name='mapToVariables', type=d.T.boolean)]),
                withMapToVariables(mapToVariables): { mapToVariables: mapToVariables },
                '#withMount':: d.fn(help='"whether we shoud mount resource"', args=[d.arg(name='mount', type=d.T.boolean)]),
                withMount(mount): { mount: mount },
                '#withMountPath':: d.fn(help='"where we shoud mount resource"', args=[d.arg(name='mountPath', type=d.T.string)]),
                withMountPath(mountPath): { mountPath: mountPath },
              },
              '#envSecrets':: d.obj(help='"secret references"'),
              envSecrets: {
                '#reference':: d.obj(help='"LocalObjectReference contains enough information to let you locate the\\nreferenced object inside the same namespace."'),
                reference: {
                  '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { reference+: { name: name } },
                },
                '#withMapToVariables':: d.fn(help='"whether we shoud map to variables from resource"', args=[d.arg(name='mapToVariables', type=d.T.boolean)]),
                withMapToVariables(mapToVariables): { mapToVariables: mapToVariables },
                '#withMount':: d.fn(help='"whether we shoud mount resource"', args=[d.arg(name='mount', type=d.T.boolean)]),
                withMount(mount): { mount: mount },
                '#withMountPath':: d.fn(help='"where we shoud mount resource"', args=[d.arg(name='mountPath', type=d.T.string)]),
                withMountPath(mountPath): { mountPath: mountPath },
              },
              '#imagePullSecrets':: d.obj(help='"container executor image pull secrets"'),
              imagePullSecrets: {
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { name: name },
              },
              '#withActiveDeadlineSeconds':: d.fn(help='"Optional duration in seconds the pod may be active on the node relative to\\nStartTime before the system will actively try to mark it failed and kill associated containers.\\nValue must be a positive integer."', args=[d.arg(name='activeDeadlineSeconds', type=d.T.integer)]),
              withActiveDeadlineSeconds(activeDeadlineSeconds): { executionRequest+: { activeDeadlineSeconds: activeDeadlineSeconds } },
              '#withArgs':: d.fn(help='"additional executor binary arguments"', args=[d.arg(name='args', type=d.T.array)]),
              withArgs(args): { executionRequest+: { args: if std.isArray(v=args) then args else [args] } },
              '#withArgsMixin':: d.fn(help='"additional executor binary arguments"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='args', type=d.T.array)]),
              withArgsMixin(args): { executionRequest+: { args+: if std.isArray(v=args) then args else [args] } },
              '#withArgsMode':: d.fn(help='"usage mode for arguments"', args=[d.arg(name='argsMode', type=d.T.string)]),
              withArgsMode(argsMode): { executionRequest+: { argsMode: argsMode } },
              '#withCommand':: d.fn(help='"executor binary command"', args=[d.arg(name='command', type=d.T.array)]),
              withCommand(command): { executionRequest+: { command: if std.isArray(v=command) then command else [command] } },
              '#withCommandMixin':: d.fn(help='"executor binary command"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='command', type=d.T.array)]),
              withCommandMixin(command): { executionRequest+: { command+: if std.isArray(v=command) then command else [command] } },
              '#withCronJobTemplate':: d.fn(help='"cron job template extensions"', args=[d.arg(name='cronJobTemplate', type=d.T.string)]),
              withCronJobTemplate(cronJobTemplate): { executionRequest+: { cronJobTemplate: cronJobTemplate } },
              '#withEnvConfigMaps':: d.fn(help='"config map references"', args=[d.arg(name='envConfigMaps', type=d.T.array)]),
              withEnvConfigMaps(envConfigMaps): { executionRequest+: { envConfigMaps: if std.isArray(v=envConfigMaps) then envConfigMaps else [envConfigMaps] } },
              '#withEnvConfigMapsMixin':: d.fn(help='"config map references"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='envConfigMaps', type=d.T.array)]),
              withEnvConfigMapsMixin(envConfigMaps): { executionRequest+: { envConfigMaps+: if std.isArray(v=envConfigMaps) then envConfigMaps else [envConfigMaps] } },
              '#withEnvSecrets':: d.fn(help='"secret references"', args=[d.arg(name='envSecrets', type=d.T.array)]),
              withEnvSecrets(envSecrets): { executionRequest+: { envSecrets: if std.isArray(v=envSecrets) then envSecrets else [envSecrets] } },
              '#withEnvSecretsMixin':: d.fn(help='"secret references"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='envSecrets', type=d.T.array)]),
              withEnvSecretsMixin(envSecrets): { executionRequest+: { envSecrets+: if std.isArray(v=envSecrets) then envSecrets else [envSecrets] } },
              '#withExecutePostRunScriptBeforeScraping':: d.fn(help='"execute post run script before scraping (prebuilt executor only)"', args=[d.arg(name='executePostRunScriptBeforeScraping', type=d.T.boolean)]),
              withExecutePostRunScriptBeforeScraping(executePostRunScriptBeforeScraping): { executionRequest+: { executePostRunScriptBeforeScraping: executePostRunScriptBeforeScraping } },
              '#withExecutionLabels':: d.fn(help='"test execution labels"', args=[d.arg(name='executionLabels', type=d.T.object)]),
              withExecutionLabels(executionLabels): { executionRequest+: { executionLabels: executionLabels } },
              '#withExecutionLabelsMixin':: d.fn(help='"test execution labels"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='executionLabels', type=d.T.object)]),
              withExecutionLabelsMixin(executionLabels): { executionRequest+: { executionLabels+: executionLabels } },
              '#withExecutionNamespace':: d.fn(help='"namespace for test execution (Pro edition only)"', args=[d.arg(name='executionNamespace', type=d.T.string)]),
              withExecutionNamespace(executionNamespace): { executionRequest+: { executionNamespace: executionNamespace } },
              '#withHttpProxy':: d.fn(help='"http proxy for executor containers"', args=[d.arg(name='httpProxy', type=d.T.string)]),
              withHttpProxy(httpProxy): { executionRequest+: { httpProxy: httpProxy } },
              '#withHttpsProxy':: d.fn(help='"https proxy for executor containers"', args=[d.arg(name='httpsProxy', type=d.T.string)]),
              withHttpsProxy(httpsProxy): { executionRequest+: { httpsProxy: httpsProxy } },
              '#withImage':: d.fn(help='"container executor image"', args=[d.arg(name='image', type=d.T.string)]),
              withImage(image): { executionRequest+: { image: image } },
              '#withImagePullSecrets':: d.fn(help='"container executor image pull secrets"', args=[d.arg(name='imagePullSecrets', type=d.T.array)]),
              withImagePullSecrets(imagePullSecrets): { executionRequest+: { imagePullSecrets: if std.isArray(v=imagePullSecrets) then imagePullSecrets else [imagePullSecrets] } },
              '#withImagePullSecretsMixin':: d.fn(help='"container executor image pull secrets"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='imagePullSecrets', type=d.T.array)]),
              withImagePullSecretsMixin(imagePullSecrets): { executionRequest+: { imagePullSecrets+: if std.isArray(v=imagePullSecrets) then imagePullSecrets else [imagePullSecrets] } },
              '#withIsVariablesFileUploaded':: d.fn(help='', args=[d.arg(name='isVariablesFileUploaded', type=d.T.boolean)]),
              withIsVariablesFileUploaded(isVariablesFileUploaded): { executionRequest+: { isVariablesFileUploaded: isVariablesFileUploaded } },
              '#withJobTemplate':: d.fn(help='"job template extensions"', args=[d.arg(name='jobTemplate', type=d.T.string)]),
              withJobTemplate(jobTemplate): { executionRequest+: { jobTemplate: jobTemplate } },
              '#withName':: d.fn(help='"test execution custom name"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { executionRequest+: { name: name } },
              '#withNegativeTest':: d.fn(help='"negative test will fail the execution if it is a success and it will succeed if it is a failure"', args=[d.arg(name='negativeTest', type=d.T.boolean)]),
              withNegativeTest(negativeTest): { executionRequest+: { negativeTest: negativeTest } },
              '#withPostRunScript':: d.fn(help='"script to run after test execution"', args=[d.arg(name='postRunScript', type=d.T.string)]),
              withPostRunScript(postRunScript): { executionRequest+: { postRunScript: postRunScript } },
              '#withPreRunScript':: d.fn(help='"script to run before test execution"', args=[d.arg(name='preRunScript', type=d.T.string)]),
              withPreRunScript(preRunScript): { executionRequest+: { preRunScript: preRunScript } },
              '#withScraperTemplate':: d.fn(help='"scraper template extensions"', args=[d.arg(name='scraperTemplate', type=d.T.string)]),
              withScraperTemplate(scraperTemplate): { executionRequest+: { scraperTemplate: scraperTemplate } },
              '#withSourceScripts':: d.fn(help='"run scripts using source command (container executor only)"', args=[d.arg(name='sourceScripts', type=d.T.boolean)]),
              withSourceScripts(sourceScripts): { executionRequest+: { sourceScripts: sourceScripts } },
              '#withSync':: d.fn(help='"whether to start execution sync or async"', args=[d.arg(name='sync', type=d.T.boolean)]),
              withSync(sync): { executionRequest+: { sync: sync } },
              '#withTestSecretUUID':: d.fn(help='"test secret uuid"', args=[d.arg(name='testSecretUUID', type=d.T.string)]),
              withTestSecretUUID(testSecretUUID): { executionRequest+: { testSecretUUID: testSecretUUID } },
              '#withVariables':: d.fn(help='', args=[d.arg(name='variables', type=d.T.object)]),
              withVariables(variables): { executionRequest+: { variables: variables } },
              '#withVariablesFile':: d.fn(help='"variables file content - need to be in format for particular executor (e.g. postman envs file)"', args=[d.arg(name='variablesFile', type=d.T.string)]),
              withVariablesFile(variablesFile): { executionRequest+: { variablesFile: variablesFile } },
              '#withVariablesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='variables', type=d.T.object)]),
              withVariablesMixin(variables): { executionRequest+: { variables+: variables } },
            },
            '#withCount':: d.fn(help='"static number of sharded instances to spawn"', args=[d.arg(name='count', type=d.T.any)]),
            withCount(count): { count: count },
            '#withDescription':: d.fn(help='"test execution description to display"', args=[d.arg(name='description', type=d.T.string)]),
            withDescription(description): { description: description },
            '#withMatrix':: d.fn(help='"matrix of parameters to spawn instances (static)"', args=[d.arg(name='matrix', type=d.T.object)]),
            withMatrix(matrix): { matrix: matrix },
            '#withMatrixMixin':: d.fn(help='"matrix of parameters to spawn instances (static)"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matrix', type=d.T.object)]),
            withMatrixMixin(matrix): { matrix+: matrix },
            '#withMaxCount':: d.fn(help='"dynamic number of sharded instances to spawn - it will be lowered if there is not enough sharded values"', args=[d.arg(name='maxCount', type=d.T.any)]),
            withMaxCount(maxCount): { maxCount: maxCount },
            '#withName':: d.fn(help='"test name to run"', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { name: name },
            '#withShards':: d.fn(help='"parameters that should be distributed across sharded instances"', args=[d.arg(name='shards', type=d.T.object)]),
            withShards(shards): { shards: shards },
            '#withShardsMixin':: d.fn(help='"parameters that should be distributed across sharded instances"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='shards', type=d.T.object)]),
            withShardsMixin(shards): { shards+: shards },
            '#withTarball':: d.fn(help='"pack some data from the original file system to serve them down"', args=[d.arg(name='tarball', type=d.T.object)]),
            withTarball(tarball): { tarball: tarball },
            '#withTarballMixin':: d.fn(help='"pack some data from the original file system to serve them down"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='tarball', type=d.T.object)]),
            withTarballMixin(tarball): { tarball+: tarball },
          },
          '#withAsync':: d.fn(help="\"only schedule the resources, don't watch the results (unless it is needed for parallelism)\"", args=[d.arg(name='async', type=d.T.boolean)]),
          withAsync(async): { parallel+: { execute+: { async: async } } },
          '#withParallelism':: d.fn(help='"how many resources could be scheduled in parallel"', args=[d.arg(name='parallelism', type=d.T.integer)]),
          withParallelism(parallelism): { parallel+: { execute+: { parallelism: parallelism } } },
          '#withTests':: d.fn(help='"tests to run"', args=[d.arg(name='tests', type=d.T.array)]),
          withTests(tests): { parallel+: { execute+: { tests: if std.isArray(v=tests) then tests else [tests] } } },
          '#withTestsMixin':: d.fn(help='"tests to run"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='tests', type=d.T.array)]),
          withTestsMixin(tests): { parallel+: { execute+: { tests+: if std.isArray(v=tests) then tests else [tests] } } },
          '#withWorkflows':: d.fn(help='"workflows to run"', args=[d.arg(name='workflows', type=d.T.array)]),
          withWorkflows(workflows): { parallel+: { execute+: { workflows: if std.isArray(v=workflows) then workflows else [workflows] } } },
          '#withWorkflowsMixin':: d.fn(help='"workflows to run"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='workflows', type=d.T.array)]),
          withWorkflowsMixin(workflows): { parallel+: { execute+: { workflows+: if std.isArray(v=workflows) then workflows else [workflows] } } },
          '#workflows':: d.obj(help='"workflows to run"'),
          workflows: {
            '#selector':: d.obj(help='"selector is used to identify a group of test workflows based on their metadata labels"'),
            selector: {
              '#matchExpressions':: d.obj(help=''),
              matchExpressions: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                withOperator(operator): { operator: operator },
                '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                withValues(values): { values: if std.isArray(v=values) then values else [values] },
                '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
              },
              '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressions(matchExpressions): { selector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressionsMixin(matchExpressions): { selector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabels(matchLabels): { selector+: { matchLabels: matchLabels } },
              '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabelsMixin(matchLabels): { selector+: { matchLabels+: matchLabels } },
            },
            '#withConfig':: d.fn(help='"configuration to pass for the workflow"', args=[d.arg(name='config', type=d.T.object)]),
            withConfig(config): { config: config },
            '#withConfigMixin':: d.fn(help='"configuration to pass for the workflow"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='config', type=d.T.object)]),
            withConfigMixin(config): { config+: config },
            '#withCount':: d.fn(help='"static number of sharded instances to spawn"', args=[d.arg(name='count', type=d.T.any)]),
            withCount(count): { count: count },
            '#withDescription':: d.fn(help='"test workflow execution description to display"', args=[d.arg(name='description', type=d.T.string)]),
            withDescription(description): { description: description },
            '#withExecutionName':: d.fn(help='"unique execution name to use"', args=[d.arg(name='executionName', type=d.T.string)]),
            withExecutionName(executionName): { executionName: executionName },
            '#withMatrix':: d.fn(help='"matrix of parameters to spawn instances (static)"', args=[d.arg(name='matrix', type=d.T.object)]),
            withMatrix(matrix): { matrix: matrix },
            '#withMatrixMixin':: d.fn(help='"matrix of parameters to spawn instances (static)"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matrix', type=d.T.object)]),
            withMatrixMixin(matrix): { matrix+: matrix },
            '#withMaxCount':: d.fn(help='"dynamic number of sharded instances to spawn - it will be lowered if there is not enough sharded values"', args=[d.arg(name='maxCount', type=d.T.any)]),
            withMaxCount(maxCount): { maxCount: maxCount },
            '#withName':: d.fn(help='"workflow name to run"', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { name: name },
            '#withShards':: d.fn(help='"parameters that should be distributed across sharded instances"', args=[d.arg(name='shards', type=d.T.object)]),
            withShards(shards): { shards: shards },
            '#withShardsMixin':: d.fn(help='"parameters that should be distributed across sharded instances"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='shards', type=d.T.object)]),
            withShardsMixin(shards): { shards+: shards },
            '#withTarball':: d.fn(help='"pack some data from the original file system to serve them down"', args=[d.arg(name='tarball', type=d.T.object)]),
            withTarball(tarball): { tarball: tarball },
            '#withTarballMixin':: d.fn(help='"pack some data from the original file system to serve them down"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='tarball', type=d.T.object)]),
            withTarballMixin(tarball): { tarball+: tarball },
          },
        },
        '#retry':: d.obj(help='"policy for retrying the step"'),
        retry: {
          '#withCount':: d.fn(help='"how many times at most it should retry"', args=[d.arg(name='count', type=d.T.integer)]),
          withCount(count): { parallel+: { retry+: { count: count } } },
          '#withUntil':: d.fn(help='"until when it should retry (defaults to: \\"passed\\")"', args=[d.arg(name='until', type=d.T.string)]),
          withUntil(until): { parallel+: { retry+: { until: until } } },
        },
        '#run':: d.obj(help='"run specific container in the current step"'),
        run: {
          '#env':: d.obj(help=''),
          env: {
            '#valueFrom':: d.obj(help=''),
            valueFrom: {
              '#configMapKeyRef':: d.obj(help=''),
              configMapKeyRef: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { valueFrom+: { configMapKeyRef+: { key: key } } },
                '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { valueFrom+: { configMapKeyRef+: { name: name } } },
                '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { valueFrom+: { configMapKeyRef+: { optional: optional } } },
              },
              '#fieldRef':: d.obj(help=''),
              fieldRef: {
                '#withApiVersion':: d.fn(help='', args=[d.arg(name='apiVersion', type=d.T.string)]),
                withApiVersion(apiVersion): { valueFrom+: { fieldRef+: { apiVersion: apiVersion } } },
                '#withFieldPath':: d.fn(help='', args=[d.arg(name='fieldPath', type=d.T.string)]),
                withFieldPath(fieldPath): { valueFrom+: { fieldRef+: { fieldPath: fieldPath } } },
              },
              '#resourceFieldRef':: d.obj(help=''),
              resourceFieldRef: {
                '#withContainerName':: d.fn(help='', args=[d.arg(name='containerName', type=d.T.string)]),
                withContainerName(containerName): { valueFrom+: { resourceFieldRef+: { containerName: containerName } } },
                '#withDivisor':: d.fn(help='', args=[d.arg(name='divisor', type=d.T.any)]),
                withDivisor(divisor): { valueFrom+: { resourceFieldRef+: { divisor: divisor } } },
                '#withResource':: d.fn(help='', args=[d.arg(name='resource', type=d.T.string)]),
                withResource(resource): { valueFrom+: { resourceFieldRef+: { resource: resource } } },
              },
              '#secretKeyRef':: d.obj(help=''),
              secretKeyRef: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { valueFrom+: { secretKeyRef+: { key: key } } },
                '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { valueFrom+: { secretKeyRef+: { name: name } } },
                '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { valueFrom+: { secretKeyRef+: { optional: optional } } },
              },
            },
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { name: name },
            '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
            withValue(value): { value: value },
          },
          '#envFrom':: d.obj(help=''),
          envFrom: {
            '#configMapRef':: d.obj(help=''),
            configMapRef: {
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { configMapRef+: { name: name } },
              '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { configMapRef+: { optional: optional } },
            },
            '#secretRef':: d.obj(help=''),
            secretRef: {
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { secretRef+: { name: name } },
              '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { secretRef+: { optional: optional } },
            },
            '#withPrefix':: d.fn(help='', args=[d.arg(name='prefix', type=d.T.string)]),
            withPrefix(prefix): { prefix: prefix },
          },
          '#resources':: d.obj(help='"expected resources for the container"'),
          resources: {
            '#withLimits':: d.fn(help='"resource limits for the container"', args=[d.arg(name='limits', type=d.T.object)]),
            withLimits(limits): { parallel+: { run+: { resources+: { limits: limits } } } },
            '#withLimitsMixin':: d.fn(help='"resource limits for the container"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='limits', type=d.T.object)]),
            withLimitsMixin(limits): { parallel+: { run+: { resources+: { limits+: limits } } } },
            '#withRequests':: d.fn(help='"resource requests for the container"', args=[d.arg(name='requests', type=d.T.object)]),
            withRequests(requests): { parallel+: { run+: { resources+: { requests: requests } } } },
            '#withRequestsMixin':: d.fn(help='"resource requests for the container"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requests', type=d.T.object)]),
            withRequestsMixin(requests): { parallel+: { run+: { resources+: { requests+: requests } } } },
          },
          '#securityContext':: d.obj(help=''),
          securityContext: {
            '#appArmorProfile':: d.obj(help=''),
            appArmorProfile: {
              '#withLocalhostProfile':: d.fn(help='', args=[d.arg(name='localhostProfile', type=d.T.string)]),
              withLocalhostProfile(localhostProfile): { parallel+: { run+: { securityContext+: { appArmorProfile+: { localhostProfile: localhostProfile } } } } },
              '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
              withType(type): { parallel+: { run+: { securityContext+: { appArmorProfile+: { type: type } } } } },
            },
            '#capabilities':: d.obj(help=''),
            capabilities: {
              '#withAdd':: d.fn(help='', args=[d.arg(name='add', type=d.T.array)]),
              withAdd(add): { parallel+: { run+: { securityContext+: { capabilities+: { add: if std.isArray(v=add) then add else [add] } } } } },
              '#withAddMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='add', type=d.T.array)]),
              withAddMixin(add): { parallel+: { run+: { securityContext+: { capabilities+: { add+: if std.isArray(v=add) then add else [add] } } } } },
              '#withDrop':: d.fn(help='', args=[d.arg(name='drop', type=d.T.array)]),
              withDrop(drop): { parallel+: { run+: { securityContext+: { capabilities+: { drop: if std.isArray(v=drop) then drop else [drop] } } } } },
              '#withDropMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='drop', type=d.T.array)]),
              withDropMixin(drop): { parallel+: { run+: { securityContext+: { capabilities+: { drop+: if std.isArray(v=drop) then drop else [drop] } } } } },
            },
            '#seLinuxOptions':: d.obj(help=''),
            seLinuxOptions: {
              '#withLevel':: d.fn(help='', args=[d.arg(name='level', type=d.T.string)]),
              withLevel(level): { parallel+: { run+: { securityContext+: { seLinuxOptions+: { level: level } } } } },
              '#withRole':: d.fn(help='', args=[d.arg(name='role', type=d.T.string)]),
              withRole(role): { parallel+: { run+: { securityContext+: { seLinuxOptions+: { role: role } } } } },
              '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
              withType(type): { parallel+: { run+: { securityContext+: { seLinuxOptions+: { type: type } } } } },
              '#withUser':: d.fn(help='', args=[d.arg(name='user', type=d.T.string)]),
              withUser(user): { parallel+: { run+: { securityContext+: { seLinuxOptions+: { user: user } } } } },
            },
            '#seccompProfile':: d.obj(help=''),
            seccompProfile: {
              '#withLocalhostProfile':: d.fn(help='', args=[d.arg(name='localhostProfile', type=d.T.string)]),
              withLocalhostProfile(localhostProfile): { parallel+: { run+: { securityContext+: { seccompProfile+: { localhostProfile: localhostProfile } } } } },
              '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
              withType(type): { parallel+: { run+: { securityContext+: { seccompProfile+: { type: type } } } } },
            },
            '#windowsOptions':: d.obj(help=''),
            windowsOptions: {
              '#withGmsaCredentialSpec':: d.fn(help='', args=[d.arg(name='gmsaCredentialSpec', type=d.T.string)]),
              withGmsaCredentialSpec(gmsaCredentialSpec): { parallel+: { run+: { securityContext+: { windowsOptions+: { gmsaCredentialSpec: gmsaCredentialSpec } } } } },
              '#withGmsaCredentialSpecName':: d.fn(help='', args=[d.arg(name='gmsaCredentialSpecName', type=d.T.string)]),
              withGmsaCredentialSpecName(gmsaCredentialSpecName): { parallel+: { run+: { securityContext+: { windowsOptions+: { gmsaCredentialSpecName: gmsaCredentialSpecName } } } } },
              '#withHostProcess':: d.fn(help='', args=[d.arg(name='hostProcess', type=d.T.boolean)]),
              withHostProcess(hostProcess): { parallel+: { run+: { securityContext+: { windowsOptions+: { hostProcess: hostProcess } } } } },
              '#withRunAsUserName':: d.fn(help='', args=[d.arg(name='runAsUserName', type=d.T.string)]),
              withRunAsUserName(runAsUserName): { parallel+: { run+: { securityContext+: { windowsOptions+: { runAsUserName: runAsUserName } } } } },
            },
            '#withAllowPrivilegeEscalation':: d.fn(help='', args=[d.arg(name='allowPrivilegeEscalation', type=d.T.boolean)]),
            withAllowPrivilegeEscalation(allowPrivilegeEscalation): { parallel+: { run+: { securityContext+: { allowPrivilegeEscalation: allowPrivilegeEscalation } } } },
            '#withPrivileged':: d.fn(help='', args=[d.arg(name='privileged', type=d.T.boolean)]),
            withPrivileged(privileged): { parallel+: { run+: { securityContext+: { privileged: privileged } } } },
            '#withProcMount':: d.fn(help='', args=[d.arg(name='procMount', type=d.T.string)]),
            withProcMount(procMount): { parallel+: { run+: { securityContext+: { procMount: procMount } } } },
            '#withReadOnlyRootFilesystem':: d.fn(help='', args=[d.arg(name='readOnlyRootFilesystem', type=d.T.boolean)]),
            withReadOnlyRootFilesystem(readOnlyRootFilesystem): { parallel+: { run+: { securityContext+: { readOnlyRootFilesystem: readOnlyRootFilesystem } } } },
            '#withRunAsGroup':: d.fn(help='', args=[d.arg(name='runAsGroup', type=d.T.integer)]),
            withRunAsGroup(runAsGroup): { parallel+: { run+: { securityContext+: { runAsGroup: runAsGroup } } } },
            '#withRunAsNonRoot':: d.fn(help='', args=[d.arg(name='runAsNonRoot', type=d.T.boolean)]),
            withRunAsNonRoot(runAsNonRoot): { parallel+: { run+: { securityContext+: { runAsNonRoot: runAsNonRoot } } } },
            '#withRunAsUser':: d.fn(help='', args=[d.arg(name='runAsUser', type=d.T.integer)]),
            withRunAsUser(runAsUser): { parallel+: { run+: { securityContext+: { runAsUser: runAsUser } } } },
          },
          '#volumeMounts':: d.obj(help=''),
          volumeMounts: {
            '#withMountPath':: d.fn(help='', args=[d.arg(name='mountPath', type=d.T.string)]),
            withMountPath(mountPath): { mountPath: mountPath },
            '#withMountPropagation':: d.fn(help='', args=[d.arg(name='mountPropagation', type=d.T.string)]),
            withMountPropagation(mountPropagation): { mountPropagation: mountPropagation },
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { name: name },
            '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
            withReadOnly(readOnly): { readOnly: readOnly },
            '#withRecursiveReadOnly':: d.fn(help='', args=[d.arg(name='recursiveReadOnly', type=d.T.string)]),
            withRecursiveReadOnly(recursiveReadOnly): { recursiveReadOnly: recursiveReadOnly },
            '#withSubPath':: d.fn(help='', args=[d.arg(name='subPath', type=d.T.string)]),
            withSubPath(subPath): { subPath: subPath },
            '#withSubPathExpr':: d.fn(help='', args=[d.arg(name='subPathExpr', type=d.T.string)]),
            withSubPathExpr(subPathExpr): { subPathExpr: subPathExpr },
          },
          '#withArgs':: d.fn(help='"override default command in the image (empty string to default CMD of the image)"', args=[d.arg(name='args', type=d.T.array)]),
          withArgs(args): { parallel+: { run+: { args: if std.isArray(v=args) then args else [args] } } },
          '#withArgsMixin':: d.fn(help='"override default command in the image (empty string to default CMD of the image)"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='args', type=d.T.array)]),
          withArgsMixin(args): { parallel+: { run+: { args+: if std.isArray(v=args) then args else [args] } } },
          '#withCommand':: d.fn(help='"override default command in the image (empty string to default ENTRYPOINT of the image)"', args=[d.arg(name='command', type=d.T.array)]),
          withCommand(command): { parallel+: { run+: { command: if std.isArray(v=command) then command else [command] } } },
          '#withCommandMixin':: d.fn(help='"override default command in the image (empty string to default ENTRYPOINT of the image)"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='command', type=d.T.array)]),
          withCommandMixin(command): { parallel+: { run+: { command+: if std.isArray(v=command) then command else [command] } } },
          '#withEnv':: d.fn(help='', args=[d.arg(name='env', type=d.T.array)]),
          withEnv(env): { parallel+: { run+: { env: if std.isArray(v=env) then env else [env] } } },
          '#withEnvFrom':: d.fn(help='', args=[d.arg(name='envFrom', type=d.T.array)]),
          withEnvFrom(envFrom): { parallel+: { run+: { envFrom: if std.isArray(v=envFrom) then envFrom else [envFrom] } } },
          '#withEnvFromMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='envFrom', type=d.T.array)]),
          withEnvFromMixin(envFrom): { parallel+: { run+: { envFrom+: if std.isArray(v=envFrom) then envFrom else [envFrom] } } },
          '#withEnvMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='env', type=d.T.array)]),
          withEnvMixin(env): { parallel+: { run+: { env+: if std.isArray(v=env) then env else [env] } } },
          '#withImage':: d.fn(help='"image to be used for the container"', args=[d.arg(name='image', type=d.T.string)]),
          withImage(image): { parallel+: { run+: { image: image } } },
          '#withImagePullPolicy':: d.fn(help='"pulling policy for the image"', args=[d.arg(name='imagePullPolicy', type=d.T.string)]),
          withImagePullPolicy(imagePullPolicy): { parallel+: { run+: { imagePullPolicy: imagePullPolicy } } },
          '#withShell':: d.fn(help='"script to run in a default shell for the container"', args=[d.arg(name='shell', type=d.T.string)]),
          withShell(shell): { parallel+: { run+: { shell: shell } } },
          '#withVolumeMounts':: d.fn(help='', args=[d.arg(name='volumeMounts', type=d.T.array)]),
          withVolumeMounts(volumeMounts): { parallel+: { run+: { volumeMounts: if std.isArray(v=volumeMounts) then volumeMounts else [volumeMounts] } } },
          '#withVolumeMountsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='volumeMounts', type=d.T.array)]),
          withVolumeMountsMixin(volumeMounts): { parallel+: { run+: { volumeMounts+: if std.isArray(v=volumeMounts) then volumeMounts else [volumeMounts] } } },
          '#withWorkingDir':: d.fn(help='"override default working directory in the image (empty string to default WORKDIR for the image)"', args=[d.arg(name='workingDir', type=d.T.string)]),
          withWorkingDir(workingDir): { parallel+: { run+: { workingDir: workingDir } } },
        },
        '#withCount':: d.fn(help='"static number of sharded instances to spawn"', args=[d.arg(name='count', type=d.T.any)]),
        withCount(count): { parallel+: { count: count } },
        '#withDelay':: d.fn(help='"delay before the step"', args=[d.arg(name='delay', type=d.T.string)]),
        withDelay(delay): { parallel+: { delay: delay } },
        '#withDescription':: d.fn(help='"worker description to display"', args=[d.arg(name='description', type=d.T.string)]),
        withDescription(description): { parallel+: { description: description } },
        '#withFetch':: d.fn(help='"instructions for fetching files back"', args=[d.arg(name='fetch', type=d.T.array)]),
        withFetch(fetch): { parallel+: { fetch: if std.isArray(v=fetch) then fetch else [fetch] } },
        '#withFetchMixin':: d.fn(help='"instructions for fetching files back"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='fetch', type=d.T.array)]),
        withFetchMixin(fetch): { parallel+: { fetch+: if std.isArray(v=fetch) then fetch else [fetch] } },
        '#withLogs':: d.fn(help='"should save logs for the parallel step (true if not specified)"', args=[d.arg(name='logs', type=d.T.string)]),
        withLogs(logs): { parallel+: { logs: logs } },
        '#withMatrix':: d.fn(help='"matrix of parameters to spawn instances (static)"', args=[d.arg(name='matrix', type=d.T.object)]),
        withMatrix(matrix): { parallel+: { matrix: matrix } },
        '#withMatrixMixin':: d.fn(help='"matrix of parameters to spawn instances (static)"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matrix', type=d.T.object)]),
        withMatrixMixin(matrix): { parallel+: { matrix+: matrix } },
        '#withMaxCount':: d.fn(help='"dynamic number of sharded instances to spawn - it will be lowered if there is not enough sharded values"', args=[d.arg(name='maxCount', type=d.T.any)]),
        withMaxCount(maxCount): { parallel+: { maxCount: maxCount } },
        '#withNegative':: d.fn(help='"is the step expected to fail"', args=[d.arg(name='negative', type=d.T.boolean)]),
        withNegative(negative): { parallel+: { negative: negative } },
        '#withOptional':: d.fn(help="\"is the step optional, so its failure won't affect the TestWorkflow result\"", args=[d.arg(name='optional', type=d.T.boolean)]),
        withOptional(optional): { parallel+: { optional: optional } },
        '#withParallelism':: d.fn(help='"how many resources could be scheduled in parallel"', args=[d.arg(name='parallelism', type=d.T.integer)]),
        withParallelism(parallelism): { parallel+: { parallelism: parallelism } },
        '#withPaused':: d.fn(help='"pause the step initially"', args=[d.arg(name='paused', type=d.T.boolean)]),
        withPaused(paused): { parallel+: { paused: paused } },
        '#withShards':: d.fn(help='"parameters that should be distributed across sharded instances"', args=[d.arg(name='shards', type=d.T.object)]),
        withShards(shards): { parallel+: { shards: shards } },
        '#withShardsMixin':: d.fn(help='"parameters that should be distributed across sharded instances"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='shards', type=d.T.object)]),
        withShardsMixin(shards): { parallel+: { shards+: shards } },
        '#withShell':: d.fn(help='"script to run in a default shell for the container"', args=[d.arg(name='shell', type=d.T.string)]),
        withShell(shell): { parallel+: { shell: shell } },
        '#withTimeout':: d.fn(help='"maximum time this step may take"', args=[d.arg(name='timeout', type=d.T.string)]),
        withTimeout(timeout): { parallel+: { timeout: timeout } },
        '#withTransfer':: d.fn(help='"instructions for transferring files"', args=[d.arg(name='transfer', type=d.T.array)]),
        withTransfer(transfer): { parallel+: { transfer: if std.isArray(v=transfer) then transfer else [transfer] } },
        '#withTransferMixin':: d.fn(help='"instructions for transferring files"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='transfer', type=d.T.array)]),
        withTransferMixin(transfer): { parallel+: { transfer+: if std.isArray(v=transfer) then transfer else [transfer] } },
      },
      '#retry':: d.obj(help='"policy for retrying the step"'),
      retry: {
        '#withCount':: d.fn(help='"how many times at most it should retry"', args=[d.arg(name='count', type=d.T.integer)]),
        withCount(count): { retry+: { count: count } },
        '#withUntil':: d.fn(help='"until when it should retry (defaults to: \\"passed\\")"', args=[d.arg(name='until', type=d.T.string)]),
        withUntil(until): { retry+: { until: until } },
      },
      '#run':: d.obj(help='"run specific container in the current step"'),
      run: {
        '#env':: d.obj(help=''),
        env: {
          '#valueFrom':: d.obj(help=''),
          valueFrom: {
            '#configMapKeyRef':: d.obj(help=''),
            configMapKeyRef: {
              '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { valueFrom+: { configMapKeyRef+: { key: key } } },
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { valueFrom+: { configMapKeyRef+: { name: name } } },
              '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { valueFrom+: { configMapKeyRef+: { optional: optional } } },
            },
            '#fieldRef':: d.obj(help=''),
            fieldRef: {
              '#withApiVersion':: d.fn(help='', args=[d.arg(name='apiVersion', type=d.T.string)]),
              withApiVersion(apiVersion): { valueFrom+: { fieldRef+: { apiVersion: apiVersion } } },
              '#withFieldPath':: d.fn(help='', args=[d.arg(name='fieldPath', type=d.T.string)]),
              withFieldPath(fieldPath): { valueFrom+: { fieldRef+: { fieldPath: fieldPath } } },
            },
            '#resourceFieldRef':: d.obj(help=''),
            resourceFieldRef: {
              '#withContainerName':: d.fn(help='', args=[d.arg(name='containerName', type=d.T.string)]),
              withContainerName(containerName): { valueFrom+: { resourceFieldRef+: { containerName: containerName } } },
              '#withDivisor':: d.fn(help='', args=[d.arg(name='divisor', type=d.T.any)]),
              withDivisor(divisor): { valueFrom+: { resourceFieldRef+: { divisor: divisor } } },
              '#withResource':: d.fn(help='', args=[d.arg(name='resource', type=d.T.string)]),
              withResource(resource): { valueFrom+: { resourceFieldRef+: { resource: resource } } },
            },
            '#secretKeyRef':: d.obj(help=''),
            secretKeyRef: {
              '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { valueFrom+: { secretKeyRef+: { key: key } } },
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { valueFrom+: { secretKeyRef+: { name: name } } },
              '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { valueFrom+: { secretKeyRef+: { optional: optional } } },
            },
          },
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { name: name },
          '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#envFrom':: d.obj(help=''),
        envFrom: {
          '#configMapRef':: d.obj(help=''),
          configMapRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { configMapRef+: { name: name } },
            '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { configMapRef+: { optional: optional } },
          },
          '#secretRef':: d.obj(help=''),
          secretRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { secretRef+: { name: name } },
            '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { secretRef+: { optional: optional } },
          },
          '#withPrefix':: d.fn(help='', args=[d.arg(name='prefix', type=d.T.string)]),
          withPrefix(prefix): { prefix: prefix },
        },
        '#resources':: d.obj(help='"expected resources for the container"'),
        resources: {
          '#withLimits':: d.fn(help='"resource limits for the container"', args=[d.arg(name='limits', type=d.T.object)]),
          withLimits(limits): { run+: { resources+: { limits: limits } } },
          '#withLimitsMixin':: d.fn(help='"resource limits for the container"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='limits', type=d.T.object)]),
          withLimitsMixin(limits): { run+: { resources+: { limits+: limits } } },
          '#withRequests':: d.fn(help='"resource requests for the container"', args=[d.arg(name='requests', type=d.T.object)]),
          withRequests(requests): { run+: { resources+: { requests: requests } } },
          '#withRequestsMixin':: d.fn(help='"resource requests for the container"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requests', type=d.T.object)]),
          withRequestsMixin(requests): { run+: { resources+: { requests+: requests } } },
        },
        '#securityContext':: d.obj(help=''),
        securityContext: {
          '#appArmorProfile':: d.obj(help=''),
          appArmorProfile: {
            '#withLocalhostProfile':: d.fn(help='', args=[d.arg(name='localhostProfile', type=d.T.string)]),
            withLocalhostProfile(localhostProfile): { run+: { securityContext+: { appArmorProfile+: { localhostProfile: localhostProfile } } } },
            '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
            withType(type): { run+: { securityContext+: { appArmorProfile+: { type: type } } } },
          },
          '#capabilities':: d.obj(help=''),
          capabilities: {
            '#withAdd':: d.fn(help='', args=[d.arg(name='add', type=d.T.array)]),
            withAdd(add): { run+: { securityContext+: { capabilities+: { add: if std.isArray(v=add) then add else [add] } } } },
            '#withAddMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='add', type=d.T.array)]),
            withAddMixin(add): { run+: { securityContext+: { capabilities+: { add+: if std.isArray(v=add) then add else [add] } } } },
            '#withDrop':: d.fn(help='', args=[d.arg(name='drop', type=d.T.array)]),
            withDrop(drop): { run+: { securityContext+: { capabilities+: { drop: if std.isArray(v=drop) then drop else [drop] } } } },
            '#withDropMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='drop', type=d.T.array)]),
            withDropMixin(drop): { run+: { securityContext+: { capabilities+: { drop+: if std.isArray(v=drop) then drop else [drop] } } } },
          },
          '#seLinuxOptions':: d.obj(help=''),
          seLinuxOptions: {
            '#withLevel':: d.fn(help='', args=[d.arg(name='level', type=d.T.string)]),
            withLevel(level): { run+: { securityContext+: { seLinuxOptions+: { level: level } } } },
            '#withRole':: d.fn(help='', args=[d.arg(name='role', type=d.T.string)]),
            withRole(role): { run+: { securityContext+: { seLinuxOptions+: { role: role } } } },
            '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
            withType(type): { run+: { securityContext+: { seLinuxOptions+: { type: type } } } },
            '#withUser':: d.fn(help='', args=[d.arg(name='user', type=d.T.string)]),
            withUser(user): { run+: { securityContext+: { seLinuxOptions+: { user: user } } } },
          },
          '#seccompProfile':: d.obj(help=''),
          seccompProfile: {
            '#withLocalhostProfile':: d.fn(help='', args=[d.arg(name='localhostProfile', type=d.T.string)]),
            withLocalhostProfile(localhostProfile): { run+: { securityContext+: { seccompProfile+: { localhostProfile: localhostProfile } } } },
            '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
            withType(type): { run+: { securityContext+: { seccompProfile+: { type: type } } } },
          },
          '#windowsOptions':: d.obj(help=''),
          windowsOptions: {
            '#withGmsaCredentialSpec':: d.fn(help='', args=[d.arg(name='gmsaCredentialSpec', type=d.T.string)]),
            withGmsaCredentialSpec(gmsaCredentialSpec): { run+: { securityContext+: { windowsOptions+: { gmsaCredentialSpec: gmsaCredentialSpec } } } },
            '#withGmsaCredentialSpecName':: d.fn(help='', args=[d.arg(name='gmsaCredentialSpecName', type=d.T.string)]),
            withGmsaCredentialSpecName(gmsaCredentialSpecName): { run+: { securityContext+: { windowsOptions+: { gmsaCredentialSpecName: gmsaCredentialSpecName } } } },
            '#withHostProcess':: d.fn(help='', args=[d.arg(name='hostProcess', type=d.T.boolean)]),
            withHostProcess(hostProcess): { run+: { securityContext+: { windowsOptions+: { hostProcess: hostProcess } } } },
            '#withRunAsUserName':: d.fn(help='', args=[d.arg(name='runAsUserName', type=d.T.string)]),
            withRunAsUserName(runAsUserName): { run+: { securityContext+: { windowsOptions+: { runAsUserName: runAsUserName } } } },
          },
          '#withAllowPrivilegeEscalation':: d.fn(help='', args=[d.arg(name='allowPrivilegeEscalation', type=d.T.boolean)]),
          withAllowPrivilegeEscalation(allowPrivilegeEscalation): { run+: { securityContext+: { allowPrivilegeEscalation: allowPrivilegeEscalation } } },
          '#withPrivileged':: d.fn(help='', args=[d.arg(name='privileged', type=d.T.boolean)]),
          withPrivileged(privileged): { run+: { securityContext+: { privileged: privileged } } },
          '#withProcMount':: d.fn(help='', args=[d.arg(name='procMount', type=d.T.string)]),
          withProcMount(procMount): { run+: { securityContext+: { procMount: procMount } } },
          '#withReadOnlyRootFilesystem':: d.fn(help='', args=[d.arg(name='readOnlyRootFilesystem', type=d.T.boolean)]),
          withReadOnlyRootFilesystem(readOnlyRootFilesystem): { run+: { securityContext+: { readOnlyRootFilesystem: readOnlyRootFilesystem } } },
          '#withRunAsGroup':: d.fn(help='', args=[d.arg(name='runAsGroup', type=d.T.integer)]),
          withRunAsGroup(runAsGroup): { run+: { securityContext+: { runAsGroup: runAsGroup } } },
          '#withRunAsNonRoot':: d.fn(help='', args=[d.arg(name='runAsNonRoot', type=d.T.boolean)]),
          withRunAsNonRoot(runAsNonRoot): { run+: { securityContext+: { runAsNonRoot: runAsNonRoot } } },
          '#withRunAsUser':: d.fn(help='', args=[d.arg(name='runAsUser', type=d.T.integer)]),
          withRunAsUser(runAsUser): { run+: { securityContext+: { runAsUser: runAsUser } } },
        },
        '#volumeMounts':: d.obj(help=''),
        volumeMounts: {
          '#withMountPath':: d.fn(help='', args=[d.arg(name='mountPath', type=d.T.string)]),
          withMountPath(mountPath): { mountPath: mountPath },
          '#withMountPropagation':: d.fn(help='', args=[d.arg(name='mountPropagation', type=d.T.string)]),
          withMountPropagation(mountPropagation): { mountPropagation: mountPropagation },
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { name: name },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { readOnly: readOnly },
          '#withRecursiveReadOnly':: d.fn(help='', args=[d.arg(name='recursiveReadOnly', type=d.T.string)]),
          withRecursiveReadOnly(recursiveReadOnly): { recursiveReadOnly: recursiveReadOnly },
          '#withSubPath':: d.fn(help='', args=[d.arg(name='subPath', type=d.T.string)]),
          withSubPath(subPath): { subPath: subPath },
          '#withSubPathExpr':: d.fn(help='', args=[d.arg(name='subPathExpr', type=d.T.string)]),
          withSubPathExpr(subPathExpr): { subPathExpr: subPathExpr },
        },
        '#withArgs':: d.fn(help='"override default command in the image (empty string to default CMD of the image)"', args=[d.arg(name='args', type=d.T.array)]),
        withArgs(args): { run+: { args: if std.isArray(v=args) then args else [args] } },
        '#withArgsMixin':: d.fn(help='"override default command in the image (empty string to default CMD of the image)"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='args', type=d.T.array)]),
        withArgsMixin(args): { run+: { args+: if std.isArray(v=args) then args else [args] } },
        '#withCommand':: d.fn(help='"override default command in the image (empty string to default ENTRYPOINT of the image)"', args=[d.arg(name='command', type=d.T.array)]),
        withCommand(command): { run+: { command: if std.isArray(v=command) then command else [command] } },
        '#withCommandMixin':: d.fn(help='"override default command in the image (empty string to default ENTRYPOINT of the image)"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='command', type=d.T.array)]),
        withCommandMixin(command): { run+: { command+: if std.isArray(v=command) then command else [command] } },
        '#withEnv':: d.fn(help='', args=[d.arg(name='env', type=d.T.array)]),
        withEnv(env): { run+: { env: if std.isArray(v=env) then env else [env] } },
        '#withEnvFrom':: d.fn(help='', args=[d.arg(name='envFrom', type=d.T.array)]),
        withEnvFrom(envFrom): { run+: { envFrom: if std.isArray(v=envFrom) then envFrom else [envFrom] } },
        '#withEnvFromMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='envFrom', type=d.T.array)]),
        withEnvFromMixin(envFrom): { run+: { envFrom+: if std.isArray(v=envFrom) then envFrom else [envFrom] } },
        '#withEnvMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='env', type=d.T.array)]),
        withEnvMixin(env): { run+: { env+: if std.isArray(v=env) then env else [env] } },
        '#withImage':: d.fn(help='"image to be used for the container"', args=[d.arg(name='image', type=d.T.string)]),
        withImage(image): { run+: { image: image } },
        '#withImagePullPolicy':: d.fn(help='"pulling policy for the image"', args=[d.arg(name='imagePullPolicy', type=d.T.string)]),
        withImagePullPolicy(imagePullPolicy): { run+: { imagePullPolicy: imagePullPolicy } },
        '#withShell':: d.fn(help='"script to run in a default shell for the container"', args=[d.arg(name='shell', type=d.T.string)]),
        withShell(shell): { run+: { shell: shell } },
        '#withVolumeMounts':: d.fn(help='', args=[d.arg(name='volumeMounts', type=d.T.array)]),
        withVolumeMounts(volumeMounts): { run+: { volumeMounts: if std.isArray(v=volumeMounts) then volumeMounts else [volumeMounts] } },
        '#withVolumeMountsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='volumeMounts', type=d.T.array)]),
        withVolumeMountsMixin(volumeMounts): { run+: { volumeMounts+: if std.isArray(v=volumeMounts) then volumeMounts else [volumeMounts] } },
        '#withWorkingDir':: d.fn(help='"override default working directory in the image (empty string to default WORKDIR for the image)"', args=[d.arg(name='workingDir', type=d.T.string)]),
        withWorkingDir(workingDir): { run+: { workingDir: workingDir } },
      },
      '#withCondition':: d.fn(help='"expression to declare under which conditions the step should be run\\ndefaults to: \\"passed\\", except artifacts where it defaults to \\"always\\', args=[d.arg(name='condition', type=d.T.string)]),
      withCondition(condition): { condition: condition },
      '#withDelay':: d.fn(help='"delay before the step"', args=[d.arg(name='delay', type=d.T.string)]),
      withDelay(delay): { delay: delay },
      '#withName':: d.fn(help='"readable name for the step"', args=[d.arg(name='name', type=d.T.string)]),
      withName(name): { name: name },
      '#withNegative':: d.fn(help='"is the step expected to fail"', args=[d.arg(name='negative', type=d.T.boolean)]),
      withNegative(negative): { negative: negative },
      '#withOptional':: d.fn(help="\"is the step optional, so its failure won't affect the TestWorkflow result\"", args=[d.arg(name='optional', type=d.T.boolean)]),
      withOptional(optional): { optional: optional },
      '#withPaused':: d.fn(help='"pause the step initially"', args=[d.arg(name='paused', type=d.T.boolean)]),
      withPaused(paused): { paused: paused },
      '#withPure':: d.fn(help='"mark the step as pure, applying optimizations to merge the containers together"', args=[d.arg(name='pure', type=d.T.boolean)]),
      withPure(pure): { pure: pure },
      '#withServices':: d.fn(help='"list of accompanying services to start"', args=[d.arg(name='services', type=d.T.object)]),
      withServices(services): { services: services },
      '#withServicesMixin':: d.fn(help='"list of accompanying services to start"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='services', type=d.T.object)]),
      withServicesMixin(services): { services+: services },
      '#withSetup':: d.fn(help='"steps to run before other operations in this step"', args=[d.arg(name='setup', type=d.T.any)]),
      withSetup(setup): { setup: setup },
      '#withShell':: d.fn(help='"script to run in a default shell for the container"', args=[d.arg(name='shell', type=d.T.string)]),
      withShell(shell): { shell: shell },
      '#withSteps':: d.fn(help='"sub-steps to run"', args=[d.arg(name='steps', type=d.T.any)]),
      withSteps(steps): { steps: steps },
      '#withTimeout':: d.fn(help='"maximum time this step may take"', args=[d.arg(name='timeout', type=d.T.string)]),
      withTimeout(timeout): { timeout: timeout },
      '#withWorkingDir':: d.fn(help='"working directory to use for this step"', args=[d.arg(name='workingDir', type=d.T.string)]),
      withWorkingDir(workingDir): { workingDir: workingDir },
    },
    '#steps':: d.obj(help='"steps to execute in the workflow"'),
    steps: {
      '#artifacts':: d.obj(help='"scrape artifacts from the volumes"'),
      artifacts: {
        '#compress':: d.obj(help='"compression options for the artifacts"'),
        compress: {
          '#withName':: d.fn(help='"artifact name"', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { artifacts+: { compress+: { name: name } } },
        },
        '#withPaths':: d.fn(help='"paths to fetch from the container"', args=[d.arg(name='paths', type=d.T.array)]),
        withPaths(paths): { artifacts+: { paths: if std.isArray(v=paths) then paths else [paths] } },
        '#withPathsMixin':: d.fn(help='"paths to fetch from the container"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='paths', type=d.T.array)]),
        withPathsMixin(paths): { artifacts+: { paths+: if std.isArray(v=paths) then paths else [paths] } },
        '#withWorkingDir':: d.fn(help='"working directory to override, so it will be used as a base dir"', args=[d.arg(name='workingDir', type=d.T.string)]),
        withWorkingDir(workingDir): { artifacts+: { workingDir: workingDir } },
      },
      '#container':: d.obj(help='"defaults for the containers in this step"'),
      container: {
        '#env':: d.obj(help=''),
        env: {
          '#valueFrom':: d.obj(help=''),
          valueFrom: {
            '#configMapKeyRef':: d.obj(help=''),
            configMapKeyRef: {
              '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { valueFrom+: { configMapKeyRef+: { key: key } } },
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { valueFrom+: { configMapKeyRef+: { name: name } } },
              '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { valueFrom+: { configMapKeyRef+: { optional: optional } } },
            },
            '#fieldRef':: d.obj(help=''),
            fieldRef: {
              '#withApiVersion':: d.fn(help='', args=[d.arg(name='apiVersion', type=d.T.string)]),
              withApiVersion(apiVersion): { valueFrom+: { fieldRef+: { apiVersion: apiVersion } } },
              '#withFieldPath':: d.fn(help='', args=[d.arg(name='fieldPath', type=d.T.string)]),
              withFieldPath(fieldPath): { valueFrom+: { fieldRef+: { fieldPath: fieldPath } } },
            },
            '#resourceFieldRef':: d.obj(help=''),
            resourceFieldRef: {
              '#withContainerName':: d.fn(help='', args=[d.arg(name='containerName', type=d.T.string)]),
              withContainerName(containerName): { valueFrom+: { resourceFieldRef+: { containerName: containerName } } },
              '#withDivisor':: d.fn(help='', args=[d.arg(name='divisor', type=d.T.any)]),
              withDivisor(divisor): { valueFrom+: { resourceFieldRef+: { divisor: divisor } } },
              '#withResource':: d.fn(help='', args=[d.arg(name='resource', type=d.T.string)]),
              withResource(resource): { valueFrom+: { resourceFieldRef+: { resource: resource } } },
            },
            '#secretKeyRef':: d.obj(help=''),
            secretKeyRef: {
              '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { valueFrom+: { secretKeyRef+: { key: key } } },
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { valueFrom+: { secretKeyRef+: { name: name } } },
              '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { valueFrom+: { secretKeyRef+: { optional: optional } } },
            },
          },
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { name: name },
          '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#envFrom':: d.obj(help=''),
        envFrom: {
          '#configMapRef':: d.obj(help=''),
          configMapRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { configMapRef+: { name: name } },
            '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { configMapRef+: { optional: optional } },
          },
          '#secretRef':: d.obj(help=''),
          secretRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { secretRef+: { name: name } },
            '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { secretRef+: { optional: optional } },
          },
          '#withPrefix':: d.fn(help='', args=[d.arg(name='prefix', type=d.T.string)]),
          withPrefix(prefix): { prefix: prefix },
        },
        '#resources':: d.obj(help='"expected resources for the container"'),
        resources: {
          '#withLimits':: d.fn(help='"resource limits for the container"', args=[d.arg(name='limits', type=d.T.object)]),
          withLimits(limits): { container+: { resources+: { limits: limits } } },
          '#withLimitsMixin':: d.fn(help='"resource limits for the container"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='limits', type=d.T.object)]),
          withLimitsMixin(limits): { container+: { resources+: { limits+: limits } } },
          '#withRequests':: d.fn(help='"resource requests for the container"', args=[d.arg(name='requests', type=d.T.object)]),
          withRequests(requests): { container+: { resources+: { requests: requests } } },
          '#withRequestsMixin':: d.fn(help='"resource requests for the container"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requests', type=d.T.object)]),
          withRequestsMixin(requests): { container+: { resources+: { requests+: requests } } },
        },
        '#securityContext':: d.obj(help=''),
        securityContext: {
          '#appArmorProfile':: d.obj(help=''),
          appArmorProfile: {
            '#withLocalhostProfile':: d.fn(help='', args=[d.arg(name='localhostProfile', type=d.T.string)]),
            withLocalhostProfile(localhostProfile): { container+: { securityContext+: { appArmorProfile+: { localhostProfile: localhostProfile } } } },
            '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
            withType(type): { container+: { securityContext+: { appArmorProfile+: { type: type } } } },
          },
          '#capabilities':: d.obj(help=''),
          capabilities: {
            '#withAdd':: d.fn(help='', args=[d.arg(name='add', type=d.T.array)]),
            withAdd(add): { container+: { securityContext+: { capabilities+: { add: if std.isArray(v=add) then add else [add] } } } },
            '#withAddMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='add', type=d.T.array)]),
            withAddMixin(add): { container+: { securityContext+: { capabilities+: { add+: if std.isArray(v=add) then add else [add] } } } },
            '#withDrop':: d.fn(help='', args=[d.arg(name='drop', type=d.T.array)]),
            withDrop(drop): { container+: { securityContext+: { capabilities+: { drop: if std.isArray(v=drop) then drop else [drop] } } } },
            '#withDropMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='drop', type=d.T.array)]),
            withDropMixin(drop): { container+: { securityContext+: { capabilities+: { drop+: if std.isArray(v=drop) then drop else [drop] } } } },
          },
          '#seLinuxOptions':: d.obj(help=''),
          seLinuxOptions: {
            '#withLevel':: d.fn(help='', args=[d.arg(name='level', type=d.T.string)]),
            withLevel(level): { container+: { securityContext+: { seLinuxOptions+: { level: level } } } },
            '#withRole':: d.fn(help='', args=[d.arg(name='role', type=d.T.string)]),
            withRole(role): { container+: { securityContext+: { seLinuxOptions+: { role: role } } } },
            '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
            withType(type): { container+: { securityContext+: { seLinuxOptions+: { type: type } } } },
            '#withUser':: d.fn(help='', args=[d.arg(name='user', type=d.T.string)]),
            withUser(user): { container+: { securityContext+: { seLinuxOptions+: { user: user } } } },
          },
          '#seccompProfile':: d.obj(help=''),
          seccompProfile: {
            '#withLocalhostProfile':: d.fn(help='', args=[d.arg(name='localhostProfile', type=d.T.string)]),
            withLocalhostProfile(localhostProfile): { container+: { securityContext+: { seccompProfile+: { localhostProfile: localhostProfile } } } },
            '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
            withType(type): { container+: { securityContext+: { seccompProfile+: { type: type } } } },
          },
          '#windowsOptions':: d.obj(help=''),
          windowsOptions: {
            '#withGmsaCredentialSpec':: d.fn(help='', args=[d.arg(name='gmsaCredentialSpec', type=d.T.string)]),
            withGmsaCredentialSpec(gmsaCredentialSpec): { container+: { securityContext+: { windowsOptions+: { gmsaCredentialSpec: gmsaCredentialSpec } } } },
            '#withGmsaCredentialSpecName':: d.fn(help='', args=[d.arg(name='gmsaCredentialSpecName', type=d.T.string)]),
            withGmsaCredentialSpecName(gmsaCredentialSpecName): { container+: { securityContext+: { windowsOptions+: { gmsaCredentialSpecName: gmsaCredentialSpecName } } } },
            '#withHostProcess':: d.fn(help='', args=[d.arg(name='hostProcess', type=d.T.boolean)]),
            withHostProcess(hostProcess): { container+: { securityContext+: { windowsOptions+: { hostProcess: hostProcess } } } },
            '#withRunAsUserName':: d.fn(help='', args=[d.arg(name='runAsUserName', type=d.T.string)]),
            withRunAsUserName(runAsUserName): { container+: { securityContext+: { windowsOptions+: { runAsUserName: runAsUserName } } } },
          },
          '#withAllowPrivilegeEscalation':: d.fn(help='', args=[d.arg(name='allowPrivilegeEscalation', type=d.T.boolean)]),
          withAllowPrivilegeEscalation(allowPrivilegeEscalation): { container+: { securityContext+: { allowPrivilegeEscalation: allowPrivilegeEscalation } } },
          '#withPrivileged':: d.fn(help='', args=[d.arg(name='privileged', type=d.T.boolean)]),
          withPrivileged(privileged): { container+: { securityContext+: { privileged: privileged } } },
          '#withProcMount':: d.fn(help='', args=[d.arg(name='procMount', type=d.T.string)]),
          withProcMount(procMount): { container+: { securityContext+: { procMount: procMount } } },
          '#withReadOnlyRootFilesystem':: d.fn(help='', args=[d.arg(name='readOnlyRootFilesystem', type=d.T.boolean)]),
          withReadOnlyRootFilesystem(readOnlyRootFilesystem): { container+: { securityContext+: { readOnlyRootFilesystem: readOnlyRootFilesystem } } },
          '#withRunAsGroup':: d.fn(help='', args=[d.arg(name='runAsGroup', type=d.T.integer)]),
          withRunAsGroup(runAsGroup): { container+: { securityContext+: { runAsGroup: runAsGroup } } },
          '#withRunAsNonRoot':: d.fn(help='', args=[d.arg(name='runAsNonRoot', type=d.T.boolean)]),
          withRunAsNonRoot(runAsNonRoot): { container+: { securityContext+: { runAsNonRoot: runAsNonRoot } } },
          '#withRunAsUser':: d.fn(help='', args=[d.arg(name='runAsUser', type=d.T.integer)]),
          withRunAsUser(runAsUser): { container+: { securityContext+: { runAsUser: runAsUser } } },
        },
        '#volumeMounts':: d.obj(help=''),
        volumeMounts: {
          '#withMountPath':: d.fn(help='', args=[d.arg(name='mountPath', type=d.T.string)]),
          withMountPath(mountPath): { mountPath: mountPath },
          '#withMountPropagation':: d.fn(help='', args=[d.arg(name='mountPropagation', type=d.T.string)]),
          withMountPropagation(mountPropagation): { mountPropagation: mountPropagation },
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { name: name },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { readOnly: readOnly },
          '#withRecursiveReadOnly':: d.fn(help='', args=[d.arg(name='recursiveReadOnly', type=d.T.string)]),
          withRecursiveReadOnly(recursiveReadOnly): { recursiveReadOnly: recursiveReadOnly },
          '#withSubPath':: d.fn(help='', args=[d.arg(name='subPath', type=d.T.string)]),
          withSubPath(subPath): { subPath: subPath },
          '#withSubPathExpr':: d.fn(help='', args=[d.arg(name='subPathExpr', type=d.T.string)]),
          withSubPathExpr(subPathExpr): { subPathExpr: subPathExpr },
        },
        '#withArgs':: d.fn(help='"override default command in the image (empty string to default CMD of the image)"', args=[d.arg(name='args', type=d.T.array)]),
        withArgs(args): { container+: { args: if std.isArray(v=args) then args else [args] } },
        '#withArgsMixin':: d.fn(help='"override default command in the image (empty string to default CMD of the image)"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='args', type=d.T.array)]),
        withArgsMixin(args): { container+: { args+: if std.isArray(v=args) then args else [args] } },
        '#withCommand':: d.fn(help='"override default command in the image (empty string to default ENTRYPOINT of the image)"', args=[d.arg(name='command', type=d.T.array)]),
        withCommand(command): { container+: { command: if std.isArray(v=command) then command else [command] } },
        '#withCommandMixin':: d.fn(help='"override default command in the image (empty string to default ENTRYPOINT of the image)"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='command', type=d.T.array)]),
        withCommandMixin(command): { container+: { command+: if std.isArray(v=command) then command else [command] } },
        '#withEnv':: d.fn(help='', args=[d.arg(name='env', type=d.T.array)]),
        withEnv(env): { container+: { env: if std.isArray(v=env) then env else [env] } },
        '#withEnvFrom':: d.fn(help='', args=[d.arg(name='envFrom', type=d.T.array)]),
        withEnvFrom(envFrom): { container+: { envFrom: if std.isArray(v=envFrom) then envFrom else [envFrom] } },
        '#withEnvFromMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='envFrom', type=d.T.array)]),
        withEnvFromMixin(envFrom): { container+: { envFrom+: if std.isArray(v=envFrom) then envFrom else [envFrom] } },
        '#withEnvMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='env', type=d.T.array)]),
        withEnvMixin(env): { container+: { env+: if std.isArray(v=env) then env else [env] } },
        '#withImage':: d.fn(help='"image to be used for the container"', args=[d.arg(name='image', type=d.T.string)]),
        withImage(image): { container+: { image: image } },
        '#withImagePullPolicy':: d.fn(help='"pulling policy for the image"', args=[d.arg(name='imagePullPolicy', type=d.T.string)]),
        withImagePullPolicy(imagePullPolicy): { container+: { imagePullPolicy: imagePullPolicy } },
        '#withVolumeMounts':: d.fn(help='', args=[d.arg(name='volumeMounts', type=d.T.array)]),
        withVolumeMounts(volumeMounts): { container+: { volumeMounts: if std.isArray(v=volumeMounts) then volumeMounts else [volumeMounts] } },
        '#withVolumeMountsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='volumeMounts', type=d.T.array)]),
        withVolumeMountsMixin(volumeMounts): { container+: { volumeMounts+: if std.isArray(v=volumeMounts) then volumeMounts else [volumeMounts] } },
        '#withWorkingDir':: d.fn(help='"override default working directory in the image (empty string to default WORKDIR for the image)"', args=[d.arg(name='workingDir', type=d.T.string)]),
        withWorkingDir(workingDir): { container+: { workingDir: workingDir } },
      },
      '#content':: d.obj(help='"content that should be fetched for this step"'),
      content: {
        '#files':: d.obj(help='"files to load"'),
        files: {
          '#contentFrom':: d.obj(help='"external source to use"'),
          contentFrom: {
            '#configMapKeyRef':: d.obj(help=''),
            configMapKeyRef: {
              '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { contentFrom+: { configMapKeyRef+: { key: key } } },
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { contentFrom+: { configMapKeyRef+: { name: name } } },
              '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { contentFrom+: { configMapKeyRef+: { optional: optional } } },
            },
            '#fieldRef':: d.obj(help=''),
            fieldRef: {
              '#withApiVersion':: d.fn(help='', args=[d.arg(name='apiVersion', type=d.T.string)]),
              withApiVersion(apiVersion): { contentFrom+: { fieldRef+: { apiVersion: apiVersion } } },
              '#withFieldPath':: d.fn(help='', args=[d.arg(name='fieldPath', type=d.T.string)]),
              withFieldPath(fieldPath): { contentFrom+: { fieldRef+: { fieldPath: fieldPath } } },
            },
            '#resourceFieldRef':: d.obj(help=''),
            resourceFieldRef: {
              '#withContainerName':: d.fn(help='', args=[d.arg(name='containerName', type=d.T.string)]),
              withContainerName(containerName): { contentFrom+: { resourceFieldRef+: { containerName: containerName } } },
              '#withDivisor':: d.fn(help='', args=[d.arg(name='divisor', type=d.T.any)]),
              withDivisor(divisor): { contentFrom+: { resourceFieldRef+: { divisor: divisor } } },
              '#withResource':: d.fn(help='', args=[d.arg(name='resource', type=d.T.string)]),
              withResource(resource): { contentFrom+: { resourceFieldRef+: { resource: resource } } },
            },
            '#secretKeyRef':: d.obj(help=''),
            secretKeyRef: {
              '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { contentFrom+: { secretKeyRef+: { key: key } } },
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { contentFrom+: { secretKeyRef+: { name: name } } },
              '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { contentFrom+: { secretKeyRef+: { optional: optional } } },
            },
          },
          '#withContent':: d.fn(help='"plain-text content to put inside"', args=[d.arg(name='content', type=d.T.string)]),
          withContent(content): { content: content },
          '#withMode':: d.fn(help='"mode to use for the file"', args=[d.arg(name='mode', type=d.T.integer)]),
          withMode(mode): { mode: mode },
          '#withPath':: d.fn(help='"path where the file should be accessible at"', args=[d.arg(name='path', type=d.T.string)]),
          withPath(path): { path: path },
        },
        '#git':: d.obj(help='"git repository details"'),
        git: {
          '#sshKeyFrom':: d.obj(help='"external SSH private key to fetch with"'),
          sshKeyFrom: {
            '#configMapKeyRef':: d.obj(help=''),
            configMapKeyRef: {
              '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { content+: { git+: { sshKeyFrom+: { configMapKeyRef+: { key: key } } } } },
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { content+: { git+: { sshKeyFrom+: { configMapKeyRef+: { name: name } } } } },
              '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { content+: { git+: { sshKeyFrom+: { configMapKeyRef+: { optional: optional } } } } },
            },
            '#fieldRef':: d.obj(help=''),
            fieldRef: {
              '#withApiVersion':: d.fn(help='', args=[d.arg(name='apiVersion', type=d.T.string)]),
              withApiVersion(apiVersion): { content+: { git+: { sshKeyFrom+: { fieldRef+: { apiVersion: apiVersion } } } } },
              '#withFieldPath':: d.fn(help='', args=[d.arg(name='fieldPath', type=d.T.string)]),
              withFieldPath(fieldPath): { content+: { git+: { sshKeyFrom+: { fieldRef+: { fieldPath: fieldPath } } } } },
            },
            '#resourceFieldRef':: d.obj(help=''),
            resourceFieldRef: {
              '#withContainerName':: d.fn(help='', args=[d.arg(name='containerName', type=d.T.string)]),
              withContainerName(containerName): { content+: { git+: { sshKeyFrom+: { resourceFieldRef+: { containerName: containerName } } } } },
              '#withDivisor':: d.fn(help='', args=[d.arg(name='divisor', type=d.T.any)]),
              withDivisor(divisor): { content+: { git+: { sshKeyFrom+: { resourceFieldRef+: { divisor: divisor } } } } },
              '#withResource':: d.fn(help='', args=[d.arg(name='resource', type=d.T.string)]),
              withResource(resource): { content+: { git+: { sshKeyFrom+: { resourceFieldRef+: { resource: resource } } } } },
            },
            '#secretKeyRef':: d.obj(help=''),
            secretKeyRef: {
              '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { content+: { git+: { sshKeyFrom+: { secretKeyRef+: { key: key } } } } },
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { content+: { git+: { sshKeyFrom+: { secretKeyRef+: { name: name } } } } },
              '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { content+: { git+: { sshKeyFrom+: { secretKeyRef+: { optional: optional } } } } },
            },
          },
          '#tokenFrom':: d.obj(help='"external token to fetch with"'),
          tokenFrom: {
            '#configMapKeyRef':: d.obj(help=''),
            configMapKeyRef: {
              '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { content+: { git+: { tokenFrom+: { configMapKeyRef+: { key: key } } } } },
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { content+: { git+: { tokenFrom+: { configMapKeyRef+: { name: name } } } } },
              '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { content+: { git+: { tokenFrom+: { configMapKeyRef+: { optional: optional } } } } },
            },
            '#fieldRef':: d.obj(help=''),
            fieldRef: {
              '#withApiVersion':: d.fn(help='', args=[d.arg(name='apiVersion', type=d.T.string)]),
              withApiVersion(apiVersion): { content+: { git+: { tokenFrom+: { fieldRef+: { apiVersion: apiVersion } } } } },
              '#withFieldPath':: d.fn(help='', args=[d.arg(name='fieldPath', type=d.T.string)]),
              withFieldPath(fieldPath): { content+: { git+: { tokenFrom+: { fieldRef+: { fieldPath: fieldPath } } } } },
            },
            '#resourceFieldRef':: d.obj(help=''),
            resourceFieldRef: {
              '#withContainerName':: d.fn(help='', args=[d.arg(name='containerName', type=d.T.string)]),
              withContainerName(containerName): { content+: { git+: { tokenFrom+: { resourceFieldRef+: { containerName: containerName } } } } },
              '#withDivisor':: d.fn(help='', args=[d.arg(name='divisor', type=d.T.any)]),
              withDivisor(divisor): { content+: { git+: { tokenFrom+: { resourceFieldRef+: { divisor: divisor } } } } },
              '#withResource':: d.fn(help='', args=[d.arg(name='resource', type=d.T.string)]),
              withResource(resource): { content+: { git+: { tokenFrom+: { resourceFieldRef+: { resource: resource } } } } },
            },
            '#secretKeyRef':: d.obj(help=''),
            secretKeyRef: {
              '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { content+: { git+: { tokenFrom+: { secretKeyRef+: { key: key } } } } },
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { content+: { git+: { tokenFrom+: { secretKeyRef+: { name: name } } } } },
              '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { content+: { git+: { tokenFrom+: { secretKeyRef+: { optional: optional } } } } },
            },
          },
          '#usernameFrom':: d.obj(help='"external username to fetch with"'),
          usernameFrom: {
            '#configMapKeyRef':: d.obj(help=''),
            configMapKeyRef: {
              '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { content+: { git+: { usernameFrom+: { configMapKeyRef+: { key: key } } } } },
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { content+: { git+: { usernameFrom+: { configMapKeyRef+: { name: name } } } } },
              '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { content+: { git+: { usernameFrom+: { configMapKeyRef+: { optional: optional } } } } },
            },
            '#fieldRef':: d.obj(help=''),
            fieldRef: {
              '#withApiVersion':: d.fn(help='', args=[d.arg(name='apiVersion', type=d.T.string)]),
              withApiVersion(apiVersion): { content+: { git+: { usernameFrom+: { fieldRef+: { apiVersion: apiVersion } } } } },
              '#withFieldPath':: d.fn(help='', args=[d.arg(name='fieldPath', type=d.T.string)]),
              withFieldPath(fieldPath): { content+: { git+: { usernameFrom+: { fieldRef+: { fieldPath: fieldPath } } } } },
            },
            '#resourceFieldRef':: d.obj(help=''),
            resourceFieldRef: {
              '#withContainerName':: d.fn(help='', args=[d.arg(name='containerName', type=d.T.string)]),
              withContainerName(containerName): { content+: { git+: { usernameFrom+: { resourceFieldRef+: { containerName: containerName } } } } },
              '#withDivisor':: d.fn(help='', args=[d.arg(name='divisor', type=d.T.any)]),
              withDivisor(divisor): { content+: { git+: { usernameFrom+: { resourceFieldRef+: { divisor: divisor } } } } },
              '#withResource':: d.fn(help='', args=[d.arg(name='resource', type=d.T.string)]),
              withResource(resource): { content+: { git+: { usernameFrom+: { resourceFieldRef+: { resource: resource } } } } },
            },
            '#secretKeyRef':: d.obj(help=''),
            secretKeyRef: {
              '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { content+: { git+: { usernameFrom+: { secretKeyRef+: { key: key } } } } },
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { content+: { git+: { usernameFrom+: { secretKeyRef+: { name: name } } } } },
              '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { content+: { git+: { usernameFrom+: { secretKeyRef+: { optional: optional } } } } },
            },
          },
          '#withAuthType':: d.fn(help='"authorization type for the credentials"', args=[d.arg(name='authType', type=d.T.string)]),
          withAuthType(authType): { content+: { git+: { authType: authType } } },
          '#withCone':: d.fn(help='"enable cone mode for sparse checkout with paths"', args=[d.arg(name='cone', type=d.T.boolean)]),
          withCone(cone): { content+: { git+: { cone: cone } } },
          '#withMountPath':: d.fn(help='"where to mount the fetched repository contents (defaults to \\"repo\\" directory in the data volume)"', args=[d.arg(name='mountPath', type=d.T.string)]),
          withMountPath(mountPath): { content+: { git+: { mountPath: mountPath } } },
          '#withPaths':: d.fn(help='"paths to fetch for the sparse checkout"', args=[d.arg(name='paths', type=d.T.array)]),
          withPaths(paths): { content+: { git+: { paths: if std.isArray(v=paths) then paths else [paths] } } },
          '#withPathsMixin':: d.fn(help='"paths to fetch for the sparse checkout"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='paths', type=d.T.array)]),
          withPathsMixin(paths): { content+: { git+: { paths+: if std.isArray(v=paths) then paths else [paths] } } },
          '#withRevision':: d.fn(help='"branch, commit or a tag name to fetch"', args=[d.arg(name='revision', type=d.T.string)]),
          withRevision(revision): { content+: { git+: { revision: revision } } },
          '#withSshKey':: d.fn(help='"plain text SSH private key to fetch with"', args=[d.arg(name='sshKey', type=d.T.string)]),
          withSshKey(sshKey): { content+: { git+: { sshKey: sshKey } } },
          '#withToken':: d.fn(help='"plain text token to fetch with"', args=[d.arg(name='token', type=d.T.string)]),
          withToken(token): { content+: { git+: { token: token } } },
          '#withUri':: d.fn(help='"uri for the Git repository"', args=[d.arg(name='uri', type=d.T.string)]),
          withUri(uri): { content+: { git+: { uri: uri } } },
          '#withUsername':: d.fn(help='"plain text username to fetch with"', args=[d.arg(name='username', type=d.T.string)]),
          withUsername(username): { content+: { git+: { username: username } } },
        },
        '#tarball':: d.obj(help='"tarballs to unpack"'),
        tarball: {
          '#withMount':: d.fn(help='"should it mount a new volume there"', args=[d.arg(name='mount', type=d.T.boolean)]),
          withMount(mount): { mount: mount },
          '#withPath':: d.fn(help='"path where the tarball should be extracted"', args=[d.arg(name='path', type=d.T.string)]),
          withPath(path): { path: path },
          '#withUrl':: d.fn(help='"url for the tarball to extract"', args=[d.arg(name='url', type=d.T.string)]),
          withUrl(url): { url: url },
        },
        '#withFiles':: d.fn(help='"files to load"', args=[d.arg(name='files', type=d.T.array)]),
        withFiles(files): { content+: { files: if std.isArray(v=files) then files else [files] } },
        '#withFilesMixin':: d.fn(help='"files to load"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='files', type=d.T.array)]),
        withFilesMixin(files): { content+: { files+: if std.isArray(v=files) then files else [files] } },
        '#withTarball':: d.fn(help='"tarballs to unpack"', args=[d.arg(name='tarball', type=d.T.array)]),
        withTarball(tarball): { content+: { tarball: if std.isArray(v=tarball) then tarball else [tarball] } },
        '#withTarballMixin':: d.fn(help='"tarballs to unpack"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='tarball', type=d.T.array)]),
        withTarballMixin(tarball): { content+: { tarball+: if std.isArray(v=tarball) then tarball else [tarball] } },
      },
      '#execute':: d.obj(help='"execute other Testkube resources"'),
      execute: {
        '#tests':: d.obj(help='"tests to run"'),
        tests: {
          '#executionRequest':: d.obj(help='"pass the execution request overrides"'),
          executionRequest: {
            '#artifactRequest':: d.obj(help='"artifact request body with test artifacts"'),
            artifactRequest: {
              '#withDirs':: d.fn(help='"artifact directories for scraping"', args=[d.arg(name='dirs', type=d.T.array)]),
              withDirs(dirs): { executionRequest+: { artifactRequest+: { dirs: if std.isArray(v=dirs) then dirs else [dirs] } } },
              '#withDirsMixin':: d.fn(help='"artifact directories for scraping"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='dirs', type=d.T.array)]),
              withDirsMixin(dirs): { executionRequest+: { artifactRequest+: { dirs+: if std.isArray(v=dirs) then dirs else [dirs] } } },
              '#withMasks':: d.fn(help='"regexp to filter scraped artifacts, single or comma separated"', args=[d.arg(name='masks', type=d.T.array)]),
              withMasks(masks): { executionRequest+: { artifactRequest+: { masks: if std.isArray(v=masks) then masks else [masks] } } },
              '#withMasksMixin':: d.fn(help='"regexp to filter scraped artifacts, single or comma separated"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='masks', type=d.T.array)]),
              withMasksMixin(masks): { executionRequest+: { artifactRequest+: { masks+: if std.isArray(v=masks) then masks else [masks] } } },
              '#withOmitFolderPerExecution':: d.fn(help="\"don't use a separate folder for execution artifacts\"", args=[d.arg(name='omitFolderPerExecution', type=d.T.boolean)]),
              withOmitFolderPerExecution(omitFolderPerExecution): { executionRequest+: { artifactRequest+: { omitFolderPerExecution: omitFolderPerExecution } } },
              '#withSharedBetweenPods':: d.fn(help='"whether to share volume between pods"', args=[d.arg(name='sharedBetweenPods', type=d.T.boolean)]),
              withSharedBetweenPods(sharedBetweenPods): { executionRequest+: { artifactRequest+: { sharedBetweenPods: sharedBetweenPods } } },
              '#withSidecarScraper':: d.fn(help='"run scraper as pod sidecar container"', args=[d.arg(name='sidecarScraper', type=d.T.boolean)]),
              withSidecarScraper(sidecarScraper): { executionRequest+: { artifactRequest+: { sidecarScraper: sidecarScraper } } },
              '#withStorageBucket':: d.fn(help='"artifact bucket storage"', args=[d.arg(name='storageBucket', type=d.T.string)]),
              withStorageBucket(storageBucket): { executionRequest+: { artifactRequest+: { storageBucket: storageBucket } } },
              '#withStorageClassName':: d.fn(help='"artifact storage class name for container executor"', args=[d.arg(name='storageClassName', type=d.T.string)]),
              withStorageClassName(storageClassName): { executionRequest+: { artifactRequest+: { storageClassName: storageClassName } } },
              '#withUseDefaultStorageClassName':: d.fn(help='"whether to use default storage class name"', args=[d.arg(name='useDefaultStorageClassName', type=d.T.boolean)]),
              withUseDefaultStorageClassName(useDefaultStorageClassName): { executionRequest+: { artifactRequest+: { useDefaultStorageClassName: useDefaultStorageClassName } } },
              '#withVolumeMountPath':: d.fn(help='"artifact volume mount path for container executor"', args=[d.arg(name='volumeMountPath', type=d.T.string)]),
              withVolumeMountPath(volumeMountPath): { executionRequest+: { artifactRequest+: { volumeMountPath: volumeMountPath } } },
            },
            '#envConfigMaps':: d.obj(help='"config map references"'),
            envConfigMaps: {
              '#reference':: d.obj(help='"LocalObjectReference contains enough information to let you locate the\\nreferenced object inside the same namespace."'),
              reference: {
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { reference+: { name: name } },
              },
              '#withMapToVariables':: d.fn(help='"whether we shoud map to variables from resource"', args=[d.arg(name='mapToVariables', type=d.T.boolean)]),
              withMapToVariables(mapToVariables): { mapToVariables: mapToVariables },
              '#withMount':: d.fn(help='"whether we shoud mount resource"', args=[d.arg(name='mount', type=d.T.boolean)]),
              withMount(mount): { mount: mount },
              '#withMountPath':: d.fn(help='"where we shoud mount resource"', args=[d.arg(name='mountPath', type=d.T.string)]),
              withMountPath(mountPath): { mountPath: mountPath },
            },
            '#envSecrets':: d.obj(help='"secret references"'),
            envSecrets: {
              '#reference':: d.obj(help='"LocalObjectReference contains enough information to let you locate the\\nreferenced object inside the same namespace."'),
              reference: {
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { reference+: { name: name } },
              },
              '#withMapToVariables':: d.fn(help='"whether we shoud map to variables from resource"', args=[d.arg(name='mapToVariables', type=d.T.boolean)]),
              withMapToVariables(mapToVariables): { mapToVariables: mapToVariables },
              '#withMount':: d.fn(help='"whether we shoud mount resource"', args=[d.arg(name='mount', type=d.T.boolean)]),
              withMount(mount): { mount: mount },
              '#withMountPath':: d.fn(help='"where we shoud mount resource"', args=[d.arg(name='mountPath', type=d.T.string)]),
              withMountPath(mountPath): { mountPath: mountPath },
            },
            '#imagePullSecrets':: d.obj(help='"container executor image pull secrets"'),
            imagePullSecrets: {
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { name: name },
            },
            '#withActiveDeadlineSeconds':: d.fn(help='"Optional duration in seconds the pod may be active on the node relative to\\nStartTime before the system will actively try to mark it failed and kill associated containers.\\nValue must be a positive integer."', args=[d.arg(name='activeDeadlineSeconds', type=d.T.integer)]),
            withActiveDeadlineSeconds(activeDeadlineSeconds): { executionRequest+: { activeDeadlineSeconds: activeDeadlineSeconds } },
            '#withArgs':: d.fn(help='"additional executor binary arguments"', args=[d.arg(name='args', type=d.T.array)]),
            withArgs(args): { executionRequest+: { args: if std.isArray(v=args) then args else [args] } },
            '#withArgsMixin':: d.fn(help='"additional executor binary arguments"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='args', type=d.T.array)]),
            withArgsMixin(args): { executionRequest+: { args+: if std.isArray(v=args) then args else [args] } },
            '#withArgsMode':: d.fn(help='"usage mode for arguments"', args=[d.arg(name='argsMode', type=d.T.string)]),
            withArgsMode(argsMode): { executionRequest+: { argsMode: argsMode } },
            '#withCommand':: d.fn(help='"executor binary command"', args=[d.arg(name='command', type=d.T.array)]),
            withCommand(command): { executionRequest+: { command: if std.isArray(v=command) then command else [command] } },
            '#withCommandMixin':: d.fn(help='"executor binary command"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='command', type=d.T.array)]),
            withCommandMixin(command): { executionRequest+: { command+: if std.isArray(v=command) then command else [command] } },
            '#withCronJobTemplate':: d.fn(help='"cron job template extensions"', args=[d.arg(name='cronJobTemplate', type=d.T.string)]),
            withCronJobTemplate(cronJobTemplate): { executionRequest+: { cronJobTemplate: cronJobTemplate } },
            '#withEnvConfigMaps':: d.fn(help='"config map references"', args=[d.arg(name='envConfigMaps', type=d.T.array)]),
            withEnvConfigMaps(envConfigMaps): { executionRequest+: { envConfigMaps: if std.isArray(v=envConfigMaps) then envConfigMaps else [envConfigMaps] } },
            '#withEnvConfigMapsMixin':: d.fn(help='"config map references"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='envConfigMaps', type=d.T.array)]),
            withEnvConfigMapsMixin(envConfigMaps): { executionRequest+: { envConfigMaps+: if std.isArray(v=envConfigMaps) then envConfigMaps else [envConfigMaps] } },
            '#withEnvSecrets':: d.fn(help='"secret references"', args=[d.arg(name='envSecrets', type=d.T.array)]),
            withEnvSecrets(envSecrets): { executionRequest+: { envSecrets: if std.isArray(v=envSecrets) then envSecrets else [envSecrets] } },
            '#withEnvSecretsMixin':: d.fn(help='"secret references"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='envSecrets', type=d.T.array)]),
            withEnvSecretsMixin(envSecrets): { executionRequest+: { envSecrets+: if std.isArray(v=envSecrets) then envSecrets else [envSecrets] } },
            '#withExecutePostRunScriptBeforeScraping':: d.fn(help='"execute post run script before scraping (prebuilt executor only)"', args=[d.arg(name='executePostRunScriptBeforeScraping', type=d.T.boolean)]),
            withExecutePostRunScriptBeforeScraping(executePostRunScriptBeforeScraping): { executionRequest+: { executePostRunScriptBeforeScraping: executePostRunScriptBeforeScraping } },
            '#withExecutionLabels':: d.fn(help='"test execution labels"', args=[d.arg(name='executionLabels', type=d.T.object)]),
            withExecutionLabels(executionLabels): { executionRequest+: { executionLabels: executionLabels } },
            '#withExecutionLabelsMixin':: d.fn(help='"test execution labels"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='executionLabels', type=d.T.object)]),
            withExecutionLabelsMixin(executionLabels): { executionRequest+: { executionLabels+: executionLabels } },
            '#withExecutionNamespace':: d.fn(help='"namespace for test execution (Pro edition only)"', args=[d.arg(name='executionNamespace', type=d.T.string)]),
            withExecutionNamespace(executionNamespace): { executionRequest+: { executionNamespace: executionNamespace } },
            '#withHttpProxy':: d.fn(help='"http proxy for executor containers"', args=[d.arg(name='httpProxy', type=d.T.string)]),
            withHttpProxy(httpProxy): { executionRequest+: { httpProxy: httpProxy } },
            '#withHttpsProxy':: d.fn(help='"https proxy for executor containers"', args=[d.arg(name='httpsProxy', type=d.T.string)]),
            withHttpsProxy(httpsProxy): { executionRequest+: { httpsProxy: httpsProxy } },
            '#withImage':: d.fn(help='"container executor image"', args=[d.arg(name='image', type=d.T.string)]),
            withImage(image): { executionRequest+: { image: image } },
            '#withImagePullSecrets':: d.fn(help='"container executor image pull secrets"', args=[d.arg(name='imagePullSecrets', type=d.T.array)]),
            withImagePullSecrets(imagePullSecrets): { executionRequest+: { imagePullSecrets: if std.isArray(v=imagePullSecrets) then imagePullSecrets else [imagePullSecrets] } },
            '#withImagePullSecretsMixin':: d.fn(help='"container executor image pull secrets"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='imagePullSecrets', type=d.T.array)]),
            withImagePullSecretsMixin(imagePullSecrets): { executionRequest+: { imagePullSecrets+: if std.isArray(v=imagePullSecrets) then imagePullSecrets else [imagePullSecrets] } },
            '#withIsVariablesFileUploaded':: d.fn(help='', args=[d.arg(name='isVariablesFileUploaded', type=d.T.boolean)]),
            withIsVariablesFileUploaded(isVariablesFileUploaded): { executionRequest+: { isVariablesFileUploaded: isVariablesFileUploaded } },
            '#withJobTemplate':: d.fn(help='"job template extensions"', args=[d.arg(name='jobTemplate', type=d.T.string)]),
            withJobTemplate(jobTemplate): { executionRequest+: { jobTemplate: jobTemplate } },
            '#withName':: d.fn(help='"test execution custom name"', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { executionRequest+: { name: name } },
            '#withNegativeTest':: d.fn(help='"negative test will fail the execution if it is a success and it will succeed if it is a failure"', args=[d.arg(name='negativeTest', type=d.T.boolean)]),
            withNegativeTest(negativeTest): { executionRequest+: { negativeTest: negativeTest } },
            '#withPostRunScript':: d.fn(help='"script to run after test execution"', args=[d.arg(name='postRunScript', type=d.T.string)]),
            withPostRunScript(postRunScript): { executionRequest+: { postRunScript: postRunScript } },
            '#withPreRunScript':: d.fn(help='"script to run before test execution"', args=[d.arg(name='preRunScript', type=d.T.string)]),
            withPreRunScript(preRunScript): { executionRequest+: { preRunScript: preRunScript } },
            '#withScraperTemplate':: d.fn(help='"scraper template extensions"', args=[d.arg(name='scraperTemplate', type=d.T.string)]),
            withScraperTemplate(scraperTemplate): { executionRequest+: { scraperTemplate: scraperTemplate } },
            '#withSourceScripts':: d.fn(help='"run scripts using source command (container executor only)"', args=[d.arg(name='sourceScripts', type=d.T.boolean)]),
            withSourceScripts(sourceScripts): { executionRequest+: { sourceScripts: sourceScripts } },
            '#withSync':: d.fn(help='"whether to start execution sync or async"', args=[d.arg(name='sync', type=d.T.boolean)]),
            withSync(sync): { executionRequest+: { sync: sync } },
            '#withTestSecretUUID':: d.fn(help='"test secret uuid"', args=[d.arg(name='testSecretUUID', type=d.T.string)]),
            withTestSecretUUID(testSecretUUID): { executionRequest+: { testSecretUUID: testSecretUUID } },
            '#withVariables':: d.fn(help='', args=[d.arg(name='variables', type=d.T.object)]),
            withVariables(variables): { executionRequest+: { variables: variables } },
            '#withVariablesFile':: d.fn(help='"variables file content - need to be in format for particular executor (e.g. postman envs file)"', args=[d.arg(name='variablesFile', type=d.T.string)]),
            withVariablesFile(variablesFile): { executionRequest+: { variablesFile: variablesFile } },
            '#withVariablesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='variables', type=d.T.object)]),
            withVariablesMixin(variables): { executionRequest+: { variables+: variables } },
          },
          '#withCount':: d.fn(help='"static number of sharded instances to spawn"', args=[d.arg(name='count', type=d.T.any)]),
          withCount(count): { count: count },
          '#withDescription':: d.fn(help='"test execution description to display"', args=[d.arg(name='description', type=d.T.string)]),
          withDescription(description): { description: description },
          '#withMatrix':: d.fn(help='"matrix of parameters to spawn instances (static)"', args=[d.arg(name='matrix', type=d.T.object)]),
          withMatrix(matrix): { matrix: matrix },
          '#withMatrixMixin':: d.fn(help='"matrix of parameters to spawn instances (static)"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matrix', type=d.T.object)]),
          withMatrixMixin(matrix): { matrix+: matrix },
          '#withMaxCount':: d.fn(help='"dynamic number of sharded instances to spawn - it will be lowered if there is not enough sharded values"', args=[d.arg(name='maxCount', type=d.T.any)]),
          withMaxCount(maxCount): { maxCount: maxCount },
          '#withName':: d.fn(help='"test name to run"', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { name: name },
          '#withShards':: d.fn(help='"parameters that should be distributed across sharded instances"', args=[d.arg(name='shards', type=d.T.object)]),
          withShards(shards): { shards: shards },
          '#withShardsMixin':: d.fn(help='"parameters that should be distributed across sharded instances"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='shards', type=d.T.object)]),
          withShardsMixin(shards): { shards+: shards },
          '#withTarball':: d.fn(help='"pack some data from the original file system to serve them down"', args=[d.arg(name='tarball', type=d.T.object)]),
          withTarball(tarball): { tarball: tarball },
          '#withTarballMixin':: d.fn(help='"pack some data from the original file system to serve them down"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='tarball', type=d.T.object)]),
          withTarballMixin(tarball): { tarball+: tarball },
        },
        '#withAsync':: d.fn(help="\"only schedule the resources, don't watch the results (unless it is needed for parallelism)\"", args=[d.arg(name='async', type=d.T.boolean)]),
        withAsync(async): { execute+: { async: async } },
        '#withParallelism':: d.fn(help='"how many resources could be scheduled in parallel"', args=[d.arg(name='parallelism', type=d.T.integer)]),
        withParallelism(parallelism): { execute+: { parallelism: parallelism } },
        '#withTests':: d.fn(help='"tests to run"', args=[d.arg(name='tests', type=d.T.array)]),
        withTests(tests): { execute+: { tests: if std.isArray(v=tests) then tests else [tests] } },
        '#withTestsMixin':: d.fn(help='"tests to run"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='tests', type=d.T.array)]),
        withTestsMixin(tests): { execute+: { tests+: if std.isArray(v=tests) then tests else [tests] } },
        '#withWorkflows':: d.fn(help='"workflows to run"', args=[d.arg(name='workflows', type=d.T.array)]),
        withWorkflows(workflows): { execute+: { workflows: if std.isArray(v=workflows) then workflows else [workflows] } },
        '#withWorkflowsMixin':: d.fn(help='"workflows to run"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='workflows', type=d.T.array)]),
        withWorkflowsMixin(workflows): { execute+: { workflows+: if std.isArray(v=workflows) then workflows else [workflows] } },
        '#workflows':: d.obj(help='"workflows to run"'),
        workflows: {
          '#selector':: d.obj(help='"selector is used to identify a group of test workflows based on their metadata labels"'),
          selector: {
            '#matchExpressions':: d.obj(help=''),
            matchExpressions: {
              '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { key: key },
              '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
              withOperator(operator): { operator: operator },
              '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
              withValues(values): { values: if std.isArray(v=values) then values else [values] },
              '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
              withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
            },
            '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
            withMatchExpressions(matchExpressions): { selector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
            '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
            withMatchExpressionsMixin(matchExpressions): { selector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
            '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
            withMatchLabels(matchLabels): { selector+: { matchLabels: matchLabels } },
            '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
            withMatchLabelsMixin(matchLabels): { selector+: { matchLabels+: matchLabels } },
          },
          '#withConfig':: d.fn(help='"configuration to pass for the workflow"', args=[d.arg(name='config', type=d.T.object)]),
          withConfig(config): { config: config },
          '#withConfigMixin':: d.fn(help='"configuration to pass for the workflow"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='config', type=d.T.object)]),
          withConfigMixin(config): { config+: config },
          '#withCount':: d.fn(help='"static number of sharded instances to spawn"', args=[d.arg(name='count', type=d.T.any)]),
          withCount(count): { count: count },
          '#withDescription':: d.fn(help='"test workflow execution description to display"', args=[d.arg(name='description', type=d.T.string)]),
          withDescription(description): { description: description },
          '#withExecutionName':: d.fn(help='"unique execution name to use"', args=[d.arg(name='executionName', type=d.T.string)]),
          withExecutionName(executionName): { executionName: executionName },
          '#withMatrix':: d.fn(help='"matrix of parameters to spawn instances (static)"', args=[d.arg(name='matrix', type=d.T.object)]),
          withMatrix(matrix): { matrix: matrix },
          '#withMatrixMixin':: d.fn(help='"matrix of parameters to spawn instances (static)"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matrix', type=d.T.object)]),
          withMatrixMixin(matrix): { matrix+: matrix },
          '#withMaxCount':: d.fn(help='"dynamic number of sharded instances to spawn - it will be lowered if there is not enough sharded values"', args=[d.arg(name='maxCount', type=d.T.any)]),
          withMaxCount(maxCount): { maxCount: maxCount },
          '#withName':: d.fn(help='"workflow name to run"', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { name: name },
          '#withShards':: d.fn(help='"parameters that should be distributed across sharded instances"', args=[d.arg(name='shards', type=d.T.object)]),
          withShards(shards): { shards: shards },
          '#withShardsMixin':: d.fn(help='"parameters that should be distributed across sharded instances"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='shards', type=d.T.object)]),
          withShardsMixin(shards): { shards+: shards },
          '#withTarball':: d.fn(help='"pack some data from the original file system to serve them down"', args=[d.arg(name='tarball', type=d.T.object)]),
          withTarball(tarball): { tarball: tarball },
          '#withTarballMixin':: d.fn(help='"pack some data from the original file system to serve them down"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='tarball', type=d.T.object)]),
          withTarballMixin(tarball): { tarball+: tarball },
        },
      },
      '#parallel':: d.obj(help='"instructions for parallel execution"'),
      parallel: {
        '#artifacts':: d.obj(help='"scrape artifacts from the volumes"'),
        artifacts: {
          '#compress':: d.obj(help='"compression options for the artifacts"'),
          compress: {
            '#withName':: d.fn(help='"artifact name"', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { parallel+: { artifacts+: { compress+: { name: name } } } },
          },
          '#withPaths':: d.fn(help='"paths to fetch from the container"', args=[d.arg(name='paths', type=d.T.array)]),
          withPaths(paths): { parallel+: { artifacts+: { paths: if std.isArray(v=paths) then paths else [paths] } } },
          '#withPathsMixin':: d.fn(help='"paths to fetch from the container"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='paths', type=d.T.array)]),
          withPathsMixin(paths): { parallel+: { artifacts+: { paths+: if std.isArray(v=paths) then paths else [paths] } } },
          '#withWorkingDir':: d.fn(help='"working directory to override, so it will be used as a base dir"', args=[d.arg(name='workingDir', type=d.T.string)]),
          withWorkingDir(workingDir): { parallel+: { artifacts+: { workingDir: workingDir } } },
        },
        '#execute':: d.obj(help='"execute other Testkube resources"'),
        execute: {
          '#tests':: d.obj(help='"tests to run"'),
          tests: {
            '#executionRequest':: d.obj(help='"pass the execution request overrides"'),
            executionRequest: {
              '#artifactRequest':: d.obj(help='"artifact request body with test artifacts"'),
              artifactRequest: {
                '#withDirs':: d.fn(help='"artifact directories for scraping"', args=[d.arg(name='dirs', type=d.T.array)]),
                withDirs(dirs): { executionRequest+: { artifactRequest+: { dirs: if std.isArray(v=dirs) then dirs else [dirs] } } },
                '#withDirsMixin':: d.fn(help='"artifact directories for scraping"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='dirs', type=d.T.array)]),
                withDirsMixin(dirs): { executionRequest+: { artifactRequest+: { dirs+: if std.isArray(v=dirs) then dirs else [dirs] } } },
                '#withMasks':: d.fn(help='"regexp to filter scraped artifacts, single or comma separated"', args=[d.arg(name='masks', type=d.T.array)]),
                withMasks(masks): { executionRequest+: { artifactRequest+: { masks: if std.isArray(v=masks) then masks else [masks] } } },
                '#withMasksMixin':: d.fn(help='"regexp to filter scraped artifacts, single or comma separated"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='masks', type=d.T.array)]),
                withMasksMixin(masks): { executionRequest+: { artifactRequest+: { masks+: if std.isArray(v=masks) then masks else [masks] } } },
                '#withOmitFolderPerExecution':: d.fn(help="\"don't use a separate folder for execution artifacts\"", args=[d.arg(name='omitFolderPerExecution', type=d.T.boolean)]),
                withOmitFolderPerExecution(omitFolderPerExecution): { executionRequest+: { artifactRequest+: { omitFolderPerExecution: omitFolderPerExecution } } },
                '#withSharedBetweenPods':: d.fn(help='"whether to share volume between pods"', args=[d.arg(name='sharedBetweenPods', type=d.T.boolean)]),
                withSharedBetweenPods(sharedBetweenPods): { executionRequest+: { artifactRequest+: { sharedBetweenPods: sharedBetweenPods } } },
                '#withSidecarScraper':: d.fn(help='"run scraper as pod sidecar container"', args=[d.arg(name='sidecarScraper', type=d.T.boolean)]),
                withSidecarScraper(sidecarScraper): { executionRequest+: { artifactRequest+: { sidecarScraper: sidecarScraper } } },
                '#withStorageBucket':: d.fn(help='"artifact bucket storage"', args=[d.arg(name='storageBucket', type=d.T.string)]),
                withStorageBucket(storageBucket): { executionRequest+: { artifactRequest+: { storageBucket: storageBucket } } },
                '#withStorageClassName':: d.fn(help='"artifact storage class name for container executor"', args=[d.arg(name='storageClassName', type=d.T.string)]),
                withStorageClassName(storageClassName): { executionRequest+: { artifactRequest+: { storageClassName: storageClassName } } },
                '#withUseDefaultStorageClassName':: d.fn(help='"whether to use default storage class name"', args=[d.arg(name='useDefaultStorageClassName', type=d.T.boolean)]),
                withUseDefaultStorageClassName(useDefaultStorageClassName): { executionRequest+: { artifactRequest+: { useDefaultStorageClassName: useDefaultStorageClassName } } },
                '#withVolumeMountPath':: d.fn(help='"artifact volume mount path for container executor"', args=[d.arg(name='volumeMountPath', type=d.T.string)]),
                withVolumeMountPath(volumeMountPath): { executionRequest+: { artifactRequest+: { volumeMountPath: volumeMountPath } } },
              },
              '#envConfigMaps':: d.obj(help='"config map references"'),
              envConfigMaps: {
                '#reference':: d.obj(help='"LocalObjectReference contains enough information to let you locate the\\nreferenced object inside the same namespace."'),
                reference: {
                  '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { reference+: { name: name } },
                },
                '#withMapToVariables':: d.fn(help='"whether we shoud map to variables from resource"', args=[d.arg(name='mapToVariables', type=d.T.boolean)]),
                withMapToVariables(mapToVariables): { mapToVariables: mapToVariables },
                '#withMount':: d.fn(help='"whether we shoud mount resource"', args=[d.arg(name='mount', type=d.T.boolean)]),
                withMount(mount): { mount: mount },
                '#withMountPath':: d.fn(help='"where we shoud mount resource"', args=[d.arg(name='mountPath', type=d.T.string)]),
                withMountPath(mountPath): { mountPath: mountPath },
              },
              '#envSecrets':: d.obj(help='"secret references"'),
              envSecrets: {
                '#reference':: d.obj(help='"LocalObjectReference contains enough information to let you locate the\\nreferenced object inside the same namespace."'),
                reference: {
                  '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { reference+: { name: name } },
                },
                '#withMapToVariables':: d.fn(help='"whether we shoud map to variables from resource"', args=[d.arg(name='mapToVariables', type=d.T.boolean)]),
                withMapToVariables(mapToVariables): { mapToVariables: mapToVariables },
                '#withMount':: d.fn(help='"whether we shoud mount resource"', args=[d.arg(name='mount', type=d.T.boolean)]),
                withMount(mount): { mount: mount },
                '#withMountPath':: d.fn(help='"where we shoud mount resource"', args=[d.arg(name='mountPath', type=d.T.string)]),
                withMountPath(mountPath): { mountPath: mountPath },
              },
              '#imagePullSecrets':: d.obj(help='"container executor image pull secrets"'),
              imagePullSecrets: {
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { name: name },
              },
              '#withActiveDeadlineSeconds':: d.fn(help='"Optional duration in seconds the pod may be active on the node relative to\\nStartTime before the system will actively try to mark it failed and kill associated containers.\\nValue must be a positive integer."', args=[d.arg(name='activeDeadlineSeconds', type=d.T.integer)]),
              withActiveDeadlineSeconds(activeDeadlineSeconds): { executionRequest+: { activeDeadlineSeconds: activeDeadlineSeconds } },
              '#withArgs':: d.fn(help='"additional executor binary arguments"', args=[d.arg(name='args', type=d.T.array)]),
              withArgs(args): { executionRequest+: { args: if std.isArray(v=args) then args else [args] } },
              '#withArgsMixin':: d.fn(help='"additional executor binary arguments"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='args', type=d.T.array)]),
              withArgsMixin(args): { executionRequest+: { args+: if std.isArray(v=args) then args else [args] } },
              '#withArgsMode':: d.fn(help='"usage mode for arguments"', args=[d.arg(name='argsMode', type=d.T.string)]),
              withArgsMode(argsMode): { executionRequest+: { argsMode: argsMode } },
              '#withCommand':: d.fn(help='"executor binary command"', args=[d.arg(name='command', type=d.T.array)]),
              withCommand(command): { executionRequest+: { command: if std.isArray(v=command) then command else [command] } },
              '#withCommandMixin':: d.fn(help='"executor binary command"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='command', type=d.T.array)]),
              withCommandMixin(command): { executionRequest+: { command+: if std.isArray(v=command) then command else [command] } },
              '#withCronJobTemplate':: d.fn(help='"cron job template extensions"', args=[d.arg(name='cronJobTemplate', type=d.T.string)]),
              withCronJobTemplate(cronJobTemplate): { executionRequest+: { cronJobTemplate: cronJobTemplate } },
              '#withEnvConfigMaps':: d.fn(help='"config map references"', args=[d.arg(name='envConfigMaps', type=d.T.array)]),
              withEnvConfigMaps(envConfigMaps): { executionRequest+: { envConfigMaps: if std.isArray(v=envConfigMaps) then envConfigMaps else [envConfigMaps] } },
              '#withEnvConfigMapsMixin':: d.fn(help='"config map references"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='envConfigMaps', type=d.T.array)]),
              withEnvConfigMapsMixin(envConfigMaps): { executionRequest+: { envConfigMaps+: if std.isArray(v=envConfigMaps) then envConfigMaps else [envConfigMaps] } },
              '#withEnvSecrets':: d.fn(help='"secret references"', args=[d.arg(name='envSecrets', type=d.T.array)]),
              withEnvSecrets(envSecrets): { executionRequest+: { envSecrets: if std.isArray(v=envSecrets) then envSecrets else [envSecrets] } },
              '#withEnvSecretsMixin':: d.fn(help='"secret references"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='envSecrets', type=d.T.array)]),
              withEnvSecretsMixin(envSecrets): { executionRequest+: { envSecrets+: if std.isArray(v=envSecrets) then envSecrets else [envSecrets] } },
              '#withExecutePostRunScriptBeforeScraping':: d.fn(help='"execute post run script before scraping (prebuilt executor only)"', args=[d.arg(name='executePostRunScriptBeforeScraping', type=d.T.boolean)]),
              withExecutePostRunScriptBeforeScraping(executePostRunScriptBeforeScraping): { executionRequest+: { executePostRunScriptBeforeScraping: executePostRunScriptBeforeScraping } },
              '#withExecutionLabels':: d.fn(help='"test execution labels"', args=[d.arg(name='executionLabels', type=d.T.object)]),
              withExecutionLabels(executionLabels): { executionRequest+: { executionLabels: executionLabels } },
              '#withExecutionLabelsMixin':: d.fn(help='"test execution labels"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='executionLabels', type=d.T.object)]),
              withExecutionLabelsMixin(executionLabels): { executionRequest+: { executionLabels+: executionLabels } },
              '#withExecutionNamespace':: d.fn(help='"namespace for test execution (Pro edition only)"', args=[d.arg(name='executionNamespace', type=d.T.string)]),
              withExecutionNamespace(executionNamespace): { executionRequest+: { executionNamespace: executionNamespace } },
              '#withHttpProxy':: d.fn(help='"http proxy for executor containers"', args=[d.arg(name='httpProxy', type=d.T.string)]),
              withHttpProxy(httpProxy): { executionRequest+: { httpProxy: httpProxy } },
              '#withHttpsProxy':: d.fn(help='"https proxy for executor containers"', args=[d.arg(name='httpsProxy', type=d.T.string)]),
              withHttpsProxy(httpsProxy): { executionRequest+: { httpsProxy: httpsProxy } },
              '#withImage':: d.fn(help='"container executor image"', args=[d.arg(name='image', type=d.T.string)]),
              withImage(image): { executionRequest+: { image: image } },
              '#withImagePullSecrets':: d.fn(help='"container executor image pull secrets"', args=[d.arg(name='imagePullSecrets', type=d.T.array)]),
              withImagePullSecrets(imagePullSecrets): { executionRequest+: { imagePullSecrets: if std.isArray(v=imagePullSecrets) then imagePullSecrets else [imagePullSecrets] } },
              '#withImagePullSecretsMixin':: d.fn(help='"container executor image pull secrets"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='imagePullSecrets', type=d.T.array)]),
              withImagePullSecretsMixin(imagePullSecrets): { executionRequest+: { imagePullSecrets+: if std.isArray(v=imagePullSecrets) then imagePullSecrets else [imagePullSecrets] } },
              '#withIsVariablesFileUploaded':: d.fn(help='', args=[d.arg(name='isVariablesFileUploaded', type=d.T.boolean)]),
              withIsVariablesFileUploaded(isVariablesFileUploaded): { executionRequest+: { isVariablesFileUploaded: isVariablesFileUploaded } },
              '#withJobTemplate':: d.fn(help='"job template extensions"', args=[d.arg(name='jobTemplate', type=d.T.string)]),
              withJobTemplate(jobTemplate): { executionRequest+: { jobTemplate: jobTemplate } },
              '#withName':: d.fn(help='"test execution custom name"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { executionRequest+: { name: name } },
              '#withNegativeTest':: d.fn(help='"negative test will fail the execution if it is a success and it will succeed if it is a failure"', args=[d.arg(name='negativeTest', type=d.T.boolean)]),
              withNegativeTest(negativeTest): { executionRequest+: { negativeTest: negativeTest } },
              '#withPostRunScript':: d.fn(help='"script to run after test execution"', args=[d.arg(name='postRunScript', type=d.T.string)]),
              withPostRunScript(postRunScript): { executionRequest+: { postRunScript: postRunScript } },
              '#withPreRunScript':: d.fn(help='"script to run before test execution"', args=[d.arg(name='preRunScript', type=d.T.string)]),
              withPreRunScript(preRunScript): { executionRequest+: { preRunScript: preRunScript } },
              '#withScraperTemplate':: d.fn(help='"scraper template extensions"', args=[d.arg(name='scraperTemplate', type=d.T.string)]),
              withScraperTemplate(scraperTemplate): { executionRequest+: { scraperTemplate: scraperTemplate } },
              '#withSourceScripts':: d.fn(help='"run scripts using source command (container executor only)"', args=[d.arg(name='sourceScripts', type=d.T.boolean)]),
              withSourceScripts(sourceScripts): { executionRequest+: { sourceScripts: sourceScripts } },
              '#withSync':: d.fn(help='"whether to start execution sync or async"', args=[d.arg(name='sync', type=d.T.boolean)]),
              withSync(sync): { executionRequest+: { sync: sync } },
              '#withTestSecretUUID':: d.fn(help='"test secret uuid"', args=[d.arg(name='testSecretUUID', type=d.T.string)]),
              withTestSecretUUID(testSecretUUID): { executionRequest+: { testSecretUUID: testSecretUUID } },
              '#withVariables':: d.fn(help='', args=[d.arg(name='variables', type=d.T.object)]),
              withVariables(variables): { executionRequest+: { variables: variables } },
              '#withVariablesFile':: d.fn(help='"variables file content - need to be in format for particular executor (e.g. postman envs file)"', args=[d.arg(name='variablesFile', type=d.T.string)]),
              withVariablesFile(variablesFile): { executionRequest+: { variablesFile: variablesFile } },
              '#withVariablesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='variables', type=d.T.object)]),
              withVariablesMixin(variables): { executionRequest+: { variables+: variables } },
            },
            '#withCount':: d.fn(help='"static number of sharded instances to spawn"', args=[d.arg(name='count', type=d.T.any)]),
            withCount(count): { count: count },
            '#withDescription':: d.fn(help='"test execution description to display"', args=[d.arg(name='description', type=d.T.string)]),
            withDescription(description): { description: description },
            '#withMatrix':: d.fn(help='"matrix of parameters to spawn instances (static)"', args=[d.arg(name='matrix', type=d.T.object)]),
            withMatrix(matrix): { matrix: matrix },
            '#withMatrixMixin':: d.fn(help='"matrix of parameters to spawn instances (static)"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matrix', type=d.T.object)]),
            withMatrixMixin(matrix): { matrix+: matrix },
            '#withMaxCount':: d.fn(help='"dynamic number of sharded instances to spawn - it will be lowered if there is not enough sharded values"', args=[d.arg(name='maxCount', type=d.T.any)]),
            withMaxCount(maxCount): { maxCount: maxCount },
            '#withName':: d.fn(help='"test name to run"', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { name: name },
            '#withShards':: d.fn(help='"parameters that should be distributed across sharded instances"', args=[d.arg(name='shards', type=d.T.object)]),
            withShards(shards): { shards: shards },
            '#withShardsMixin':: d.fn(help='"parameters that should be distributed across sharded instances"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='shards', type=d.T.object)]),
            withShardsMixin(shards): { shards+: shards },
            '#withTarball':: d.fn(help='"pack some data from the original file system to serve them down"', args=[d.arg(name='tarball', type=d.T.object)]),
            withTarball(tarball): { tarball: tarball },
            '#withTarballMixin':: d.fn(help='"pack some data from the original file system to serve them down"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='tarball', type=d.T.object)]),
            withTarballMixin(tarball): { tarball+: tarball },
          },
          '#withAsync':: d.fn(help="\"only schedule the resources, don't watch the results (unless it is needed for parallelism)\"", args=[d.arg(name='async', type=d.T.boolean)]),
          withAsync(async): { parallel+: { execute+: { async: async } } },
          '#withParallelism':: d.fn(help='"how many resources could be scheduled in parallel"', args=[d.arg(name='parallelism', type=d.T.integer)]),
          withParallelism(parallelism): { parallel+: { execute+: { parallelism: parallelism } } },
          '#withTests':: d.fn(help='"tests to run"', args=[d.arg(name='tests', type=d.T.array)]),
          withTests(tests): { parallel+: { execute+: { tests: if std.isArray(v=tests) then tests else [tests] } } },
          '#withTestsMixin':: d.fn(help='"tests to run"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='tests', type=d.T.array)]),
          withTestsMixin(tests): { parallel+: { execute+: { tests+: if std.isArray(v=tests) then tests else [tests] } } },
          '#withWorkflows':: d.fn(help='"workflows to run"', args=[d.arg(name='workflows', type=d.T.array)]),
          withWorkflows(workflows): { parallel+: { execute+: { workflows: if std.isArray(v=workflows) then workflows else [workflows] } } },
          '#withWorkflowsMixin':: d.fn(help='"workflows to run"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='workflows', type=d.T.array)]),
          withWorkflowsMixin(workflows): { parallel+: { execute+: { workflows+: if std.isArray(v=workflows) then workflows else [workflows] } } },
          '#workflows':: d.obj(help='"workflows to run"'),
          workflows: {
            '#selector':: d.obj(help='"selector is used to identify a group of test workflows based on their metadata labels"'),
            selector: {
              '#matchExpressions':: d.obj(help=''),
              matchExpressions: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { key: key },
                '#withOperator':: d.fn(help='', args=[d.arg(name='operator', type=d.T.string)]),
                withOperator(operator): { operator: operator },
                '#withValues':: d.fn(help='', args=[d.arg(name='values', type=d.T.array)]),
                withValues(values): { values: if std.isArray(v=values) then values else [values] },
                '#withValuesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='values', type=d.T.array)]),
                withValuesMixin(values): { values+: if std.isArray(v=values) then values else [values] },
              },
              '#withMatchExpressions':: d.fn(help='', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressions(matchExpressions): { selector+: { matchExpressions: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchExpressionsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchExpressions', type=d.T.array)]),
              withMatchExpressionsMixin(matchExpressions): { selector+: { matchExpressions+: if std.isArray(v=matchExpressions) then matchExpressions else [matchExpressions] } },
              '#withMatchLabels':: d.fn(help='', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabels(matchLabels): { selector+: { matchLabels: matchLabels } },
              '#withMatchLabelsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matchLabels', type=d.T.object)]),
              withMatchLabelsMixin(matchLabels): { selector+: { matchLabels+: matchLabels } },
            },
            '#withConfig':: d.fn(help='"configuration to pass for the workflow"', args=[d.arg(name='config', type=d.T.object)]),
            withConfig(config): { config: config },
            '#withConfigMixin':: d.fn(help='"configuration to pass for the workflow"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='config', type=d.T.object)]),
            withConfigMixin(config): { config+: config },
            '#withCount':: d.fn(help='"static number of sharded instances to spawn"', args=[d.arg(name='count', type=d.T.any)]),
            withCount(count): { count: count },
            '#withDescription':: d.fn(help='"test workflow execution description to display"', args=[d.arg(name='description', type=d.T.string)]),
            withDescription(description): { description: description },
            '#withExecutionName':: d.fn(help='"unique execution name to use"', args=[d.arg(name='executionName', type=d.T.string)]),
            withExecutionName(executionName): { executionName: executionName },
            '#withMatrix':: d.fn(help='"matrix of parameters to spawn instances (static)"', args=[d.arg(name='matrix', type=d.T.object)]),
            withMatrix(matrix): { matrix: matrix },
            '#withMatrixMixin':: d.fn(help='"matrix of parameters to spawn instances (static)"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matrix', type=d.T.object)]),
            withMatrixMixin(matrix): { matrix+: matrix },
            '#withMaxCount':: d.fn(help='"dynamic number of sharded instances to spawn - it will be lowered if there is not enough sharded values"', args=[d.arg(name='maxCount', type=d.T.any)]),
            withMaxCount(maxCount): { maxCount: maxCount },
            '#withName':: d.fn(help='"workflow name to run"', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { name: name },
            '#withShards':: d.fn(help='"parameters that should be distributed across sharded instances"', args=[d.arg(name='shards', type=d.T.object)]),
            withShards(shards): { shards: shards },
            '#withShardsMixin':: d.fn(help='"parameters that should be distributed across sharded instances"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='shards', type=d.T.object)]),
            withShardsMixin(shards): { shards+: shards },
            '#withTarball':: d.fn(help='"pack some data from the original file system to serve them down"', args=[d.arg(name='tarball', type=d.T.object)]),
            withTarball(tarball): { tarball: tarball },
            '#withTarballMixin':: d.fn(help='"pack some data from the original file system to serve them down"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='tarball', type=d.T.object)]),
            withTarballMixin(tarball): { tarball+: tarball },
          },
        },
        '#retry':: d.obj(help='"policy for retrying the step"'),
        retry: {
          '#withCount':: d.fn(help='"how many times at most it should retry"', args=[d.arg(name='count', type=d.T.integer)]),
          withCount(count): { parallel+: { retry+: { count: count } } },
          '#withUntil':: d.fn(help='"until when it should retry (defaults to: \\"passed\\")"', args=[d.arg(name='until', type=d.T.string)]),
          withUntil(until): { parallel+: { retry+: { until: until } } },
        },
        '#run':: d.obj(help='"run specific container in the current step"'),
        run: {
          '#env':: d.obj(help=''),
          env: {
            '#valueFrom':: d.obj(help=''),
            valueFrom: {
              '#configMapKeyRef':: d.obj(help=''),
              configMapKeyRef: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { valueFrom+: { configMapKeyRef+: { key: key } } },
                '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { valueFrom+: { configMapKeyRef+: { name: name } } },
                '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { valueFrom+: { configMapKeyRef+: { optional: optional } } },
              },
              '#fieldRef':: d.obj(help=''),
              fieldRef: {
                '#withApiVersion':: d.fn(help='', args=[d.arg(name='apiVersion', type=d.T.string)]),
                withApiVersion(apiVersion): { valueFrom+: { fieldRef+: { apiVersion: apiVersion } } },
                '#withFieldPath':: d.fn(help='', args=[d.arg(name='fieldPath', type=d.T.string)]),
                withFieldPath(fieldPath): { valueFrom+: { fieldRef+: { fieldPath: fieldPath } } },
              },
              '#resourceFieldRef':: d.obj(help=''),
              resourceFieldRef: {
                '#withContainerName':: d.fn(help='', args=[d.arg(name='containerName', type=d.T.string)]),
                withContainerName(containerName): { valueFrom+: { resourceFieldRef+: { containerName: containerName } } },
                '#withDivisor':: d.fn(help='', args=[d.arg(name='divisor', type=d.T.any)]),
                withDivisor(divisor): { valueFrom+: { resourceFieldRef+: { divisor: divisor } } },
                '#withResource':: d.fn(help='', args=[d.arg(name='resource', type=d.T.string)]),
                withResource(resource): { valueFrom+: { resourceFieldRef+: { resource: resource } } },
              },
              '#secretKeyRef':: d.obj(help=''),
              secretKeyRef: {
                '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { valueFrom+: { secretKeyRef+: { key: key } } },
                '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { valueFrom+: { secretKeyRef+: { name: name } } },
                '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { valueFrom+: { secretKeyRef+: { optional: optional } } },
              },
            },
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { name: name },
            '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
            withValue(value): { value: value },
          },
          '#envFrom':: d.obj(help=''),
          envFrom: {
            '#configMapRef':: d.obj(help=''),
            configMapRef: {
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { configMapRef+: { name: name } },
              '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { configMapRef+: { optional: optional } },
            },
            '#secretRef':: d.obj(help=''),
            secretRef: {
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { secretRef+: { name: name } },
              '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { secretRef+: { optional: optional } },
            },
            '#withPrefix':: d.fn(help='', args=[d.arg(name='prefix', type=d.T.string)]),
            withPrefix(prefix): { prefix: prefix },
          },
          '#resources':: d.obj(help='"expected resources for the container"'),
          resources: {
            '#withLimits':: d.fn(help='"resource limits for the container"', args=[d.arg(name='limits', type=d.T.object)]),
            withLimits(limits): { parallel+: { run+: { resources+: { limits: limits } } } },
            '#withLimitsMixin':: d.fn(help='"resource limits for the container"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='limits', type=d.T.object)]),
            withLimitsMixin(limits): { parallel+: { run+: { resources+: { limits+: limits } } } },
            '#withRequests':: d.fn(help='"resource requests for the container"', args=[d.arg(name='requests', type=d.T.object)]),
            withRequests(requests): { parallel+: { run+: { resources+: { requests: requests } } } },
            '#withRequestsMixin':: d.fn(help='"resource requests for the container"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requests', type=d.T.object)]),
            withRequestsMixin(requests): { parallel+: { run+: { resources+: { requests+: requests } } } },
          },
          '#securityContext':: d.obj(help=''),
          securityContext: {
            '#appArmorProfile':: d.obj(help=''),
            appArmorProfile: {
              '#withLocalhostProfile':: d.fn(help='', args=[d.arg(name='localhostProfile', type=d.T.string)]),
              withLocalhostProfile(localhostProfile): { parallel+: { run+: { securityContext+: { appArmorProfile+: { localhostProfile: localhostProfile } } } } },
              '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
              withType(type): { parallel+: { run+: { securityContext+: { appArmorProfile+: { type: type } } } } },
            },
            '#capabilities':: d.obj(help=''),
            capabilities: {
              '#withAdd':: d.fn(help='', args=[d.arg(name='add', type=d.T.array)]),
              withAdd(add): { parallel+: { run+: { securityContext+: { capabilities+: { add: if std.isArray(v=add) then add else [add] } } } } },
              '#withAddMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='add', type=d.T.array)]),
              withAddMixin(add): { parallel+: { run+: { securityContext+: { capabilities+: { add+: if std.isArray(v=add) then add else [add] } } } } },
              '#withDrop':: d.fn(help='', args=[d.arg(name='drop', type=d.T.array)]),
              withDrop(drop): { parallel+: { run+: { securityContext+: { capabilities+: { drop: if std.isArray(v=drop) then drop else [drop] } } } } },
              '#withDropMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='drop', type=d.T.array)]),
              withDropMixin(drop): { parallel+: { run+: { securityContext+: { capabilities+: { drop+: if std.isArray(v=drop) then drop else [drop] } } } } },
            },
            '#seLinuxOptions':: d.obj(help=''),
            seLinuxOptions: {
              '#withLevel':: d.fn(help='', args=[d.arg(name='level', type=d.T.string)]),
              withLevel(level): { parallel+: { run+: { securityContext+: { seLinuxOptions+: { level: level } } } } },
              '#withRole':: d.fn(help='', args=[d.arg(name='role', type=d.T.string)]),
              withRole(role): { parallel+: { run+: { securityContext+: { seLinuxOptions+: { role: role } } } } },
              '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
              withType(type): { parallel+: { run+: { securityContext+: { seLinuxOptions+: { type: type } } } } },
              '#withUser':: d.fn(help='', args=[d.arg(name='user', type=d.T.string)]),
              withUser(user): { parallel+: { run+: { securityContext+: { seLinuxOptions+: { user: user } } } } },
            },
            '#seccompProfile':: d.obj(help=''),
            seccompProfile: {
              '#withLocalhostProfile':: d.fn(help='', args=[d.arg(name='localhostProfile', type=d.T.string)]),
              withLocalhostProfile(localhostProfile): { parallel+: { run+: { securityContext+: { seccompProfile+: { localhostProfile: localhostProfile } } } } },
              '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
              withType(type): { parallel+: { run+: { securityContext+: { seccompProfile+: { type: type } } } } },
            },
            '#windowsOptions':: d.obj(help=''),
            windowsOptions: {
              '#withGmsaCredentialSpec':: d.fn(help='', args=[d.arg(name='gmsaCredentialSpec', type=d.T.string)]),
              withGmsaCredentialSpec(gmsaCredentialSpec): { parallel+: { run+: { securityContext+: { windowsOptions+: { gmsaCredentialSpec: gmsaCredentialSpec } } } } },
              '#withGmsaCredentialSpecName':: d.fn(help='', args=[d.arg(name='gmsaCredentialSpecName', type=d.T.string)]),
              withGmsaCredentialSpecName(gmsaCredentialSpecName): { parallel+: { run+: { securityContext+: { windowsOptions+: { gmsaCredentialSpecName: gmsaCredentialSpecName } } } } },
              '#withHostProcess':: d.fn(help='', args=[d.arg(name='hostProcess', type=d.T.boolean)]),
              withHostProcess(hostProcess): { parallel+: { run+: { securityContext+: { windowsOptions+: { hostProcess: hostProcess } } } } },
              '#withRunAsUserName':: d.fn(help='', args=[d.arg(name='runAsUserName', type=d.T.string)]),
              withRunAsUserName(runAsUserName): { parallel+: { run+: { securityContext+: { windowsOptions+: { runAsUserName: runAsUserName } } } } },
            },
            '#withAllowPrivilegeEscalation':: d.fn(help='', args=[d.arg(name='allowPrivilegeEscalation', type=d.T.boolean)]),
            withAllowPrivilegeEscalation(allowPrivilegeEscalation): { parallel+: { run+: { securityContext+: { allowPrivilegeEscalation: allowPrivilegeEscalation } } } },
            '#withPrivileged':: d.fn(help='', args=[d.arg(name='privileged', type=d.T.boolean)]),
            withPrivileged(privileged): { parallel+: { run+: { securityContext+: { privileged: privileged } } } },
            '#withProcMount':: d.fn(help='', args=[d.arg(name='procMount', type=d.T.string)]),
            withProcMount(procMount): { parallel+: { run+: { securityContext+: { procMount: procMount } } } },
            '#withReadOnlyRootFilesystem':: d.fn(help='', args=[d.arg(name='readOnlyRootFilesystem', type=d.T.boolean)]),
            withReadOnlyRootFilesystem(readOnlyRootFilesystem): { parallel+: { run+: { securityContext+: { readOnlyRootFilesystem: readOnlyRootFilesystem } } } },
            '#withRunAsGroup':: d.fn(help='', args=[d.arg(name='runAsGroup', type=d.T.integer)]),
            withRunAsGroup(runAsGroup): { parallel+: { run+: { securityContext+: { runAsGroup: runAsGroup } } } },
            '#withRunAsNonRoot':: d.fn(help='', args=[d.arg(name='runAsNonRoot', type=d.T.boolean)]),
            withRunAsNonRoot(runAsNonRoot): { parallel+: { run+: { securityContext+: { runAsNonRoot: runAsNonRoot } } } },
            '#withRunAsUser':: d.fn(help='', args=[d.arg(name='runAsUser', type=d.T.integer)]),
            withRunAsUser(runAsUser): { parallel+: { run+: { securityContext+: { runAsUser: runAsUser } } } },
          },
          '#volumeMounts':: d.obj(help=''),
          volumeMounts: {
            '#withMountPath':: d.fn(help='', args=[d.arg(name='mountPath', type=d.T.string)]),
            withMountPath(mountPath): { mountPath: mountPath },
            '#withMountPropagation':: d.fn(help='', args=[d.arg(name='mountPropagation', type=d.T.string)]),
            withMountPropagation(mountPropagation): { mountPropagation: mountPropagation },
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { name: name },
            '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
            withReadOnly(readOnly): { readOnly: readOnly },
            '#withRecursiveReadOnly':: d.fn(help='', args=[d.arg(name='recursiveReadOnly', type=d.T.string)]),
            withRecursiveReadOnly(recursiveReadOnly): { recursiveReadOnly: recursiveReadOnly },
            '#withSubPath':: d.fn(help='', args=[d.arg(name='subPath', type=d.T.string)]),
            withSubPath(subPath): { subPath: subPath },
            '#withSubPathExpr':: d.fn(help='', args=[d.arg(name='subPathExpr', type=d.T.string)]),
            withSubPathExpr(subPathExpr): { subPathExpr: subPathExpr },
          },
          '#withArgs':: d.fn(help='"override default command in the image (empty string to default CMD of the image)"', args=[d.arg(name='args', type=d.T.array)]),
          withArgs(args): { parallel+: { run+: { args: if std.isArray(v=args) then args else [args] } } },
          '#withArgsMixin':: d.fn(help='"override default command in the image (empty string to default CMD of the image)"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='args', type=d.T.array)]),
          withArgsMixin(args): { parallel+: { run+: { args+: if std.isArray(v=args) then args else [args] } } },
          '#withCommand':: d.fn(help='"override default command in the image (empty string to default ENTRYPOINT of the image)"', args=[d.arg(name='command', type=d.T.array)]),
          withCommand(command): { parallel+: { run+: { command: if std.isArray(v=command) then command else [command] } } },
          '#withCommandMixin':: d.fn(help='"override default command in the image (empty string to default ENTRYPOINT of the image)"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='command', type=d.T.array)]),
          withCommandMixin(command): { parallel+: { run+: { command+: if std.isArray(v=command) then command else [command] } } },
          '#withEnv':: d.fn(help='', args=[d.arg(name='env', type=d.T.array)]),
          withEnv(env): { parallel+: { run+: { env: if std.isArray(v=env) then env else [env] } } },
          '#withEnvFrom':: d.fn(help='', args=[d.arg(name='envFrom', type=d.T.array)]),
          withEnvFrom(envFrom): { parallel+: { run+: { envFrom: if std.isArray(v=envFrom) then envFrom else [envFrom] } } },
          '#withEnvFromMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='envFrom', type=d.T.array)]),
          withEnvFromMixin(envFrom): { parallel+: { run+: { envFrom+: if std.isArray(v=envFrom) then envFrom else [envFrom] } } },
          '#withEnvMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='env', type=d.T.array)]),
          withEnvMixin(env): { parallel+: { run+: { env+: if std.isArray(v=env) then env else [env] } } },
          '#withImage':: d.fn(help='"image to be used for the container"', args=[d.arg(name='image', type=d.T.string)]),
          withImage(image): { parallel+: { run+: { image: image } } },
          '#withImagePullPolicy':: d.fn(help='"pulling policy for the image"', args=[d.arg(name='imagePullPolicy', type=d.T.string)]),
          withImagePullPolicy(imagePullPolicy): { parallel+: { run+: { imagePullPolicy: imagePullPolicy } } },
          '#withShell':: d.fn(help='"script to run in a default shell for the container"', args=[d.arg(name='shell', type=d.T.string)]),
          withShell(shell): { parallel+: { run+: { shell: shell } } },
          '#withVolumeMounts':: d.fn(help='', args=[d.arg(name='volumeMounts', type=d.T.array)]),
          withVolumeMounts(volumeMounts): { parallel+: { run+: { volumeMounts: if std.isArray(v=volumeMounts) then volumeMounts else [volumeMounts] } } },
          '#withVolumeMountsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='volumeMounts', type=d.T.array)]),
          withVolumeMountsMixin(volumeMounts): { parallel+: { run+: { volumeMounts+: if std.isArray(v=volumeMounts) then volumeMounts else [volumeMounts] } } },
          '#withWorkingDir':: d.fn(help='"override default working directory in the image (empty string to default WORKDIR for the image)"', args=[d.arg(name='workingDir', type=d.T.string)]),
          withWorkingDir(workingDir): { parallel+: { run+: { workingDir: workingDir } } },
        },
        '#withCount':: d.fn(help='"static number of sharded instances to spawn"', args=[d.arg(name='count', type=d.T.any)]),
        withCount(count): { parallel+: { count: count } },
        '#withDelay':: d.fn(help='"delay before the step"', args=[d.arg(name='delay', type=d.T.string)]),
        withDelay(delay): { parallel+: { delay: delay } },
        '#withDescription':: d.fn(help='"worker description to display"', args=[d.arg(name='description', type=d.T.string)]),
        withDescription(description): { parallel+: { description: description } },
        '#withFetch':: d.fn(help='"instructions for fetching files back"', args=[d.arg(name='fetch', type=d.T.array)]),
        withFetch(fetch): { parallel+: { fetch: if std.isArray(v=fetch) then fetch else [fetch] } },
        '#withFetchMixin':: d.fn(help='"instructions for fetching files back"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='fetch', type=d.T.array)]),
        withFetchMixin(fetch): { parallel+: { fetch+: if std.isArray(v=fetch) then fetch else [fetch] } },
        '#withLogs':: d.fn(help='"should save logs for the parallel step (true if not specified)"', args=[d.arg(name='logs', type=d.T.string)]),
        withLogs(logs): { parallel+: { logs: logs } },
        '#withMatrix':: d.fn(help='"matrix of parameters to spawn instances (static)"', args=[d.arg(name='matrix', type=d.T.object)]),
        withMatrix(matrix): { parallel+: { matrix: matrix } },
        '#withMatrixMixin':: d.fn(help='"matrix of parameters to spawn instances (static)"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='matrix', type=d.T.object)]),
        withMatrixMixin(matrix): { parallel+: { matrix+: matrix } },
        '#withMaxCount':: d.fn(help='"dynamic number of sharded instances to spawn - it will be lowered if there is not enough sharded values"', args=[d.arg(name='maxCount', type=d.T.any)]),
        withMaxCount(maxCount): { parallel+: { maxCount: maxCount } },
        '#withNegative':: d.fn(help='"is the step expected to fail"', args=[d.arg(name='negative', type=d.T.boolean)]),
        withNegative(negative): { parallel+: { negative: negative } },
        '#withOptional':: d.fn(help="\"is the step optional, so its failure won't affect the TestWorkflow result\"", args=[d.arg(name='optional', type=d.T.boolean)]),
        withOptional(optional): { parallel+: { optional: optional } },
        '#withParallelism':: d.fn(help='"how many resources could be scheduled in parallel"', args=[d.arg(name='parallelism', type=d.T.integer)]),
        withParallelism(parallelism): { parallel+: { parallelism: parallelism } },
        '#withPaused':: d.fn(help='"pause the step initially"', args=[d.arg(name='paused', type=d.T.boolean)]),
        withPaused(paused): { parallel+: { paused: paused } },
        '#withShards':: d.fn(help='"parameters that should be distributed across sharded instances"', args=[d.arg(name='shards', type=d.T.object)]),
        withShards(shards): { parallel+: { shards: shards } },
        '#withShardsMixin':: d.fn(help='"parameters that should be distributed across sharded instances"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='shards', type=d.T.object)]),
        withShardsMixin(shards): { parallel+: { shards+: shards } },
        '#withShell':: d.fn(help='"script to run in a default shell for the container"', args=[d.arg(name='shell', type=d.T.string)]),
        withShell(shell): { parallel+: { shell: shell } },
        '#withTimeout':: d.fn(help='"maximum time this step may take"', args=[d.arg(name='timeout', type=d.T.string)]),
        withTimeout(timeout): { parallel+: { timeout: timeout } },
        '#withTransfer':: d.fn(help='"instructions for transferring files"', args=[d.arg(name='transfer', type=d.T.array)]),
        withTransfer(transfer): { parallel+: { transfer: if std.isArray(v=transfer) then transfer else [transfer] } },
        '#withTransferMixin':: d.fn(help='"instructions for transferring files"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='transfer', type=d.T.array)]),
        withTransferMixin(transfer): { parallel+: { transfer+: if std.isArray(v=transfer) then transfer else [transfer] } },
      },
      '#retry':: d.obj(help='"policy for retrying the step"'),
      retry: {
        '#withCount':: d.fn(help='"how many times at most it should retry"', args=[d.arg(name='count', type=d.T.integer)]),
        withCount(count): { retry+: { count: count } },
        '#withUntil':: d.fn(help='"until when it should retry (defaults to: \\"passed\\")"', args=[d.arg(name='until', type=d.T.string)]),
        withUntil(until): { retry+: { until: until } },
      },
      '#run':: d.obj(help='"run specific container in the current step"'),
      run: {
        '#env':: d.obj(help=''),
        env: {
          '#valueFrom':: d.obj(help=''),
          valueFrom: {
            '#configMapKeyRef':: d.obj(help=''),
            configMapKeyRef: {
              '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { valueFrom+: { configMapKeyRef+: { key: key } } },
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { valueFrom+: { configMapKeyRef+: { name: name } } },
              '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { valueFrom+: { configMapKeyRef+: { optional: optional } } },
            },
            '#fieldRef':: d.obj(help=''),
            fieldRef: {
              '#withApiVersion':: d.fn(help='', args=[d.arg(name='apiVersion', type=d.T.string)]),
              withApiVersion(apiVersion): { valueFrom+: { fieldRef+: { apiVersion: apiVersion } } },
              '#withFieldPath':: d.fn(help='', args=[d.arg(name='fieldPath', type=d.T.string)]),
              withFieldPath(fieldPath): { valueFrom+: { fieldRef+: { fieldPath: fieldPath } } },
            },
            '#resourceFieldRef':: d.obj(help=''),
            resourceFieldRef: {
              '#withContainerName':: d.fn(help='', args=[d.arg(name='containerName', type=d.T.string)]),
              withContainerName(containerName): { valueFrom+: { resourceFieldRef+: { containerName: containerName } } },
              '#withDivisor':: d.fn(help='', args=[d.arg(name='divisor', type=d.T.any)]),
              withDivisor(divisor): { valueFrom+: { resourceFieldRef+: { divisor: divisor } } },
              '#withResource':: d.fn(help='', args=[d.arg(name='resource', type=d.T.string)]),
              withResource(resource): { valueFrom+: { resourceFieldRef+: { resource: resource } } },
            },
            '#secretKeyRef':: d.obj(help=''),
            secretKeyRef: {
              '#withKey':: d.fn(help='', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { valueFrom+: { secretKeyRef+: { key: key } } },
              '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { valueFrom+: { secretKeyRef+: { name: name } } },
              '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { valueFrom+: { secretKeyRef+: { optional: optional } } },
            },
          },
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { name: name },
          '#withValue':: d.fn(help='', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#envFrom':: d.obj(help=''),
        envFrom: {
          '#configMapRef':: d.obj(help=''),
          configMapRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { configMapRef+: { name: name } },
            '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { configMapRef+: { optional: optional } },
          },
          '#secretRef':: d.obj(help=''),
          secretRef: {
            '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { secretRef+: { name: name } },
            '#withOptional':: d.fn(help='', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { secretRef+: { optional: optional } },
          },
          '#withPrefix':: d.fn(help='', args=[d.arg(name='prefix', type=d.T.string)]),
          withPrefix(prefix): { prefix: prefix },
        },
        '#resources':: d.obj(help='"expected resources for the container"'),
        resources: {
          '#withLimits':: d.fn(help='"resource limits for the container"', args=[d.arg(name='limits', type=d.T.object)]),
          withLimits(limits): { run+: { resources+: { limits: limits } } },
          '#withLimitsMixin':: d.fn(help='"resource limits for the container"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='limits', type=d.T.object)]),
          withLimitsMixin(limits): { run+: { resources+: { limits+: limits } } },
          '#withRequests':: d.fn(help='"resource requests for the container"', args=[d.arg(name='requests', type=d.T.object)]),
          withRequests(requests): { run+: { resources+: { requests: requests } } },
          '#withRequestsMixin':: d.fn(help='"resource requests for the container"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='requests', type=d.T.object)]),
          withRequestsMixin(requests): { run+: { resources+: { requests+: requests } } },
        },
        '#securityContext':: d.obj(help=''),
        securityContext: {
          '#appArmorProfile':: d.obj(help=''),
          appArmorProfile: {
            '#withLocalhostProfile':: d.fn(help='', args=[d.arg(name='localhostProfile', type=d.T.string)]),
            withLocalhostProfile(localhostProfile): { run+: { securityContext+: { appArmorProfile+: { localhostProfile: localhostProfile } } } },
            '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
            withType(type): { run+: { securityContext+: { appArmorProfile+: { type: type } } } },
          },
          '#capabilities':: d.obj(help=''),
          capabilities: {
            '#withAdd':: d.fn(help='', args=[d.arg(name='add', type=d.T.array)]),
            withAdd(add): { run+: { securityContext+: { capabilities+: { add: if std.isArray(v=add) then add else [add] } } } },
            '#withAddMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='add', type=d.T.array)]),
            withAddMixin(add): { run+: { securityContext+: { capabilities+: { add+: if std.isArray(v=add) then add else [add] } } } },
            '#withDrop':: d.fn(help='', args=[d.arg(name='drop', type=d.T.array)]),
            withDrop(drop): { run+: { securityContext+: { capabilities+: { drop: if std.isArray(v=drop) then drop else [drop] } } } },
            '#withDropMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='drop', type=d.T.array)]),
            withDropMixin(drop): { run+: { securityContext+: { capabilities+: { drop+: if std.isArray(v=drop) then drop else [drop] } } } },
          },
          '#seLinuxOptions':: d.obj(help=''),
          seLinuxOptions: {
            '#withLevel':: d.fn(help='', args=[d.arg(name='level', type=d.T.string)]),
            withLevel(level): { run+: { securityContext+: { seLinuxOptions+: { level: level } } } },
            '#withRole':: d.fn(help='', args=[d.arg(name='role', type=d.T.string)]),
            withRole(role): { run+: { securityContext+: { seLinuxOptions+: { role: role } } } },
            '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
            withType(type): { run+: { securityContext+: { seLinuxOptions+: { type: type } } } },
            '#withUser':: d.fn(help='', args=[d.arg(name='user', type=d.T.string)]),
            withUser(user): { run+: { securityContext+: { seLinuxOptions+: { user: user } } } },
          },
          '#seccompProfile':: d.obj(help=''),
          seccompProfile: {
            '#withLocalhostProfile':: d.fn(help='', args=[d.arg(name='localhostProfile', type=d.T.string)]),
            withLocalhostProfile(localhostProfile): { run+: { securityContext+: { seccompProfile+: { localhostProfile: localhostProfile } } } },
            '#withType':: d.fn(help='', args=[d.arg(name='type', type=d.T.string)]),
            withType(type): { run+: { securityContext+: { seccompProfile+: { type: type } } } },
          },
          '#windowsOptions':: d.obj(help=''),
          windowsOptions: {
            '#withGmsaCredentialSpec':: d.fn(help='', args=[d.arg(name='gmsaCredentialSpec', type=d.T.string)]),
            withGmsaCredentialSpec(gmsaCredentialSpec): { run+: { securityContext+: { windowsOptions+: { gmsaCredentialSpec: gmsaCredentialSpec } } } },
            '#withGmsaCredentialSpecName':: d.fn(help='', args=[d.arg(name='gmsaCredentialSpecName', type=d.T.string)]),
            withGmsaCredentialSpecName(gmsaCredentialSpecName): { run+: { securityContext+: { windowsOptions+: { gmsaCredentialSpecName: gmsaCredentialSpecName } } } },
            '#withHostProcess':: d.fn(help='', args=[d.arg(name='hostProcess', type=d.T.boolean)]),
            withHostProcess(hostProcess): { run+: { securityContext+: { windowsOptions+: { hostProcess: hostProcess } } } },
            '#withRunAsUserName':: d.fn(help='', args=[d.arg(name='runAsUserName', type=d.T.string)]),
            withRunAsUserName(runAsUserName): { run+: { securityContext+: { windowsOptions+: { runAsUserName: runAsUserName } } } },
          },
          '#withAllowPrivilegeEscalation':: d.fn(help='', args=[d.arg(name='allowPrivilegeEscalation', type=d.T.boolean)]),
          withAllowPrivilegeEscalation(allowPrivilegeEscalation): { run+: { securityContext+: { allowPrivilegeEscalation: allowPrivilegeEscalation } } },
          '#withPrivileged':: d.fn(help='', args=[d.arg(name='privileged', type=d.T.boolean)]),
          withPrivileged(privileged): { run+: { securityContext+: { privileged: privileged } } },
          '#withProcMount':: d.fn(help='', args=[d.arg(name='procMount', type=d.T.string)]),
          withProcMount(procMount): { run+: { securityContext+: { procMount: procMount } } },
          '#withReadOnlyRootFilesystem':: d.fn(help='', args=[d.arg(name='readOnlyRootFilesystem', type=d.T.boolean)]),
          withReadOnlyRootFilesystem(readOnlyRootFilesystem): { run+: { securityContext+: { readOnlyRootFilesystem: readOnlyRootFilesystem } } },
          '#withRunAsGroup':: d.fn(help='', args=[d.arg(name='runAsGroup', type=d.T.integer)]),
          withRunAsGroup(runAsGroup): { run+: { securityContext+: { runAsGroup: runAsGroup } } },
          '#withRunAsNonRoot':: d.fn(help='', args=[d.arg(name='runAsNonRoot', type=d.T.boolean)]),
          withRunAsNonRoot(runAsNonRoot): { run+: { securityContext+: { runAsNonRoot: runAsNonRoot } } },
          '#withRunAsUser':: d.fn(help='', args=[d.arg(name='runAsUser', type=d.T.integer)]),
          withRunAsUser(runAsUser): { run+: { securityContext+: { runAsUser: runAsUser } } },
        },
        '#volumeMounts':: d.obj(help=''),
        volumeMounts: {
          '#withMountPath':: d.fn(help='', args=[d.arg(name='mountPath', type=d.T.string)]),
          withMountPath(mountPath): { mountPath: mountPath },
          '#withMountPropagation':: d.fn(help='', args=[d.arg(name='mountPropagation', type=d.T.string)]),
          withMountPropagation(mountPropagation): { mountPropagation: mountPropagation },
          '#withName':: d.fn(help='', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { name: name },
          '#withReadOnly':: d.fn(help='', args=[d.arg(name='readOnly', type=d.T.boolean)]),
          withReadOnly(readOnly): { readOnly: readOnly },
          '#withRecursiveReadOnly':: d.fn(help='', args=[d.arg(name='recursiveReadOnly', type=d.T.string)]),
          withRecursiveReadOnly(recursiveReadOnly): { recursiveReadOnly: recursiveReadOnly },
          '#withSubPath':: d.fn(help='', args=[d.arg(name='subPath', type=d.T.string)]),
          withSubPath(subPath): { subPath: subPath },
          '#withSubPathExpr':: d.fn(help='', args=[d.arg(name='subPathExpr', type=d.T.string)]),
          withSubPathExpr(subPathExpr): { subPathExpr: subPathExpr },
        },
        '#withArgs':: d.fn(help='"override default command in the image (empty string to default CMD of the image)"', args=[d.arg(name='args', type=d.T.array)]),
        withArgs(args): { run+: { args: if std.isArray(v=args) then args else [args] } },
        '#withArgsMixin':: d.fn(help='"override default command in the image (empty string to default CMD of the image)"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='args', type=d.T.array)]),
        withArgsMixin(args): { run+: { args+: if std.isArray(v=args) then args else [args] } },
        '#withCommand':: d.fn(help='"override default command in the image (empty string to default ENTRYPOINT of the image)"', args=[d.arg(name='command', type=d.T.array)]),
        withCommand(command): { run+: { command: if std.isArray(v=command) then command else [command] } },
        '#withCommandMixin':: d.fn(help='"override default command in the image (empty string to default ENTRYPOINT of the image)"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='command', type=d.T.array)]),
        withCommandMixin(command): { run+: { command+: if std.isArray(v=command) then command else [command] } },
        '#withEnv':: d.fn(help='', args=[d.arg(name='env', type=d.T.array)]),
        withEnv(env): { run+: { env: if std.isArray(v=env) then env else [env] } },
        '#withEnvFrom':: d.fn(help='', args=[d.arg(name='envFrom', type=d.T.array)]),
        withEnvFrom(envFrom): { run+: { envFrom: if std.isArray(v=envFrom) then envFrom else [envFrom] } },
        '#withEnvFromMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='envFrom', type=d.T.array)]),
        withEnvFromMixin(envFrom): { run+: { envFrom+: if std.isArray(v=envFrom) then envFrom else [envFrom] } },
        '#withEnvMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='env', type=d.T.array)]),
        withEnvMixin(env): { run+: { env+: if std.isArray(v=env) then env else [env] } },
        '#withImage':: d.fn(help='"image to be used for the container"', args=[d.arg(name='image', type=d.T.string)]),
        withImage(image): { run+: { image: image } },
        '#withImagePullPolicy':: d.fn(help='"pulling policy for the image"', args=[d.arg(name='imagePullPolicy', type=d.T.string)]),
        withImagePullPolicy(imagePullPolicy): { run+: { imagePullPolicy: imagePullPolicy } },
        '#withShell':: d.fn(help='"script to run in a default shell for the container"', args=[d.arg(name='shell', type=d.T.string)]),
        withShell(shell): { run+: { shell: shell } },
        '#withVolumeMounts':: d.fn(help='', args=[d.arg(name='volumeMounts', type=d.T.array)]),
        withVolumeMounts(volumeMounts): { run+: { volumeMounts: if std.isArray(v=volumeMounts) then volumeMounts else [volumeMounts] } },
        '#withVolumeMountsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='volumeMounts', type=d.T.array)]),
        withVolumeMountsMixin(volumeMounts): { run+: { volumeMounts+: if std.isArray(v=volumeMounts) then volumeMounts else [volumeMounts] } },
        '#withWorkingDir':: d.fn(help='"override default working directory in the image (empty string to default WORKDIR for the image)"', args=[d.arg(name='workingDir', type=d.T.string)]),
        withWorkingDir(workingDir): { run+: { workingDir: workingDir } },
      },
      '#withCondition':: d.fn(help='"expression to declare under which conditions the step should be run\\ndefaults to: \\"passed\\", except artifacts where it defaults to \\"always\\', args=[d.arg(name='condition', type=d.T.string)]),
      withCondition(condition): { condition: condition },
      '#withDelay':: d.fn(help='"delay before the step"', args=[d.arg(name='delay', type=d.T.string)]),
      withDelay(delay): { delay: delay },
      '#withName':: d.fn(help='"readable name for the step"', args=[d.arg(name='name', type=d.T.string)]),
      withName(name): { name: name },
      '#withNegative':: d.fn(help='"is the step expected to fail"', args=[d.arg(name='negative', type=d.T.boolean)]),
      withNegative(negative): { negative: negative },
      '#withOptional':: d.fn(help="\"is the step optional, so its failure won't affect the TestWorkflow result\"", args=[d.arg(name='optional', type=d.T.boolean)]),
      withOptional(optional): { optional: optional },
      '#withPaused':: d.fn(help='"pause the step initially"', args=[d.arg(name='paused', type=d.T.boolean)]),
      withPaused(paused): { paused: paused },
      '#withPure':: d.fn(help='"mark the step as pure, applying optimizations to merge the containers together"', args=[d.arg(name='pure', type=d.T.boolean)]),
      withPure(pure): { pure: pure },
      '#withServices':: d.fn(help='"list of accompanying services to start"', args=[d.arg(name='services', type=d.T.object)]),
      withServices(services): { services: services },
      '#withServicesMixin':: d.fn(help='"list of accompanying services to start"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='services', type=d.T.object)]),
      withServicesMixin(services): { services+: services },
      '#withSetup':: d.fn(help='"steps to run before other operations in this step"', args=[d.arg(name='setup', type=d.T.any)]),
      withSetup(setup): { setup: setup },
      '#withShell':: d.fn(help='"script to run in a default shell for the container"', args=[d.arg(name='shell', type=d.T.string)]),
      withShell(shell): { shell: shell },
      '#withSteps':: d.fn(help='"sub-steps to run"', args=[d.arg(name='steps', type=d.T.any)]),
      withSteps(steps): { steps: steps },
      '#withTimeout':: d.fn(help='"maximum time this step may take"', args=[d.arg(name='timeout', type=d.T.string)]),
      withTimeout(timeout): { timeout: timeout },
      '#withWorkingDir':: d.fn(help='"working directory to use for this step"', args=[d.arg(name='workingDir', type=d.T.string)]),
      withWorkingDir(workingDir): { workingDir: workingDir },
    },
    '#system':: d.obj(help='"system configuration to define the orchestration behavior"'),
    system: {
      '#withIsolatedContainers':: d.fn(help='"disable the behavior of merging multiple operations in a single container"', args=[d.arg(name='isolatedContainers', type=d.T.boolean)]),
      withIsolatedContainers(isolatedContainers): { spec+: { system+: { isolatedContainers: isolatedContainers } } },
      '#withPureByDefault':: d.fn(help='"assume all the steps are pure by default"', args=[d.arg(name='pureByDefault', type=d.T.boolean)]),
      withPureByDefault(pureByDefault): { spec+: { system+: { pureByDefault: pureByDefault } } },
    },
    '#withAfter':: d.fn(help='"steps to run at the end of the workflow"', args=[d.arg(name='after', type=d.T.array)]),
    withAfter(after): { spec+: { after: if std.isArray(v=after) then after else [after] } },
    '#withAfterMixin':: d.fn(help='"steps to run at the end of the workflow"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='after', type=d.T.array)]),
    withAfterMixin(after): { spec+: { after+: if std.isArray(v=after) then after else [after] } },
    '#withConfig':: d.fn(help='"make the instance configurable with some input data for scheduling it"', args=[d.arg(name='config', type=d.T.object)]),
    withConfig(config): { spec+: { config: config } },
    '#withConfigMixin':: d.fn(help='"make the instance configurable with some input data for scheduling it"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='config', type=d.T.object)]),
    withConfigMixin(config): { spec+: { config+: config } },
    '#withEvents':: d.fn(help='"events triggering execution of the test workflow"', args=[d.arg(name='events', type=d.T.array)]),
    withEvents(events): { spec+: { events: if std.isArray(v=events) then events else [events] } },
    '#withEventsMixin':: d.fn(help='"events triggering execution of the test workflow"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='events', type=d.T.array)]),
    withEventsMixin(events): { spec+: { events+: if std.isArray(v=events) then events else [events] } },
    '#withPvcs':: d.fn(help='', args=[d.arg(name='pvcs', type=d.T.object)]),
    withPvcs(pvcs): { spec+: { pvcs: pvcs } },
    '#withPvcsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='pvcs', type=d.T.object)]),
    withPvcsMixin(pvcs): { spec+: { pvcs+: pvcs } },
    '#withServices':: d.fn(help='"list of accompanying services to start"', args=[d.arg(name='services', type=d.T.object)]),
    withServices(services): { spec+: { services: services } },
    '#withServicesMixin':: d.fn(help='"list of accompanying services to start"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='services', type=d.T.object)]),
    withServicesMixin(services): { spec+: { services+: services } },
    '#withSetup':: d.fn(help='"steps for setting up the workflow"', args=[d.arg(name='setup', type=d.T.array)]),
    withSetup(setup): { spec+: { setup: if std.isArray(v=setup) then setup else [setup] } },
    '#withSetupMixin':: d.fn(help='"steps for setting up the workflow"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='setup', type=d.T.array)]),
    withSetupMixin(setup): { spec+: { setup+: if std.isArray(v=setup) then setup else [setup] } },
    '#withSteps':: d.fn(help='"steps to execute in the workflow"', args=[d.arg(name='steps', type=d.T.array)]),
    withSteps(steps): { spec+: { steps: if std.isArray(v=steps) then steps else [steps] } },
    '#withStepsMixin':: d.fn(help='"steps to execute in the workflow"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='steps', type=d.T.array)]),
    withStepsMixin(steps): { spec+: { steps+: if std.isArray(v=steps) then steps else [steps] } },
  },
  '#withDescription':: d.fn(help='"TestWorkflowTemplate readable description"', args=[d.arg(name='description', type=d.T.string)]),
  withDescription(description): { description: description },
  '#mixin': 'ignore',
  mixin: self,
}
